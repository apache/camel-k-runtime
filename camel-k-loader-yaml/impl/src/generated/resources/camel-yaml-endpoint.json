{
  "$schema" : "http://json-schema.org/draft-04/schema#",
  "type" : "object",
  "definitions" : {
    "activemq" : {
      "type" : "object",
      "required" : [ "destinationName" ],
      "properties" : {
        "destination-name" : {
          "description" : "Name of the queue or topic to use as destination",
          "type" : "string"
        },
        "destination-type" : {
          "description" : "The kind of destination to use",
          "default" : "queue",
          "enum" : [ "queue", "topic", "temp-queue", "temp-topic" ],
          "type" : "string"
        },
        "accept-messages-while-stopping" : {
          "description" : "Specifies whether the consumer accept messages while it is stopping. You may consider enabling this option, if you start and stop JMS routes at runtime, while there are still messages enqueued on the queue. If this option is false, and you stop the JMS route, then messages may be rejected, and the JMS broker would have to attempt redeliveries, which yet again may be rejected, and eventually the message may be moved at a dead letter queue on the JMS broker. To avoid this its recommended to enable this option.",
          "default" : "false",
          "type" : "boolean"
        },
        "acknowledgement-mode-name" : {
          "description" : "The JMS acknowledgement name, which is one of: SESSION_TRANSACTED, CLIENT_ACKNOWLEDGE, AUTO_ACKNOWLEDGE, DUPS_OK_ACKNOWLEDGE",
          "default" : "AUTO_ACKNOWLEDGE",
          "enum" : [ "SESSION_TRANSACTED", "CLIENT_ACKNOWLEDGE", "AUTO_ACKNOWLEDGE", "DUPS_OK_ACKNOWLEDGE" ],
          "type" : "string"
        },
        "allow-additional-headers" : {
          "description" : "This option is used to allow additional headers which may have values that are invalid according to JMS specification. For example some message systems such as WMQ do this with header names using prefix JMS_IBM_MQMD_ containing values with byte array or other invalid types. You can specify multiple header names separated by comma, and use as suffix for wildcard matching.",
          "type" : "string"
        },
        "allow-null-body" : {
          "description" : "Whether to allow sending messages with no body. If this option is false and the message body is null, then an JMSException is thrown.",
          "default" : "true",
          "type" : "boolean"
        },
        "allow-reply-manager-quick-stop" : {
          "description" : "Whether the DefaultMessageListenerContainer used in the reply managers for request-reply messaging allow the DefaultMessageListenerContainer.runningAllowed flag to quick stop in case JmsConfiguration#isAcceptMessagesWhileStopping is enabled, and org.apache.camel.CamelContext is currently being stopped. This quick stop ability is enabled by default in the regular JMS consumers but to enable for reply managers you must enable this flag.",
          "default" : "false",
          "type" : "boolean"
        },
        "allow-serialized-headers" : {
          "description" : "Controls whether or not to include serialized headers. Applies only when transferExchange is true. This requires that the objects are serializable. Camel will exclude any non-serializable objects and log it at WARN level.",
          "default" : "false",
          "type" : "boolean"
        },
        "always-copy-message" : {
          "description" : "If true, Camel will always make a JMS message copy of the message when it is passed to the producer for sending. Copying the message is needed in some situations, such as when a replyToDestinationSelectorName is set (incidentally, Camel will set the alwaysCopyMessage option to true, if a replyToDestinationSelectorName is set)",
          "default" : "false",
          "type" : "boolean"
        },
        "artemis-streaming-enabled" : {
          "description" : "Whether optimizing for Apache Artemis streaming mode.",
          "default" : "true",
          "type" : "boolean"
        },
        "async-consumer" : {
          "description" : "Whether the JmsConsumer processes the Exchange asynchronously. If enabled then the JmsConsumer may pickup the next message from the JMS queue, while the previous message is being processed asynchronously (by the Asynchronous Routing Engine). This means that messages may be processed not 100% strictly in order. If disabled (as default) then the Exchange is fully processed before the JmsConsumer will pickup the next message from the JMS queue. Note if transacted has been enabled, then asyncConsumer=true does not run asynchronously, as transaction must be executed synchronously (Camel 3.0 may support async transactions).",
          "default" : "false",
          "type" : "boolean"
        },
        "async-start-listener" : {
          "description" : "Whether to startup the JmsConsumer message listener asynchronously, when starting a route. For example if a JmsConsumer cannot get a connection to a remote JMS broker, then it may block while retrying and/or failover. This will cause Camel to block while starting routes. By setting this option to true, you will let routes startup, while the JmsConsumer connects to the JMS broker using a dedicated thread in asynchronous mode. If this option is used, then beware that if the connection could not be established, then an exception is logged at WARN level, and the consumer will not be able to receive messages; You can then restart the route to retry.",
          "default" : "false",
          "type" : "boolean"
        },
        "async-stop-listener" : {
          "description" : "Whether to stop the JmsConsumer message listener asynchronously, when stopping a route.",
          "default" : "false",
          "type" : "boolean"
        },
        "auto-startup" : {
          "description" : "Specifies whether the consumer container should auto-startup.",
          "default" : "true",
          "type" : "boolean"
        },
        "cache-level" : {
          "description" : "Sets the cache level by ID for the underlying JMS resources. See cacheLevelName option for more details.",
          "type" : "integer"
        },
        "cache-level-name" : {
          "description" : "Sets the cache level by name for the underlying JMS resources. Possible values are: CACHE_AUTO, CACHE_CONNECTION, CACHE_CONSUMER, CACHE_NONE, and CACHE_SESSION. The default setting is CACHE_AUTO. See the Spring documentation and Transactions Cache Levels for more information.",
          "default" : "CACHE_AUTO",
          "enum" : [ "CACHE_AUTO", "CACHE_CONNECTION", "CACHE_CONSUMER", "CACHE_NONE", "CACHE_SESSION" ],
          "type" : "string"
        },
        "client-id" : {
          "description" : "Sets the JMS client ID to use. Note that this value, if specified, must be unique and can only be used by a single JMS connection instance. It is typically only required for durable topic subscriptions. If using Apache ActiveMQ you may prefer to use Virtual Topics instead.",
          "type" : "string"
        },
        "concurrent-consumers" : {
          "description" : "Specifies the default number of concurrent consumers when consuming from JMS (not for request/reply over JMS). See also the maxMessagesPerTask option to control dynamic scaling up/down of threads. When doing request/reply over JMS then the option replyToConcurrentConsumers is used to control number of concurrent consumers on the reply message listener.",
          "default" : "1",
          "type" : "integer"
        },
        "connection-factory" : {
          "description" : "The connection factory to be use. A connection factory must be configured either on the component or endpoint.",
          "type" : "string"
        },
        "consumer-type" : {
          "description" : "The consumer type to use, which can be one of: Simple, Default, or Custom. The consumer type determines which Spring JMS listener to use. Default will use org.springframework.jms.listener.DefaultMessageListenerContainer, Simple will use org.springframework.jms.listener.SimpleMessageListenerContainer. When Custom is specified, the MessageListenerContainerFactory defined by the messageListenerContainerFactory option will determine what org.springframework.jms.listener.AbstractMessageListenerContainer to use.",
          "default" : "Default",
          "enum" : [ "Simple", "Default", "Custom" ],
          "type" : "string"
        },
        "correlation-property" : {
          "description" : "When using InOut exchange pattern use this JMS property instead of JMSCorrelationID JMS property to correlate messages. If set messages will be correlated solely on the value of this property JMSCorrelationID property will be ignored and not set by Camel.",
          "type" : "string"
        },
        "default-task-executor-type" : {
          "description" : "Specifies what default TaskExecutor type to use in the DefaultMessageListenerContainer, for both consumer endpoints and the ReplyTo consumer of producer endpoints. Possible values: SimpleAsync (uses Spring's SimpleAsyncTaskExecutor) or ThreadPool (uses Spring's ThreadPoolTaskExecutor with optimal values - cached threadpool-like). If not set, it defaults to the previous behaviour, which uses a cached thread pool for consumer endpoints and SimpleAsync for reply consumers. The use of ThreadPool is recommended to reduce thread trash in elastic configurations with dynamically increasing and decreasing concurrent consumers.",
          "enum" : [ "ThreadPool", "SimpleAsync" ],
          "type" : "string"
        },
        "delivery-delay" : {
          "description" : "Sets delivery delay to use for send calls for JMS. This option requires JMS 2.0 compliant broker.",
          "default" : "-1",
          "type" : "integer"
        },
        "delivery-mode" : {
          "description" : "Specifies the delivery mode to be used. Possible values are those defined by javax.jms.DeliveryMode. NON_PERSISTENT = 1 and PERSISTENT = 2.",
          "enum" : [ "1", "2" ],
          "type" : "integer"
        },
        "delivery-persistent" : {
          "description" : "Specifies whether persistent delivery is used by default.",
          "default" : "true",
          "type" : "boolean"
        },
        "destination-resolver" : {
          "description" : "A pluggable org.springframework.jms.support.destination.DestinationResolver that allows you to use your own resolver (for example, to lookup the real destination in a JNDI registry).",
          "type" : "string"
        },
        "disable-reply-to" : {
          "description" : "Specifies whether Camel ignores the JMSReplyTo header in messages. If true, Camel does not send a reply back to the destination specified in the JMSReplyTo header. You can use this option if you want Camel to consume from a route and you do not want Camel to automatically send back a reply message because another component in your code handles the reply message. You can also use this option if you want to use Camel as a proxy between different message brokers and you want to route message from one system to another.",
          "default" : "false",
          "type" : "boolean"
        },
        "disable-time-to-live" : {
          "description" : "Use this option to force disabling time to live. For example when you do request/reply over JMS, then Camel will by default use the requestTimeout value as time to live on the message being sent. The problem is that the sender and receiver systems have to have their clocks synchronized, so they are in sync. This is not always so easy to archive. So you can use disableTimeToLive=true to not set a time to live value on the sent message. Then the message will not expire on the receiver system. See below in section About time to live for more details.",
          "default" : "false",
          "type" : "boolean"
        },
        "durable-subscription-name" : {
          "description" : "The durable subscriber name for specifying durable topic subscriptions. The clientId option must be configured as well.",
          "type" : "string"
        },
        "eager-loading-of-properties" : {
          "description" : "Enables eager loading of JMS properties and payload as soon as a message is loaded which generally is inefficient as the JMS properties may not be required but sometimes can catch early any issues with the underlying JMS provider and the use of JMS properties. See also the option eagerPoisonBody.",
          "default" : "false",
          "type" : "boolean"
        },
        "eager-poison-body" : {
          "description" : "If eagerLoadingOfProperties is enabled and the JMS message payload (JMS body or JMS properties) is poison (cannot be read/mapped), then set this text as the message body instead so the message can be processed (the cause of the poison are already stored as exception on the Exchange). This can be turned off by setting eagerPoisonBody=false. See also the option eagerLoadingOfProperties.",
          "default" : "Poison JMS message due to ${exception.message}",
          "type" : "string"
        },
        "error-handler" : {
          "description" : "Specifies a org.springframework.util.ErrorHandler to be invoked in case of any uncaught exceptions thrown while processing a Message. By default these exceptions will be logged at the WARN level, if no errorHandler has been configured. You can configure logging level and whether stack traces should be logged using errorHandlerLoggingLevel and errorHandlerLogStackTrace options. This makes it much easier to configure, than having to code a custom errorHandler.",
          "type" : "string"
        },
        "error-handler-log-stack-trace" : {
          "description" : "Allows to control whether stacktraces should be logged or not, by the default errorHandler.",
          "default" : "true",
          "type" : "boolean"
        },
        "error-handler-logging-level" : {
          "description" : "Allows to configure the default errorHandler logging level for logging uncaught exceptions.",
          "default" : "WARN",
          "enum" : [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ],
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exception-listener" : {
          "description" : "Specifies the JMS Exception Listener that is to be notified of any underlying JMS exceptions.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "explicit-qos-enabled" : {
          "description" : "Set if the deliveryMode, priority or timeToLive qualities of service should be used when sending messages. This option is based on Spring's JmsTemplate. The deliveryMode, priority and timeToLive options are applied to the current endpoint. This contrasts with the preserveMessageQos option, which operates at message granularity, reading QoS properties exclusively from the Camel In message headers.",
          "default" : "false",
          "type" : "boolean"
        },
        "expose-listener-session" : {
          "description" : "Specifies whether the listener session should be exposed when consuming messages.",
          "default" : "false",
          "type" : "boolean"
        },
        "force-send-original-message" : {
          "description" : "When using mapJmsMessage=false Camel will create a new JMS message to send to a new JMS destination if you touch the headers (get or set) during the route. Set this option to true to force Camel to send the original JMS message that was received.",
          "default" : "false",
          "type" : "boolean"
        },
        "format-date-headers-to-iso8601" : {
          "description" : "Sets whether JMS date properties should be formatted according to the ISO 8601 standard.",
          "default" : "false",
          "type" : "boolean"
        },
        "header-filter-strategy" : {
          "description" : "To use a custom HeaderFilterStrategy to filter header to and from Camel message.",
          "type" : "string"
        },
        "idle-consumer-limit" : {
          "description" : "Specify the limit for the number of consumers that are allowed to be idle at any given time.",
          "default" : "1",
          "type" : "integer"
        },
        "idle-task-execution-limit" : {
          "description" : "Specifies the limit for idle executions of a receive task, not having received any message within its execution. If this limit is reached, the task will shut down and leave receiving to other executing tasks (in the case of dynamic scheduling; see the maxConcurrentConsumers setting). There is additional doc available from Spring.",
          "default" : "1",
          "type" : "integer"
        },
        "include-all-jmsx-properties" : {
          "description" : "Whether to include all JMSXxxx properties when mapping from JMS to Camel Message. Setting this to true will include properties such as JMSXAppID, and JMSXUserID etc. Note: If you are using a custom headerFilterStrategy then this option does not apply.",
          "default" : "false",
          "type" : "boolean"
        },
        "include-sent-jms-message-id" : {
          "description" : "Only applicable when sending to JMS destination using InOnly (eg fire and forget). Enabling this option will enrich the Camel Exchange with the actual JMSMessageID that was used by the JMS client when the message was sent to the JMS destination.",
          "default" : "false",
          "type" : "boolean"
        },
        "jms-key-format-strategy" : {
          "description" : "Pluggable strategy for encoding and decoding JMS keys so they can be compliant with the JMS specification. Camel provides two implementations out of the box: default and passthrough. The default strategy will safely marshal dots and hyphens (. and -). The passthrough strategy leaves the key as is. Can be used for JMS brokers which do not care whether JMS header keys contain illegal characters. You can provide your own implementation of the org.apache.camel.component.jms.JmsKeyFormatStrategy and refer to it using the # notation.",
          "enum" : [ "default", "passthrough" ],
          "type" : "string"
        },
        "jms-message-type" : {
          "description" : "Allows you to force the use of a specific javax.jms.Message implementation for sending JMS messages. Possible values are: Bytes, Map, Object, Stream, Text. By default, Camel would determine which JMS message type to use from the In body type. This option allows you to specify it.",
          "enum" : [ "Bytes", "Map", "Object", "Stream", "Text" ],
          "type" : "string"
        },
        "lazy-create-transaction-manager" : {
          "description" : "If true, Camel will create a JmsTransactionManager, if there is no transactionManager injected when option transacted=true.",
          "default" : "true",
          "type" : "boolean"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "map-jms-message" : {
          "description" : "Specifies whether Camel should auto map the received JMS message to a suited payload type, such as javax.jms.TextMessage to a String etc.",
          "default" : "true",
          "type" : "boolean"
        },
        "max-concurrent-consumers" : {
          "description" : "Specifies the maximum number of concurrent consumers when consuming from JMS (not for request/reply over JMS). See also the maxMessagesPerTask option to control dynamic scaling up/down of threads. When doing request/reply over JMS then the option replyToMaxConcurrentConsumers is used to control number of concurrent consumers on the reply message listener.",
          "type" : "integer"
        },
        "max-messages-per-task" : {
          "description" : "The number of messages per task. -1 is unlimited. If you use a range for concurrent consumers (eg min max), then this option can be used to set a value to eg 100 to control how fast the consumers will shrink when less work is required.",
          "default" : "-1",
          "type" : "integer"
        },
        "message-converter" : {
          "description" : "To use a custom Spring org.springframework.jms.support.converter.MessageConverter so you can be in control how to map to/from a javax.jms.Message.",
          "type" : "string"
        },
        "message-created-strategy" : {
          "description" : "To use the given MessageCreatedStrategy which are invoked when Camel creates new instances of javax.jms.Message objects when Camel is sending a JMS message.",
          "type" : "string"
        },
        "message-id-enabled" : {
          "description" : "When sending, specifies whether message IDs should be added. This is just an hint to the JMS broker. If the JMS provider accepts this hint, these messages must have the message ID set to null; if the provider ignores the hint, the message ID must be set to its normal unique value.",
          "default" : "true",
          "type" : "boolean"
        },
        "message-listener-container-factory" : {
          "description" : "Registry ID of the MessageListenerContainerFactory used to determine what org.springframework.jms.listener.AbstractMessageListenerContainer to use to consume messages. Setting this will automatically set consumerType to Custom.",
          "type" : "string"
        },
        "message-timestamp-enabled" : {
          "description" : "Specifies whether timestamps should be enabled by default on sending messages. This is just an hint to the JMS broker. If the JMS provider accepts this hint, these messages must have the timestamp set to zero; if the provider ignores the hint the timestamp must be set to its normal value.",
          "default" : "true",
          "type" : "boolean"
        },
        "password" : {
          "description" : "Password to use with the ConnectionFactory. You can also configure username/password directly on the ConnectionFactory.",
          "type" : "string"
        },
        "preserve-message-qos" : {
          "description" : "Set to true, if you want to send message using the QoS settings specified on the message, instead of the QoS settings on the JMS endpoint. The following three headers are considered JMSPriority, JMSDeliveryMode, and JMSExpiration. You can provide all or only some of them. If not provided, Camel will fall back to use the values from the endpoint instead. So, when using this option, the headers override the values from the endpoint. The explicitQosEnabled option, by contrast, will only use options set on the endpoint, and not values from the message header.",
          "default" : "false",
          "type" : "boolean"
        },
        "priority" : {
          "description" : "Values greater than 1 specify the message priority when sending (where 0 is the lowest priority and 9 is the highest). The explicitQosEnabled option must also be enabled in order for this option to have any effect.",
          "default" : "4",
          "enum" : [ "1", "2", "3", "4", "5", "6", "7", "8", "9" ],
          "type" : "integer"
        },
        "pub-sub-no-local" : {
          "description" : "Specifies whether to inhibit the delivery of messages published by its own connection.",
          "default" : "false",
          "type" : "boolean"
        },
        "receive-timeout" : {
          "description" : "The timeout for receiving messages (in milliseconds).",
          "default" : "1000",
          "type" : "string"
        },
        "recovery-interval" : {
          "description" : "Specifies the interval between recovery attempts, i.e. when a connection is being refreshed, in milliseconds. The default is 5000 ms, that is, 5 seconds.",
          "default" : "5000",
          "type" : "string"
        },
        "reply-to" : {
          "description" : "Provides an explicit ReplyTo destination (overrides any incoming value of Message.getJMSReplyTo() in consumer).",
          "type" : "string"
        },
        "reply-to-cache-level-name" : {
          "description" : "Sets the cache level by name for the reply consumer when doing request/reply over JMS. This option only applies when using fixed reply queues (not temporary). Camel will by default use: CACHE_CONSUMER for exclusive or shared w/ replyToSelectorName. And CACHE_SESSION for shared without replyToSelectorName. Some JMS brokers such as IBM WebSphere may require to set the replyToCacheLevelName=CACHE_NONE to work. Note: If using temporary queues then CACHE_NONE is not allowed, and you must use a higher value such as CACHE_CONSUMER or CACHE_SESSION.",
          "enum" : [ "CACHE_AUTO", "CACHE_CONNECTION", "CACHE_CONSUMER", "CACHE_NONE", "CACHE_SESSION" ],
          "type" : "string"
        },
        "reply-to-concurrent-consumers" : {
          "description" : "Specifies the default number of concurrent consumers when doing request/reply over JMS. See also the maxMessagesPerTask option to control dynamic scaling up/down of threads.",
          "default" : "1",
          "type" : "integer"
        },
        "reply-to-delivery-persistent" : {
          "description" : "Specifies whether to use persistent delivery by default for replies.",
          "default" : "true",
          "type" : "boolean"
        },
        "reply-to-destination-selector-name" : {
          "description" : "Sets the JMS Selector using the fixed name to be used so you can filter out your own replies from the others when using a shared queue (that is, if you are not using a temporary reply queue).",
          "type" : "string"
        },
        "reply-to-max-concurrent-consumers" : {
          "description" : "Specifies the maximum number of concurrent consumers when using request/reply over JMS. See also the maxMessagesPerTask option to control dynamic scaling up/down of threads.",
          "type" : "integer"
        },
        "reply-to-on-timeout-max-concurrent-consumers" : {
          "description" : "Specifies the maximum number of concurrent consumers for continue routing when timeout occurred when using request/reply over JMS.",
          "default" : "1",
          "type" : "integer"
        },
        "reply-to-override" : {
          "description" : "Provides an explicit ReplyTo destination in the JMS message, which overrides the setting of replyTo. It is useful if you want to forward the message to a remote Queue and receive the reply message from the ReplyTo destination.",
          "type" : "string"
        },
        "reply-to-same-destination-allowed" : {
          "description" : "Whether a JMS consumer is allowed to send a reply message to the same destination that the consumer is using to consume from. This prevents an endless loop by consuming and sending back the same message to itself.",
          "default" : "false",
          "type" : "boolean"
        },
        "reply-to-type" : {
          "description" : "Allows for explicitly specifying which kind of strategy to use for replyTo queues when doing request/reply over JMS. Possible values are: Temporary, Shared, or Exclusive. By default Camel will use temporary queues. However if replyTo has been configured, then Shared is used by default. This option allows you to use exclusive queues instead of shared ones. See Camel JMS documentation for more details, and especially the notes about the implications if running in a clustered environment, and the fact that Shared reply queues has lower performance than its alternatives Temporary and Exclusive.",
          "enum" : [ "Temporary", "Shared", "Exclusive" ],
          "type" : "string"
        },
        "request-timeout" : {
          "description" : "The timeout for waiting for a reply when using the InOut Exchange Pattern (in milliseconds). The default is 20 seconds. You can include the header CamelJmsRequestTimeout to override this endpoint configured timeout value, and thus have per message individual timeout values. See also the requestTimeoutCheckerInterval option.",
          "default" : "20000",
          "type" : "string"
        },
        "request-timeout-checker-interval" : {
          "description" : "Configures how often Camel should check for timed out Exchanges when doing request/reply over JMS. By default Camel checks once per second. But if you must react faster when a timeout occurs, then you can lower this interval, to check more frequently. The timeout is determined by the option requestTimeout.",
          "default" : "1000",
          "type" : "string"
        },
        "selector" : {
          "description" : "Sets the JMS selector to use",
          "type" : "string"
        },
        "stream-message-type-enabled" : {
          "description" : "Sets whether StreamMessage type is enabled or not. Message payloads of streaming kind such as files, InputStream, etc will either by sent as BytesMessage or StreamMessage. This option controls which kind will be used. By default BytesMessage is used which enforces the entire message payload to be read into memory. By enabling this option the message payload is read into memory in chunks and each chunk is then written to the StreamMessage until no more data.",
          "default" : "false",
          "type" : "boolean"
        },
        "subscription-durable" : {
          "description" : "Set whether to make the subscription durable. The durable subscription name to be used can be specified through the subscriptionName property. Default is false. Set this to true to register a durable subscription, typically in combination with a subscriptionName value (unless your message listener class name is good enough as subscription name). Only makes sense when listening to a topic (pub-sub domain), therefore this method switches the pubSubDomain flag as well.",
          "default" : "false",
          "type" : "boolean"
        },
        "subscription-name" : {
          "description" : "Set the name of a subscription to create. To be applied in case of a topic (pub-sub domain) with a shared or durable subscription. The subscription name needs to be unique within this client's JMS client id. Default is the class name of the specified message listener. Note: Only 1 concurrent consumer (which is the default of this message listener container) is allowed for each subscription, except for a shared subscription (which requires JMS 2.0).",
          "type" : "string"
        },
        "subscription-shared" : {
          "description" : "Set whether to make the subscription shared. The shared subscription name to be used can be specified through the subscriptionName property. Default is false. Set this to true to register a shared subscription, typically in combination with a subscriptionName value (unless your message listener class name is good enough as subscription name). Note that shared subscriptions may also be durable, so this flag can (and often will) be combined with subscriptionDurable as well. Only makes sense when listening to a topic (pub-sub domain), therefore this method switches the pubSubDomain flag as well. Requires a JMS 2.0 compatible message broker.",
          "default" : "false",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "task-executor" : {
          "description" : "Allows you to specify a custom task executor for consuming messages.",
          "type" : "string"
        },
        "test-connection-on-startup" : {
          "description" : "Specifies whether to test the connection on startup. This ensures that when Camel starts that all the JMS consumers have a valid connection to the JMS broker. If a connection cannot be granted then Camel throws an exception on startup. This ensures that Camel is not started with failed connections. The JMS producers is tested as well.",
          "default" : "false",
          "type" : "boolean"
        },
        "time-to-live" : {
          "description" : "When sending messages, specifies the time-to-live of the message (in milliseconds).",
          "default" : "-1",
          "type" : "integer"
        },
        "transacted" : {
          "description" : "Specifies whether to use transacted mode",
          "default" : "false",
          "type" : "boolean"
        },
        "transacted-in-out" : {
          "description" : "Specifies whether InOut operations (request reply) default to using transacted mode If this flag is set to true, then Spring JmsTemplate will have sessionTransacted set to true, and the acknowledgeMode as transacted on the JmsTemplate used for InOut operations. Note from Spring JMS: that within a JTA transaction, the parameters passed to createQueue, createTopic methods are not taken into account. Depending on the Java EE transaction context, the container makes its own decisions on these values. Analogously, these parameters are not taken into account within a locally managed transaction either, since Spring JMS operates on an existing JMS Session in this case. Setting this flag to true will use a short local JMS transaction when running outside of a managed transaction, and a synchronized local JMS transaction in case of a managed transaction (other than an XA transaction) being present. This has the effect of a local JMS transaction being managed alongside the main transaction (which might be a native JDBC transaction), with the JMS transaction committing right after the main transaction.",
          "default" : "false",
          "type" : "boolean"
        },
        "transaction-manager" : {
          "description" : "The Spring transaction manager to use.",
          "type" : "string"
        },
        "transaction-name" : {
          "description" : "The name of the transaction to use.",
          "type" : "string"
        },
        "transaction-timeout" : {
          "description" : "The timeout value of the transaction (in seconds), if using transacted mode.",
          "default" : "-1",
          "type" : "integer"
        },
        "transfer-exception" : {
          "description" : "If enabled and you are using Request Reply messaging (InOut) and an Exchange failed on the consumer side, then the caused Exception will be send back in response as a javax.jms.ObjectMessage. If the client is Camel, the returned Exception is rethrown. This allows you to use Camel JMS as a bridge in your routing - for example, using persistent queues to enable robust routing. Notice that if you also have transferExchange enabled, this option takes precedence. The caught exception is required to be serializable. The original Exception on the consumer side can be wrapped in an outer exception such as org.apache.camel.RuntimeCamelException when returned to the producer. Use this with caution as the data is using Java Object serialization and requires the received to be able to deserialize the data at Class level, which forces a strong coupling between the producers and consumer!",
          "default" : "false",
          "type" : "boolean"
        },
        "transfer-exchange" : {
          "description" : "You can transfer the exchange over the wire instead of just the body and headers. The following fields are transferred: In body, Out body, Fault body, In headers, Out headers, Fault headers, exchange properties, exchange exception. This requires that the objects are serializable. Camel will exclude any non-serializable objects and log it at WARN level. You must enable this option on both the producer and consumer side, so Camel knows the payloads is an Exchange and not a regular payload. Use this with caution as the data is using Java Object serialization and requires the received to be able to deserialize the data at Class level, which forces a strong coupling between the producers and consumer having to use compatible Camel versions!",
          "default" : "false",
          "type" : "boolean"
        },
        "use-message-id-as-correlation-id" : {
          "description" : "Specifies whether JMSMessageID should always be used as JMSCorrelationID for InOut messages.",
          "default" : "false",
          "type" : "boolean"
        },
        "username" : {
          "description" : "Username to use with the ConnectionFactory. You can also configure username/password directly on the ConnectionFactory.",
          "type" : "string"
        },
        "wait-for-provision-correlation-to-be-updated-counter" : {
          "description" : "Number of times to wait for provisional correlation id to be updated to the actual correlation id when doing request/reply over JMS and when the option useMessageIDAsCorrelationID is enabled.",
          "default" : "50",
          "type" : "integer"
        },
        "wait-for-provision-correlation-to-be-updated-thread-sleeping-time" : {
          "description" : "Interval in millis to sleep each time while waiting for provisional correlation id to be updated.",
          "default" : "100",
          "type" : "string"
        }
      }
    },
    "ahc" : {
      "type" : "object",
      "required" : [ "httpUri" ],
      "properties" : {
        "http-uri" : {
          "description" : "The URI to use such as http://hostname:port/path",
          "type" : "string"
        },
        "binding" : {
          "description" : "To use a custom AhcBinding which allows to control how to bind between AHC and Camel.",
          "type" : "string"
        },
        "bridge-endpoint" : {
          "description" : "If the option is true, then the Exchange.HTTP_URI header is ignored, and use the endpoint's URI for request. You may also set the throwExceptionOnFailure to be false to let the AhcProducer send all the fault response back.",
          "default" : "false",
          "type" : "boolean"
        },
        "buffer-size" : {
          "description" : "The initial in-memory buffer size used when transferring data between Camel and AHC Client.",
          "default" : "4096",
          "type" : "integer"
        },
        "client-config" : {
          "description" : "To configure the AsyncHttpClient to use a custom com.ning.http.client.AsyncHttpClientConfig instance.",
          "type" : "string"
        },
        "client-config-options" : {
          "description" : "To configure the AsyncHttpClientConfig using the key/values from the Map.",
          "type" : "string"
        },
        "client-config-realm-options" : {
          "description" : "To configure the AsyncHttpClientConfig Realm using the key/values from the Map.",
          "type" : "string"
        },
        "connection-close" : {
          "description" : "Define if the Connection Close header has to be added to HTTP Request. This parameter is false by default",
          "default" : "false",
          "type" : "boolean"
        },
        "cookie-handler" : {
          "description" : "Configure a cookie handler to maintain a HTTP session",
          "type" : "string"
        },
        "header-filter-strategy" : {
          "description" : "To use a custom HeaderFilterStrategy to filter header to and from Camel message.",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "ssl-context-parameters" : {
          "description" : "Reference to a org.apache.camel.support.jsse.SSLContextParameters in the Registry. This reference overrides any configured SSLContextParameters at the component level. See Using the JSSE Configuration Utility. Note that configuring this option will override any SSL/TLS configuration options provided through the clientConfig option at the endpoint or component level.",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "throw-exception-on-failure" : {
          "description" : "Option to disable throwing the AhcOperationFailedException in case of failed responses from the remote server. This allows you to get all responses regardless of the HTTP status code.",
          "default" : "true",
          "type" : "boolean"
        },
        "transfer-exception" : {
          "description" : "If enabled and an Exchange failed processing on the consumer side, and if the caused Exception was send back serialized in the response as a application/x-java-serialized-object content type (for example using Jetty or Servlet Camel components). On the producer side the exception will be deserialized and thrown as is, instead of the AhcOperationFailedException. The caused exception is required to be serialized. This is by default turned off. If you enable this then be aware that Java will deserialize the incoming data from the request to Java and that can be a potential security risk.",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "ahc-ws" : {
      "type" : "object",
      "required" : [ "httpUri" ],
      "properties" : {
        "http-uri" : {
          "description" : "The URI to use such as http://hostname:port/path",
          "type" : "string"
        },
        "binding" : {
          "description" : "To use a custom AhcBinding which allows to control how to bind between AHC and Camel.",
          "type" : "string"
        },
        "bridge-endpoint" : {
          "description" : "If the option is true, then the Exchange.HTTP_URI header is ignored, and use the endpoint's URI for request. You may also set the throwExceptionOnFailure to be false to let the AhcProducer send all the fault response back.",
          "default" : "false",
          "type" : "boolean"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "buffer-size" : {
          "description" : "The initial in-memory buffer size used when transferring data between Camel and AHC Client.",
          "default" : "4096",
          "type" : "integer"
        },
        "client-config" : {
          "description" : "To configure the AsyncHttpClient to use a custom com.ning.http.client.AsyncHttpClientConfig instance.",
          "type" : "string"
        },
        "client-config-options" : {
          "description" : "To configure the AsyncHttpClientConfig using the key/values from the Map.",
          "type" : "string"
        },
        "client-config-realm-options" : {
          "description" : "To configure the AsyncHttpClientConfig Realm using the key/values from the Map.",
          "type" : "string"
        },
        "connection-close" : {
          "description" : "Define if the Connection Close header has to be added to HTTP Request. This parameter is false by default",
          "default" : "false",
          "type" : "boolean"
        },
        "cookie-handler" : {
          "description" : "Configure a cookie handler to maintain a HTTP session",
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "header-filter-strategy" : {
          "description" : "To use a custom HeaderFilterStrategy to filter header to and from Camel message.",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "send-message-on-error" : {
          "description" : "Whether to send an message if the web-socket listener received an error.",
          "default" : "false",
          "type" : "boolean"
        },
        "ssl-context-parameters" : {
          "description" : "Reference to a org.apache.camel.support.jsse.SSLContextParameters in the Registry. This reference overrides any configured SSLContextParameters at the component level. See Using the JSSE Configuration Utility. Note that configuring this option will override any SSL/TLS configuration options provided through the clientConfig option at the endpoint or component level.",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "throw-exception-on-failure" : {
          "description" : "Option to disable throwing the AhcOperationFailedException in case of failed responses from the remote server. This allows you to get all responses regardless of the HTTP status code.",
          "default" : "true",
          "type" : "boolean"
        },
        "transfer-exception" : {
          "description" : "If enabled and an Exchange failed processing on the consumer side, and if the caused Exception was send back serialized in the response as a application/x-java-serialized-object content type (for example using Jetty or Servlet Camel components). On the producer side the exception will be deserialized and thrown as is, instead of the AhcOperationFailedException. The caused exception is required to be serialized. This is by default turned off. If you enable this then be aware that Java will deserialize the incoming data from the request to Java and that can be a potential security risk.",
          "default" : "false",
          "type" : "boolean"
        },
        "use-streaming" : {
          "description" : "To enable streaming to send data as multiple text fragments.",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "ahc-wss" : {
      "type" : "object",
      "$ref" : "#/definitions/ahc-ws"
    },
    "amqp" : {
      "type" : "object",
      "required" : [ "destinationName" ],
      "properties" : {
        "destination-name" : {
          "description" : "Name of the queue or topic to use as destination",
          "type" : "string"
        },
        "destination-type" : {
          "description" : "The kind of destination to use",
          "default" : "queue",
          "enum" : [ "queue", "topic", "temp-queue", "temp-topic" ],
          "type" : "string"
        },
        "accept-messages-while-stopping" : {
          "description" : "Specifies whether the consumer accept messages while it is stopping. You may consider enabling this option, if you start and stop JMS routes at runtime, while there are still messages enqueued on the queue. If this option is false, and you stop the JMS route, then messages may be rejected, and the JMS broker would have to attempt redeliveries, which yet again may be rejected, and eventually the message may be moved at a dead letter queue on the JMS broker. To avoid this its recommended to enable this option.",
          "default" : "false",
          "type" : "boolean"
        },
        "acknowledgement-mode-name" : {
          "description" : "The JMS acknowledgement name, which is one of: SESSION_TRANSACTED, CLIENT_ACKNOWLEDGE, AUTO_ACKNOWLEDGE, DUPS_OK_ACKNOWLEDGE",
          "default" : "AUTO_ACKNOWLEDGE",
          "enum" : [ "SESSION_TRANSACTED", "CLIENT_ACKNOWLEDGE", "AUTO_ACKNOWLEDGE", "DUPS_OK_ACKNOWLEDGE" ],
          "type" : "string"
        },
        "allow-additional-headers" : {
          "description" : "This option is used to allow additional headers which may have values that are invalid according to JMS specification. For example some message systems such as WMQ do this with header names using prefix JMS_IBM_MQMD_ containing values with byte array or other invalid types. You can specify multiple header names separated by comma, and use as suffix for wildcard matching.",
          "type" : "string"
        },
        "allow-null-body" : {
          "description" : "Whether to allow sending messages with no body. If this option is false and the message body is null, then an JMSException is thrown.",
          "default" : "true",
          "type" : "boolean"
        },
        "allow-reply-manager-quick-stop" : {
          "description" : "Whether the DefaultMessageListenerContainer used in the reply managers for request-reply messaging allow the DefaultMessageListenerContainer.runningAllowed flag to quick stop in case JmsConfiguration#isAcceptMessagesWhileStopping is enabled, and org.apache.camel.CamelContext is currently being stopped. This quick stop ability is enabled by default in the regular JMS consumers but to enable for reply managers you must enable this flag.",
          "default" : "false",
          "type" : "boolean"
        },
        "allow-serialized-headers" : {
          "description" : "Controls whether or not to include serialized headers. Applies only when transferExchange is true. This requires that the objects are serializable. Camel will exclude any non-serializable objects and log it at WARN level.",
          "default" : "false",
          "type" : "boolean"
        },
        "always-copy-message" : {
          "description" : "If true, Camel will always make a JMS message copy of the message when it is passed to the producer for sending. Copying the message is needed in some situations, such as when a replyToDestinationSelectorName is set (incidentally, Camel will set the alwaysCopyMessage option to true, if a replyToDestinationSelectorName is set)",
          "default" : "false",
          "type" : "boolean"
        },
        "artemis-streaming-enabled" : {
          "description" : "Whether optimizing for Apache Artemis streaming mode.",
          "default" : "true",
          "type" : "boolean"
        },
        "async-consumer" : {
          "description" : "Whether the JmsConsumer processes the Exchange asynchronously. If enabled then the JmsConsumer may pickup the next message from the JMS queue, while the previous message is being processed asynchronously (by the Asynchronous Routing Engine). This means that messages may be processed not 100% strictly in order. If disabled (as default) then the Exchange is fully processed before the JmsConsumer will pickup the next message from the JMS queue. Note if transacted has been enabled, then asyncConsumer=true does not run asynchronously, as transaction must be executed synchronously (Camel 3.0 may support async transactions).",
          "default" : "false",
          "type" : "boolean"
        },
        "async-start-listener" : {
          "description" : "Whether to startup the JmsConsumer message listener asynchronously, when starting a route. For example if a JmsConsumer cannot get a connection to a remote JMS broker, then it may block while retrying and/or failover. This will cause Camel to block while starting routes. By setting this option to true, you will let routes startup, while the JmsConsumer connects to the JMS broker using a dedicated thread in asynchronous mode. If this option is used, then beware that if the connection could not be established, then an exception is logged at WARN level, and the consumer will not be able to receive messages; You can then restart the route to retry.",
          "default" : "false",
          "type" : "boolean"
        },
        "async-stop-listener" : {
          "description" : "Whether to stop the JmsConsumer message listener asynchronously, when stopping a route.",
          "default" : "false",
          "type" : "boolean"
        },
        "auto-startup" : {
          "description" : "Specifies whether the consumer container should auto-startup.",
          "default" : "true",
          "type" : "boolean"
        },
        "cache-level" : {
          "description" : "Sets the cache level by ID for the underlying JMS resources. See cacheLevelName option for more details.",
          "type" : "integer"
        },
        "cache-level-name" : {
          "description" : "Sets the cache level by name for the underlying JMS resources. Possible values are: CACHE_AUTO, CACHE_CONNECTION, CACHE_CONSUMER, CACHE_NONE, and CACHE_SESSION. The default setting is CACHE_AUTO. See the Spring documentation and Transactions Cache Levels for more information.",
          "default" : "CACHE_AUTO",
          "enum" : [ "CACHE_AUTO", "CACHE_CONNECTION", "CACHE_CONSUMER", "CACHE_NONE", "CACHE_SESSION" ],
          "type" : "string"
        },
        "client-id" : {
          "description" : "Sets the JMS client ID to use. Note that this value, if specified, must be unique and can only be used by a single JMS connection instance. It is typically only required for durable topic subscriptions. If using Apache ActiveMQ you may prefer to use Virtual Topics instead.",
          "type" : "string"
        },
        "concurrent-consumers" : {
          "description" : "Specifies the default number of concurrent consumers when consuming from JMS (not for request/reply over JMS). See also the maxMessagesPerTask option to control dynamic scaling up/down of threads. When doing request/reply over JMS then the option replyToConcurrentConsumers is used to control number of concurrent consumers on the reply message listener.",
          "default" : "1",
          "type" : "integer"
        },
        "connection-factory" : {
          "description" : "The connection factory to be use. A connection factory must be configured either on the component or endpoint.",
          "type" : "string"
        },
        "consumer-type" : {
          "description" : "The consumer type to use, which can be one of: Simple, Default, or Custom. The consumer type determines which Spring JMS listener to use. Default will use org.springframework.jms.listener.DefaultMessageListenerContainer, Simple will use org.springframework.jms.listener.SimpleMessageListenerContainer. When Custom is specified, the MessageListenerContainerFactory defined by the messageListenerContainerFactory option will determine what org.springframework.jms.listener.AbstractMessageListenerContainer to use.",
          "default" : "Default",
          "enum" : [ "Simple", "Default", "Custom" ],
          "type" : "string"
        },
        "correlation-property" : {
          "description" : "When using InOut exchange pattern use this JMS property instead of JMSCorrelationID JMS property to correlate messages. If set messages will be correlated solely on the value of this property JMSCorrelationID property will be ignored and not set by Camel.",
          "type" : "string"
        },
        "default-task-executor-type" : {
          "description" : "Specifies what default TaskExecutor type to use in the DefaultMessageListenerContainer, for both consumer endpoints and the ReplyTo consumer of producer endpoints. Possible values: SimpleAsync (uses Spring's SimpleAsyncTaskExecutor) or ThreadPool (uses Spring's ThreadPoolTaskExecutor with optimal values - cached threadpool-like). If not set, it defaults to the previous behaviour, which uses a cached thread pool for consumer endpoints and SimpleAsync for reply consumers. The use of ThreadPool is recommended to reduce thread trash in elastic configurations with dynamically increasing and decreasing concurrent consumers.",
          "enum" : [ "ThreadPool", "SimpleAsync" ],
          "type" : "string"
        },
        "delivery-delay" : {
          "description" : "Sets delivery delay to use for send calls for JMS. This option requires JMS 2.0 compliant broker.",
          "default" : "-1",
          "type" : "integer"
        },
        "delivery-mode" : {
          "description" : "Specifies the delivery mode to be used. Possible values are those defined by javax.jms.DeliveryMode. NON_PERSISTENT = 1 and PERSISTENT = 2.",
          "enum" : [ "1", "2" ],
          "type" : "integer"
        },
        "delivery-persistent" : {
          "description" : "Specifies whether persistent delivery is used by default.",
          "default" : "true",
          "type" : "boolean"
        },
        "destination-resolver" : {
          "description" : "A pluggable org.springframework.jms.support.destination.DestinationResolver that allows you to use your own resolver (for example, to lookup the real destination in a JNDI registry).",
          "type" : "string"
        },
        "disable-reply-to" : {
          "description" : "Specifies whether Camel ignores the JMSReplyTo header in messages. If true, Camel does not send a reply back to the destination specified in the JMSReplyTo header. You can use this option if you want Camel to consume from a route and you do not want Camel to automatically send back a reply message because another component in your code handles the reply message. You can also use this option if you want to use Camel as a proxy between different message brokers and you want to route message from one system to another.",
          "default" : "false",
          "type" : "boolean"
        },
        "disable-time-to-live" : {
          "description" : "Use this option to force disabling time to live. For example when you do request/reply over JMS, then Camel will by default use the requestTimeout value as time to live on the message being sent. The problem is that the sender and receiver systems have to have their clocks synchronized, so they are in sync. This is not always so easy to archive. So you can use disableTimeToLive=true to not set a time to live value on the sent message. Then the message will not expire on the receiver system. See below in section About time to live for more details.",
          "default" : "false",
          "type" : "boolean"
        },
        "durable-subscription-name" : {
          "description" : "The durable subscriber name for specifying durable topic subscriptions. The clientId option must be configured as well.",
          "type" : "string"
        },
        "eager-loading-of-properties" : {
          "description" : "Enables eager loading of JMS properties and payload as soon as a message is loaded which generally is inefficient as the JMS properties may not be required but sometimes can catch early any issues with the underlying JMS provider and the use of JMS properties. See also the option eagerPoisonBody.",
          "default" : "false",
          "type" : "boolean"
        },
        "eager-poison-body" : {
          "description" : "If eagerLoadingOfProperties is enabled and the JMS message payload (JMS body or JMS properties) is poison (cannot be read/mapped), then set this text as the message body instead so the message can be processed (the cause of the poison are already stored as exception on the Exchange). This can be turned off by setting eagerPoisonBody=false. See also the option eagerLoadingOfProperties.",
          "default" : "Poison JMS message due to ${exception.message}",
          "type" : "string"
        },
        "error-handler" : {
          "description" : "Specifies a org.springframework.util.ErrorHandler to be invoked in case of any uncaught exceptions thrown while processing a Message. By default these exceptions will be logged at the WARN level, if no errorHandler has been configured. You can configure logging level and whether stack traces should be logged using errorHandlerLoggingLevel and errorHandlerLogStackTrace options. This makes it much easier to configure, than having to code a custom errorHandler.",
          "type" : "string"
        },
        "error-handler-log-stack-trace" : {
          "description" : "Allows to control whether stacktraces should be logged or not, by the default errorHandler.",
          "default" : "true",
          "type" : "boolean"
        },
        "error-handler-logging-level" : {
          "description" : "Allows to configure the default errorHandler logging level for logging uncaught exceptions.",
          "default" : "WARN",
          "enum" : [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ],
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exception-listener" : {
          "description" : "Specifies the JMS Exception Listener that is to be notified of any underlying JMS exceptions.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "explicit-qos-enabled" : {
          "description" : "Set if the deliveryMode, priority or timeToLive qualities of service should be used when sending messages. This option is based on Spring's JmsTemplate. The deliveryMode, priority and timeToLive options are applied to the current endpoint. This contrasts with the preserveMessageQos option, which operates at message granularity, reading QoS properties exclusively from the Camel In message headers.",
          "default" : "false",
          "type" : "boolean"
        },
        "expose-listener-session" : {
          "description" : "Specifies whether the listener session should be exposed when consuming messages.",
          "default" : "false",
          "type" : "boolean"
        },
        "force-send-original-message" : {
          "description" : "When using mapJmsMessage=false Camel will create a new JMS message to send to a new JMS destination if you touch the headers (get or set) during the route. Set this option to true to force Camel to send the original JMS message that was received.",
          "default" : "false",
          "type" : "boolean"
        },
        "format-date-headers-to-iso8601" : {
          "description" : "Sets whether JMS date properties should be formatted according to the ISO 8601 standard.",
          "default" : "false",
          "type" : "boolean"
        },
        "header-filter-strategy" : {
          "description" : "To use a custom HeaderFilterStrategy to filter header to and from Camel message.",
          "type" : "string"
        },
        "idle-consumer-limit" : {
          "description" : "Specify the limit for the number of consumers that are allowed to be idle at any given time.",
          "default" : "1",
          "type" : "integer"
        },
        "idle-task-execution-limit" : {
          "description" : "Specifies the limit for idle executions of a receive task, not having received any message within its execution. If this limit is reached, the task will shut down and leave receiving to other executing tasks (in the case of dynamic scheduling; see the maxConcurrentConsumers setting). There is additional doc available from Spring.",
          "default" : "1",
          "type" : "integer"
        },
        "include-all-jmsx-properties" : {
          "description" : "Whether to include all JMSXxxx properties when mapping from JMS to Camel Message. Setting this to true will include properties such as JMSXAppID, and JMSXUserID etc. Note: If you are using a custom headerFilterStrategy then this option does not apply.",
          "default" : "false",
          "type" : "boolean"
        },
        "include-sent-jms-message-id" : {
          "description" : "Only applicable when sending to JMS destination using InOnly (eg fire and forget). Enabling this option will enrich the Camel Exchange with the actual JMSMessageID that was used by the JMS client when the message was sent to the JMS destination.",
          "default" : "false",
          "type" : "boolean"
        },
        "jms-key-format-strategy" : {
          "description" : "Pluggable strategy for encoding and decoding JMS keys so they can be compliant with the JMS specification. Camel provides two implementations out of the box: default and passthrough. The default strategy will safely marshal dots and hyphens (. and -). The passthrough strategy leaves the key as is. Can be used for JMS brokers which do not care whether JMS header keys contain illegal characters. You can provide your own implementation of the org.apache.camel.component.jms.JmsKeyFormatStrategy and refer to it using the # notation.",
          "enum" : [ "default", "passthrough" ],
          "type" : "string"
        },
        "jms-message-type" : {
          "description" : "Allows you to force the use of a specific javax.jms.Message implementation for sending JMS messages. Possible values are: Bytes, Map, Object, Stream, Text. By default, Camel would determine which JMS message type to use from the In body type. This option allows you to specify it.",
          "enum" : [ "Bytes", "Map", "Object", "Stream", "Text" ],
          "type" : "string"
        },
        "lazy-create-transaction-manager" : {
          "description" : "If true, Camel will create a JmsTransactionManager, if there is no transactionManager injected when option transacted=true.",
          "default" : "true",
          "type" : "boolean"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "map-jms-message" : {
          "description" : "Specifies whether Camel should auto map the received JMS message to a suited payload type, such as javax.jms.TextMessage to a String etc.",
          "default" : "true",
          "type" : "boolean"
        },
        "max-concurrent-consumers" : {
          "description" : "Specifies the maximum number of concurrent consumers when consuming from JMS (not for request/reply over JMS). See also the maxMessagesPerTask option to control dynamic scaling up/down of threads. When doing request/reply over JMS then the option replyToMaxConcurrentConsumers is used to control number of concurrent consumers on the reply message listener.",
          "type" : "integer"
        },
        "max-messages-per-task" : {
          "description" : "The number of messages per task. -1 is unlimited. If you use a range for concurrent consumers (eg min max), then this option can be used to set a value to eg 100 to control how fast the consumers will shrink when less work is required.",
          "default" : "-1",
          "type" : "integer"
        },
        "message-converter" : {
          "description" : "To use a custom Spring org.springframework.jms.support.converter.MessageConverter so you can be in control how to map to/from a javax.jms.Message.",
          "type" : "string"
        },
        "message-created-strategy" : {
          "description" : "To use the given MessageCreatedStrategy which are invoked when Camel creates new instances of javax.jms.Message objects when Camel is sending a JMS message.",
          "type" : "string"
        },
        "message-id-enabled" : {
          "description" : "When sending, specifies whether message IDs should be added. This is just an hint to the JMS broker. If the JMS provider accepts this hint, these messages must have the message ID set to null; if the provider ignores the hint, the message ID must be set to its normal unique value.",
          "default" : "true",
          "type" : "boolean"
        },
        "message-listener-container-factory" : {
          "description" : "Registry ID of the MessageListenerContainerFactory used to determine what org.springframework.jms.listener.AbstractMessageListenerContainer to use to consume messages. Setting this will automatically set consumerType to Custom.",
          "type" : "string"
        },
        "message-timestamp-enabled" : {
          "description" : "Specifies whether timestamps should be enabled by default on sending messages. This is just an hint to the JMS broker. If the JMS provider accepts this hint, these messages must have the timestamp set to zero; if the provider ignores the hint the timestamp must be set to its normal value.",
          "default" : "true",
          "type" : "boolean"
        },
        "password" : {
          "description" : "Password to use with the ConnectionFactory. You can also configure username/password directly on the ConnectionFactory.",
          "type" : "string"
        },
        "preserve-message-qos" : {
          "description" : "Set to true, if you want to send message using the QoS settings specified on the message, instead of the QoS settings on the JMS endpoint. The following three headers are considered JMSPriority, JMSDeliveryMode, and JMSExpiration. You can provide all or only some of them. If not provided, Camel will fall back to use the values from the endpoint instead. So, when using this option, the headers override the values from the endpoint. The explicitQosEnabled option, by contrast, will only use options set on the endpoint, and not values from the message header.",
          "default" : "false",
          "type" : "boolean"
        },
        "priority" : {
          "description" : "Values greater than 1 specify the message priority when sending (where 0 is the lowest priority and 9 is the highest). The explicitQosEnabled option must also be enabled in order for this option to have any effect.",
          "default" : "4",
          "enum" : [ "1", "2", "3", "4", "5", "6", "7", "8", "9" ],
          "type" : "integer"
        },
        "pub-sub-no-local" : {
          "description" : "Specifies whether to inhibit the delivery of messages published by its own connection.",
          "default" : "false",
          "type" : "boolean"
        },
        "receive-timeout" : {
          "description" : "The timeout for receiving messages (in milliseconds).",
          "default" : "1000",
          "type" : "string"
        },
        "recovery-interval" : {
          "description" : "Specifies the interval between recovery attempts, i.e. when a connection is being refreshed, in milliseconds. The default is 5000 ms, that is, 5 seconds.",
          "default" : "5000",
          "type" : "string"
        },
        "reply-to" : {
          "description" : "Provides an explicit ReplyTo destination (overrides any incoming value of Message.getJMSReplyTo() in consumer).",
          "type" : "string"
        },
        "reply-to-cache-level-name" : {
          "description" : "Sets the cache level by name for the reply consumer when doing request/reply over JMS. This option only applies when using fixed reply queues (not temporary). Camel will by default use: CACHE_CONSUMER for exclusive or shared w/ replyToSelectorName. And CACHE_SESSION for shared without replyToSelectorName. Some JMS brokers such as IBM WebSphere may require to set the replyToCacheLevelName=CACHE_NONE to work. Note: If using temporary queues then CACHE_NONE is not allowed, and you must use a higher value such as CACHE_CONSUMER or CACHE_SESSION.",
          "enum" : [ "CACHE_AUTO", "CACHE_CONNECTION", "CACHE_CONSUMER", "CACHE_NONE", "CACHE_SESSION" ],
          "type" : "string"
        },
        "reply-to-concurrent-consumers" : {
          "description" : "Specifies the default number of concurrent consumers when doing request/reply over JMS. See also the maxMessagesPerTask option to control dynamic scaling up/down of threads.",
          "default" : "1",
          "type" : "integer"
        },
        "reply-to-delivery-persistent" : {
          "description" : "Specifies whether to use persistent delivery by default for replies.",
          "default" : "true",
          "type" : "boolean"
        },
        "reply-to-destination-selector-name" : {
          "description" : "Sets the JMS Selector using the fixed name to be used so you can filter out your own replies from the others when using a shared queue (that is, if you are not using a temporary reply queue).",
          "type" : "string"
        },
        "reply-to-max-concurrent-consumers" : {
          "description" : "Specifies the maximum number of concurrent consumers when using request/reply over JMS. See also the maxMessagesPerTask option to control dynamic scaling up/down of threads.",
          "type" : "integer"
        },
        "reply-to-on-timeout-max-concurrent-consumers" : {
          "description" : "Specifies the maximum number of concurrent consumers for continue routing when timeout occurred when using request/reply over JMS.",
          "default" : "1",
          "type" : "integer"
        },
        "reply-to-override" : {
          "description" : "Provides an explicit ReplyTo destination in the JMS message, which overrides the setting of replyTo. It is useful if you want to forward the message to a remote Queue and receive the reply message from the ReplyTo destination.",
          "type" : "string"
        },
        "reply-to-same-destination-allowed" : {
          "description" : "Whether a JMS consumer is allowed to send a reply message to the same destination that the consumer is using to consume from. This prevents an endless loop by consuming and sending back the same message to itself.",
          "default" : "false",
          "type" : "boolean"
        },
        "reply-to-type" : {
          "description" : "Allows for explicitly specifying which kind of strategy to use for replyTo queues when doing request/reply over JMS. Possible values are: Temporary, Shared, or Exclusive. By default Camel will use temporary queues. However if replyTo has been configured, then Shared is used by default. This option allows you to use exclusive queues instead of shared ones. See Camel JMS documentation for more details, and especially the notes about the implications if running in a clustered environment, and the fact that Shared reply queues has lower performance than its alternatives Temporary and Exclusive.",
          "enum" : [ "Temporary", "Shared", "Exclusive" ],
          "type" : "string"
        },
        "request-timeout" : {
          "description" : "The timeout for waiting for a reply when using the InOut Exchange Pattern (in milliseconds). The default is 20 seconds. You can include the header CamelJmsRequestTimeout to override this endpoint configured timeout value, and thus have per message individual timeout values. See also the requestTimeoutCheckerInterval option.",
          "default" : "20000",
          "type" : "string"
        },
        "request-timeout-checker-interval" : {
          "description" : "Configures how often Camel should check for timed out Exchanges when doing request/reply over JMS. By default Camel checks once per second. But if you must react faster when a timeout occurs, then you can lower this interval, to check more frequently. The timeout is determined by the option requestTimeout.",
          "default" : "1000",
          "type" : "string"
        },
        "selector" : {
          "description" : "Sets the JMS selector to use",
          "type" : "string"
        },
        "stream-message-type-enabled" : {
          "description" : "Sets whether StreamMessage type is enabled or not. Message payloads of streaming kind such as files, InputStream, etc will either by sent as BytesMessage or StreamMessage. This option controls which kind will be used. By default BytesMessage is used which enforces the entire message payload to be read into memory. By enabling this option the message payload is read into memory in chunks and each chunk is then written to the StreamMessage until no more data.",
          "default" : "false",
          "type" : "boolean"
        },
        "subscription-durable" : {
          "description" : "Set whether to make the subscription durable. The durable subscription name to be used can be specified through the subscriptionName property. Default is false. Set this to true to register a durable subscription, typically in combination with a subscriptionName value (unless your message listener class name is good enough as subscription name). Only makes sense when listening to a topic (pub-sub domain), therefore this method switches the pubSubDomain flag as well.",
          "default" : "false",
          "type" : "boolean"
        },
        "subscription-name" : {
          "description" : "Set the name of a subscription to create. To be applied in case of a topic (pub-sub domain) with a shared or durable subscription. The subscription name needs to be unique within this client's JMS client id. Default is the class name of the specified message listener. Note: Only 1 concurrent consumer (which is the default of this message listener container) is allowed for each subscription, except for a shared subscription (which requires JMS 2.0).",
          "type" : "string"
        },
        "subscription-shared" : {
          "description" : "Set whether to make the subscription shared. The shared subscription name to be used can be specified through the subscriptionName property. Default is false. Set this to true to register a shared subscription, typically in combination with a subscriptionName value (unless your message listener class name is good enough as subscription name). Note that shared subscriptions may also be durable, so this flag can (and often will) be combined with subscriptionDurable as well. Only makes sense when listening to a topic (pub-sub domain), therefore this method switches the pubSubDomain flag as well. Requires a JMS 2.0 compatible message broker.",
          "default" : "false",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "task-executor" : {
          "description" : "Allows you to specify a custom task executor for consuming messages.",
          "type" : "string"
        },
        "test-connection-on-startup" : {
          "description" : "Specifies whether to test the connection on startup. This ensures that when Camel starts that all the JMS consumers have a valid connection to the JMS broker. If a connection cannot be granted then Camel throws an exception on startup. This ensures that Camel is not started with failed connections. The JMS producers is tested as well.",
          "default" : "false",
          "type" : "boolean"
        },
        "time-to-live" : {
          "description" : "When sending messages, specifies the time-to-live of the message (in milliseconds).",
          "default" : "-1",
          "type" : "integer"
        },
        "transacted" : {
          "description" : "Specifies whether to use transacted mode",
          "default" : "false",
          "type" : "boolean"
        },
        "transacted-in-out" : {
          "description" : "Specifies whether InOut operations (request reply) default to using transacted mode If this flag is set to true, then Spring JmsTemplate will have sessionTransacted set to true, and the acknowledgeMode as transacted on the JmsTemplate used for InOut operations. Note from Spring JMS: that within a JTA transaction, the parameters passed to createQueue, createTopic methods are not taken into account. Depending on the Java EE transaction context, the container makes its own decisions on these values. Analogously, these parameters are not taken into account within a locally managed transaction either, since Spring JMS operates on an existing JMS Session in this case. Setting this flag to true will use a short local JMS transaction when running outside of a managed transaction, and a synchronized local JMS transaction in case of a managed transaction (other than an XA transaction) being present. This has the effect of a local JMS transaction being managed alongside the main transaction (which might be a native JDBC transaction), with the JMS transaction committing right after the main transaction.",
          "default" : "false",
          "type" : "boolean"
        },
        "transaction-manager" : {
          "description" : "The Spring transaction manager to use.",
          "type" : "string"
        },
        "transaction-name" : {
          "description" : "The name of the transaction to use.",
          "type" : "string"
        },
        "transaction-timeout" : {
          "description" : "The timeout value of the transaction (in seconds), if using transacted mode.",
          "default" : "-1",
          "type" : "integer"
        },
        "transfer-exception" : {
          "description" : "If enabled and you are using Request Reply messaging (InOut) and an Exchange failed on the consumer side, then the caused Exception will be send back in response as a javax.jms.ObjectMessage. If the client is Camel, the returned Exception is rethrown. This allows you to use Camel JMS as a bridge in your routing - for example, using persistent queues to enable robust routing. Notice that if you also have transferExchange enabled, this option takes precedence. The caught exception is required to be serializable. The original Exception on the consumer side can be wrapped in an outer exception such as org.apache.camel.RuntimeCamelException when returned to the producer. Use this with caution as the data is using Java Object serialization and requires the received to be able to deserialize the data at Class level, which forces a strong coupling between the producers and consumer!",
          "default" : "false",
          "type" : "boolean"
        },
        "transfer-exchange" : {
          "description" : "You can transfer the exchange over the wire instead of just the body and headers. The following fields are transferred: In body, Out body, Fault body, In headers, Out headers, Fault headers, exchange properties, exchange exception. This requires that the objects are serializable. Camel will exclude any non-serializable objects and log it at WARN level. You must enable this option on both the producer and consumer side, so Camel knows the payloads is an Exchange and not a regular payload. Use this with caution as the data is using Java Object serialization and requires the received to be able to deserialize the data at Class level, which forces a strong coupling between the producers and consumer having to use compatible Camel versions!",
          "default" : "false",
          "type" : "boolean"
        },
        "use-message-id-as-correlation-id" : {
          "description" : "Specifies whether JMSMessageID should always be used as JMSCorrelationID for InOut messages.",
          "default" : "false",
          "type" : "boolean"
        },
        "username" : {
          "description" : "Username to use with the ConnectionFactory. You can also configure username/password directly on the ConnectionFactory.",
          "type" : "string"
        },
        "wait-for-provision-correlation-to-be-updated-counter" : {
          "description" : "Number of times to wait for provisional correlation id to be updated to the actual correlation id when doing request/reply over JMS and when the option useMessageIDAsCorrelationID is enabled.",
          "default" : "50",
          "type" : "integer"
        },
        "wait-for-provision-correlation-to-be-updated-thread-sleeping-time" : {
          "description" : "Interval in millis to sleep each time while waiting for provisional correlation id to be updated.",
          "default" : "100",
          "type" : "string"
        }
      }
    },
    "apns" : {
      "type" : "object",
      "properties" : {
        "name" : {
          "description" : "Name of the endpoint",
          "type" : "string"
        },
        "backoff-error-threshold" : {
          "description" : "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-idle-threshold" : {
          "description" : "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-multiplier" : {
          "description" : "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
          "type" : "integer"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "delay" : {
          "description" : "Milliseconds before the next poll.",
          "default" : "500",
          "type" : "integer"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "greedy" : {
          "description" : "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
          "default" : "false",
          "type" : "boolean"
        },
        "initial-delay" : {
          "description" : "Milliseconds before the first poll starts.",
          "default" : "1000",
          "type" : "integer"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "poll-strategy" : {
          "description" : "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
          "type" : "string"
        },
        "repeat-count" : {
          "description" : "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
          "default" : "0",
          "type" : "integer"
        },
        "run-logging-level" : {
          "description" : "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
          "default" : "TRACE",
          "enum" : [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ],
          "type" : "string"
        },
        "scheduled-executor-service" : {
          "description" : "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
          "type" : "string"
        },
        "scheduler" : {
          "description" : "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
          "default" : "none",
          "type" : "string"
        },
        "scheduler-properties" : {
          "description" : "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
          "type" : "string"
        },
        "send-empty-message-when-idle" : {
          "description" : "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
          "default" : "false",
          "type" : "boolean"
        },
        "start-scheduler" : {
          "description" : "Whether the scheduler should be auto started.",
          "default" : "true",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "time-unit" : {
          "description" : "Time unit for initialDelay and delay options.",
          "default" : "MILLISECONDS",
          "enum" : [ "NANOSECONDS", "MICROSECONDS", "MILLISECONDS", "SECONDS", "MINUTES", "HOURS", "DAYS" ],
          "type" : "string"
        },
        "tokens" : {
          "description" : "Configure this property in case you want to statically declare tokens related to devices you want to notify. Tokens are separated by comma.",
          "type" : "string"
        },
        "use-fixed-delay" : {
          "description" : "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
          "default" : "true",
          "type" : "boolean"
        }
      }
    },
    "arangodb" : {
      "type" : "object",
      "required" : [ "database" ],
      "properties" : {
        "database" : {
          "description" : "database name",
          "type" : "string"
        },
        "document-collection" : {
          "description" : "Collection name, when using ArangoDb as a Document Database. Set the documentCollection name when using the CRUD operation on the document database collections (SAVE_DOCUMENT , FIND_DOCUMENT_BY_KEY, UPDATE_DOCUMENT, DELETE_DOCUMENT).",
          "type" : "string"
        },
        "edge-collection" : {
          "description" : "Collection name of vertices, when using ArangoDb as a Graph Database. Set the edgeCollection name to perform CRUD operation on edges using these operations : SAVE_VERTEX, FIND_VERTEX_BY_KEY, UPDATE_VERTEX, DELETE_VERTEX. The graph attribute is mandatory.",
          "type" : "string"
        },
        "graph" : {
          "description" : "Graph name, when using ArangoDb as a Graph Database. Combine this attribute with one of the two attributes vertexCollection and edgeCollection.",
          "type" : "string"
        },
        "host" : {
          "description" : "ArangoDB host. If host and port are default, this field is Optional.",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "operation" : {
          "description" : "Operations to perform on ArangoDb. For the operation AQL_QUERY, no need to specify a collection or graph.",
          "enum" : [ "SAVE_DOCUMENT", "FIND_DOCUMENT_BY_KEY", "UPDATE_DOCUMENT", "DELETE_DOCUMENT", "AQL_QUERY", "SAVE_VERTEX", "FIND_VERTEX_BY_KEY", "UPDATE_VERTEX", "DELETE_VERTEX", "SAVE_EDGE", "FIND_EDGE_BY_KEY", "UPDATE_EDGE", "DELETE_EDGE" ],
          "type" : "string"
        },
        "password" : {
          "description" : "ArangoDB password. If user and password are default, this field is Optional.",
          "type" : "string"
        },
        "port" : {
          "description" : "ArangoDB exposed port. If host and port are default, this field is Optional.",
          "type" : "integer"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "user" : {
          "description" : "ArangoDB user. If user and password are default, this field is Optional.",
          "type" : "string"
        },
        "vertex-collection" : {
          "description" : "Collection name of vertices, when using ArangoDb as a Graph Database. Set the vertexCollection name to perform CRUD operation on vertices using these operations : SAVE_EDGE, FIND_EDGE_BY_KEY, UPDATE_EDGE, DELETE_EDGE. The graph attribute is mandatory.",
          "type" : "string"
        }
      }
    },
    "as2" : {
      "type" : "object",
      "required" : [ "apiName", "methodName" ],
      "properties" : {
        "api-name" : {
          "description" : "What kind of operation to perform",
          "enum" : [ "CLIENT", "SERVER" ],
          "type" : "string"
        },
        "method-name" : {
          "description" : "What sub operation to use for the selected operation",
          "type" : "string"
        },
        "as2-from" : {
          "description" : "The value of the AS2From header of AS2 message.",
          "type" : "string"
        },
        "as2-message-structure" : {
          "description" : "The structure of AS2 Message. One of: PLAIN - No encryption, no signature, SIGNED - No encryption, signature, ENCRYPTED - Encryption, no signature, ENCRYPTED_SIGNED - Encryption, signature",
          "enum" : [ "PLAIN", "SIGNED", "ENCRYPTED", "SIGNED_ENCRYPTED", "PLAIN_COMPRESSED", "SIGNED_COMPRESSED", "ENCRYPTED_COMPRESSED", "ENCRYPTED_COMPRESSED_SIGNED" ],
          "type" : "string"
        },
        "as2-to" : {
          "description" : "The value of the AS2To header of AS2 message.",
          "type" : "string"
        },
        "as2-version" : {
          "description" : "The version of the AS2 protocol.",
          "default" : "1.1",
          "enum" : [ "1.0", "1.1" ],
          "type" : "string"
        },
        "client-fqdn" : {
          "description" : "The Client Fully Qualified Domain Name (FQDN). Used in message ids sent by endpoint.",
          "default" : "camel.apache.org",
          "type" : "string"
        },
        "compression-algorithm" : {
          "description" : "The algorithm used to compress EDI message.",
          "enum" : [ "ZLIB" ],
          "type" : "string"
        },
        "decrypting-private-key" : {
          "description" : "The key used to encrypt the EDI message.",
          "type" : "string"
        },
        "disposition-notification-to" : {
          "description" : "The value of the Disposition-Notification-To header. Assigning a value to this parameter requests a message disposition notification (MDN) for the AS2 message.",
          "type" : "string"
        },
        "edi-message-transfer-encoding" : {
          "description" : "The transfer encoding of EDI message.",
          "type" : "string"
        },
        "edi-message-type" : {
          "description" : "The content type of EDI message. One of application/edifact, application/edi-x12, application/edi-consent",
          "type" : "string"
        },
        "encrypting-algorithm" : {
          "description" : "The algorithm used to encrypt EDI message.",
          "enum" : [ "AES128_CBC", "AES192_CBC", "AES256_CBC", "AES128_CCM", "AES192_CCM", "AES256_CCM", "AES128_GCM", "AES192_GCM", "AES256_GCM", "CAMELLIA128_CBC", "CAMELLIA192_CBC", "CAMELLIA256_CBC", "CAST5_CBC", "DES_CBC", "DES_EDE3_CBC", "GOST28147_GCFB", "IDEA_CBC", "RC2_CBC", "RC4", "SEED_CBC" ],
          "type" : "string"
        },
        "encrypting-certificate-chain" : {
          "description" : "The chain of certificates used to encrypt EDI message.",
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "from" : {
          "description" : "The value of the From header of AS2 message.",
          "type" : "string"
        },
        "in-body" : {
          "description" : "Sets the name of a parameter to be passed in the exchange In Body",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "mdn-message-template" : {
          "description" : "The template used to format MDN message",
          "type" : "string"
        },
        "request-uri" : {
          "description" : "The request URI of EDI message.",
          "default" : "/",
          "type" : "string"
        },
        "server" : {
          "description" : "The value included in the Server message header identifying the AS2 Server.",
          "default" : "Camel AS2 Server Endpoint",
          "type" : "string"
        },
        "server-fqdn" : {
          "description" : "The Server Fully Qualified Domain Name (FQDN). Used in message ids sent by endpoint.",
          "default" : "camel.apache.org",
          "type" : "string"
        },
        "server-port-number" : {
          "description" : "The port number of server.",
          "type" : "integer"
        },
        "signed-receipt-mic-algorithms" : {
          "description" : "The list of algorithms, in order of preference, requested to generate a message integrity check (MIC) returned in message dispostion notification (MDN)",
          "type" : "string"
        },
        "signing-algorithm" : {
          "description" : "The algorithm used to sign EDI message.",
          "enum" : [ "SHA3_224WITHRSA", "SHA3_256WITHRSA", "SHA3_384withRSA", "SHA3_512WITHRSA", "MD5WITHRSA", "SHA1WITHRSA", "MD2WITHRSA", "SHA224WITHRSA", "SHA256WITHRSA", "SHA384WITHRSA", "SHA512WITHRSA", "RIPEMD128WITHRSA", "RIPEMD160WITHRSA", "RIPEMD256WITHRSA", "SHA224WITHDSA", "SHA256WITHDSA", "SHA384WITHDSA", "SHA512WITHDSA", "SHA3_224WITHDSA", "SHA3_256WITHDSA", "SHA3_384WITHDSA", "SHA3_512WITHDSA", "SHA1WITHDSA", "SHA3_224WITHECDSA", "SHA3_256WITHECDSA", "SHA3_384WITHECDSA", "SHA3_512WITHECDSA", "SHA1WITHECDSA", "SHA224WITHECDSA", "SHA256WITHECDSA", "SHA384WITHECDSA", "SHA512WITHECDSA", "SHA1WITHPLAIN_ECDSA", "SHA224WITHPLAIN_ECDSA", "SHA256WITHPLAIN_ECDSA", "SHA384WITHPLAIN_ECDSA", "SHA512WITHPLAIN_ECDSA", "RIPEMD160WITHPLAIN_ECDSA", "SHA1WITHRSAANDMGF1", "SHA224WITHRSAANDMGF1", "SHA256WITHRSAANDMGF1", "SHA384WITHRSAANDMGF1", "SHA512WITHRSAANDMGF1", "SHA3_224WITHRSAANDMGF1", "SHA3_256WITHRSAANDMGF1", "SHA3_384WITHRSAANDMGF1", "SHA3_512WITHRSAANDMGF1" ],
          "type" : "string"
        },
        "signing-certificate-chain" : {
          "description" : "The chain of certificates used to sign EDI message.",
          "type" : "string"
        },
        "signing-private-key" : {
          "description" : "The key used to sign the EDI message.",
          "type" : "string"
        },
        "subject" : {
          "description" : "The value of Subject header of AS2 message.",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "target-hostname" : {
          "description" : "The host name (IP or DNS name) of target host.",
          "type" : "string"
        },
        "target-port-number" : {
          "description" : "The port number of target host. -1 indicates the scheme default port.",
          "type" : "integer"
        },
        "user-agent" : {
          "description" : "The value included in the User-Agent message header identifying the AS2 user agent.",
          "default" : "Camel AS2 Client Endpoint",
          "type" : "string"
        }
      }
    },
    "asterisk" : {
      "type" : "object",
      "required" : [ "name", "hostname", "password", "username" ],
      "properties" : {
        "name" : {
          "description" : "Name of component",
          "type" : "string"
        },
        "action" : {
          "description" : "What action to perform such as getting queue status, sip peers or extension state.",
          "enum" : [ "QUEUE_STATUS", "SIP_PEERS", "EXTENSION_STATE" ],
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "hostname" : {
          "description" : "The hostname of the asterisk server",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "password" : {
          "description" : "Login password",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "username" : {
          "description" : "Login username",
          "type" : "string"
        }
      }
    },
    "atlasmap" : {
      "type" : "object",
      "required" : [ "resourceUri" ],
      "properties" : {
        "resource-uri" : {
          "description" : "Path to the resource. You can prefix with: classpath, file, http, ref, or bean. classpath, file and http loads the resource using these protocols (classpath is default). ref will lookup the resource in the registry. bean will call a method on a bean to be used as the resource. For bean you can specify the method name after dot, eg bean:myBean.myMethod.",
          "type" : "string"
        },
        "allow-context-map-all" : {
          "description" : "Sets whether the context map should allow access to all details. By default only the message body and headers can be accessed. This option can be enabled for full access to the current Exchange and CamelContext. Doing so impose a potential security risk as this opens access to the full power of CamelContext API.",
          "default" : "false",
          "type" : "boolean"
        },
        "content-cache" : {
          "description" : "Sets whether to use resource content cache or not",
          "default" : "false",
          "type" : "boolean"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "properties-file" : {
          "description" : "The URI of the properties file which is used for AtlasContextFactory initialization.",
          "type" : "string"
        },
        "source-map-name" : {
          "description" : "The Exchange property name for a source message map which hold java.util.Map&lt;String, Message&gt; where the key is AtlasMap Document ID. AtlasMap consumes Message bodies as source documents, as well as message headers as source properties where the scope equals to Document ID.",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "target-map-mode" : {
          "description" : "TargetMapMode enum value to specify how multiple target documents are delivered if exist. 'MAP': Stores them into a java.util.Map, and the java.util.Map is set to an exchange property if 'targetMapName' is specified, otherwise message body. 'MESSAGE_HEADER': Stores them into message headers. 'EXCHANGE_PROPERTY': Stores them into exchange properties. )",
          "default" : "MAP",
          "enum" : [ "MAP", "MESSAGE_HEADER", "EXCHANGE_PROPERTY" ],
          "type" : "string"
        },
        "target-map-name" : {
          "description" : "The Exchange property name for a target document map which hold java.util.Map&lt;String, Object&gt; where the key is AtlasMap Document ID. AtlasMap populates multiple target documents into this map.",
          "type" : "string"
        }
      }
    },
    "atmos" : {
      "type" : "object",
      "properties" : {
        "name" : {
          "description" : "Atmos name",
          "type" : "string"
        },
        "operation" : {
          "description" : "Operation to perform",
          "enum" : [ "put", "del", "search", "get", "move" ],
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "full-token-id" : {
          "description" : "Atmos client fullTokenId",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "local-path" : {
          "description" : "Local path to put files",
          "type" : "string"
        },
        "new-remote-path" : {
          "description" : "New path on Atmos when moving files",
          "type" : "string"
        },
        "query" : {
          "description" : "Search query on Atmos",
          "type" : "string"
        },
        "remote-path" : {
          "description" : "Where to put files on Atmos",
          "type" : "string"
        },
        "secret-key" : {
          "description" : "The secret key to pass to the Atmos client (should be base64 encoded)",
          "type" : "string"
        },
        "ssl-validation" : {
          "description" : "Atmos SSL validation",
          "default" : "false",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "uri" : {
          "description" : "Atomos server uri",
          "type" : "string"
        }
      },
      "required" : [ "operation" ]
    },
    "atmosphere-websocket" : {
      "type" : "object",
      "required" : [ "servicePath" ],
      "properties" : {
        "service-path" : {
          "description" : "Name of websocket endpoint",
          "type" : "string"
        },
        "async" : {
          "description" : "Configure the consumer to work in async mode",
          "default" : "false",
          "type" : "boolean"
        },
        "attachment-multipart-binding" : {
          "description" : "Whether to automatic bind multipart/form-data as attachments on the Camel Exchange. The options attachmentMultipartBinding=true and disableStreamCache=false cannot work together. Remove disableStreamCache to use AttachmentMultipartBinding. This is turn off by default as this may require servlet specific configuration to enable this when using Servlet's.",
          "default" : "false",
          "type" : "boolean"
        },
        "bridge-endpoint" : {
          "description" : "If the option is true, HttpProducer will ignore the Exchange.HTTP_URI header, and use the endpoint's URI for request. You may also set the option throwExceptionOnFailure to be false to let the HttpProducer send all the fault response back.",
          "default" : "false",
          "type" : "boolean"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "chunked" : {
          "description" : "If this option is false the Servlet will disable the HTTP streaming and set the content-length header on the response",
          "default" : "true",
          "type" : "boolean"
        },
        "disable-stream-cache" : {
          "description" : "Determines whether or not the raw input stream from Servlet is cached or not (Camel will read the stream into a in memory/overflow to file, Stream caching) cache. By default Camel will cache the Servlet input stream to support reading it multiple times to ensure it Camel can retrieve all data from the stream. However you can set this option to true when you for example need to access the raw stream, such as streaming it directly to a file or other persistent store. DefaultHttpBinding will copy the request input stream into a stream cache and put it into message body if this option is false to support reading the stream multiple times. If you use Servlet to bridge/proxy an endpoint then consider enabling this option to improve performance, in case you do not need to read the message payload multiple times. The http producer will by default cache the response body stream. If setting this option to true, then the producers will not cache the response body stream but use the response stream as-is as the message body.",
          "default" : "false",
          "type" : "boolean"
        },
        "eager-check-content-available" : {
          "description" : "Whether to eager check whether the HTTP requests has content if the content-length header is 0 or not present. This can be turned on in case HTTP clients do not send streamed data.",
          "default" : "false",
          "type" : "boolean"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "file-name-ext-whitelist" : {
          "description" : "Whitelist of accepted filename extensions for accepting uploaded files. Multiple extensions can be separated by comma, such as txt,xml.",
          "type" : "string"
        },
        "header-filter-strategy" : {
          "description" : "To use a custom HeaderFilterStrategy to filter header to and from Camel message.",
          "type" : "string"
        },
        "http-binding" : {
          "description" : "To use a custom HttpBinding to control the mapping between Camel message and HttpClient.",
          "type" : "string"
        },
        "http-method-restrict" : {
          "description" : "Used to only allow consuming if the HttpMethod matches, such as GET/POST/PUT etc. Multiple methods can be specified separated by comma.",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "map-http-message-body" : {
          "description" : "If this option is true then IN exchange Body of the exchange will be mapped to HTTP body. Setting this to false will avoid the HTTP mapping.",
          "default" : "true",
          "type" : "boolean"
        },
        "map-http-message-form-url-encoded-body" : {
          "description" : "If this option is true then IN exchange Form Encoded body of the exchange will be mapped to HTTP. Setting this to false will avoid the HTTP Form Encoded body mapping.",
          "default" : "true",
          "type" : "boolean"
        },
        "map-http-message-headers" : {
          "description" : "If this option is true then IN exchange Headers of the exchange will be mapped to HTTP headers. Setting this to false will avoid the HTTP Headers mapping.",
          "default" : "true",
          "type" : "boolean"
        },
        "match-on-uri-prefix" : {
          "description" : "Whether or not the consumer should try to find a target consumer by matching the URI prefix if no exact match is found.",
          "default" : "false",
          "type" : "boolean"
        },
        "mute-exception" : {
          "description" : "If enabled and an Exchange failed processing on the consumer side the response's body won't contain the exception's stack trace.",
          "default" : "false",
          "type" : "boolean"
        },
        "options-enabled" : {
          "description" : "Specifies whether to enable HTTP OPTIONS for this Servlet consumer. By default OPTIONS is turned off.",
          "default" : "false",
          "type" : "boolean"
        },
        "response-buffer-size" : {
          "description" : "To use a custom buffer size on the javax.servlet.ServletResponse.",
          "type" : "integer"
        },
        "send-to-all" : {
          "description" : "Whether to send to all (broadcast) or send to a single receiver.",
          "default" : "false",
          "type" : "boolean"
        },
        "servlet-name" : {
          "description" : "Name of the servlet to use",
          "default" : "CamelServlet",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "trace-enabled" : {
          "description" : "Specifies whether to enable HTTP TRACE for this Servlet consumer. By default TRACE is turned off.",
          "default" : "false",
          "type" : "boolean"
        },
        "transfer-exception" : {
          "description" : "If enabled and an Exchange failed processing on the consumer side, and if the caused Exception was send back serialized in the response as a application/x-java-serialized-object content type. On the producer side the exception will be deserialized and thrown as is, instead of the HttpOperationFailedException. The caused exception is required to be serialized. This is by default turned off. If you enable this then be aware that Java will deserialize the incoming data from the request to Java and that can be a potential security risk.",
          "default" : "false",
          "type" : "boolean"
        },
        "use-streaming" : {
          "description" : "To enable streaming to send data as multiple text fragments.",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "atom" : {
      "type" : "object",
      "required" : [ "feedUri" ],
      "properties" : {
        "feed-uri" : {
          "description" : "The URI to the feed to poll.",
          "type" : "string"
        },
        "backoff-error-threshold" : {
          "description" : "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-idle-threshold" : {
          "description" : "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-multiplier" : {
          "description" : "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
          "type" : "integer"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "delay" : {
          "description" : "Milliseconds before the next poll.",
          "default" : "500",
          "type" : "integer"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "feed-header" : {
          "description" : "Sets whether to add the feed object as a header.",
          "default" : "true",
          "type" : "boolean"
        },
        "filter" : {
          "description" : "Sets whether to use filtering or not of the entries.",
          "default" : "true",
          "type" : "boolean"
        },
        "greedy" : {
          "description" : "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
          "default" : "false",
          "type" : "boolean"
        },
        "initial-delay" : {
          "description" : "Milliseconds before the first poll starts.",
          "default" : "1000",
          "type" : "integer"
        },
        "last-update" : {
          "description" : "Sets the timestamp to be used for filtering entries from the atom feeds. This options is only in conjunction with the splitEntries.",
          "type" : "string"
        },
        "password" : {
          "description" : "Sets the password to be used for basic authentication when polling from a HTTP feed.",
          "type" : "string"
        },
        "poll-strategy" : {
          "description" : "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
          "type" : "string"
        },
        "repeat-count" : {
          "description" : "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
          "default" : "0",
          "type" : "integer"
        },
        "run-logging-level" : {
          "description" : "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
          "default" : "TRACE",
          "enum" : [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ],
          "type" : "string"
        },
        "scheduled-executor-service" : {
          "description" : "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
          "type" : "string"
        },
        "scheduler" : {
          "description" : "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
          "default" : "none",
          "type" : "string"
        },
        "scheduler-properties" : {
          "description" : "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
          "type" : "string"
        },
        "send-empty-message-when-idle" : {
          "description" : "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
          "default" : "false",
          "type" : "boolean"
        },
        "sort-entries" : {
          "description" : "Sets whether to sort entries by published date. Only works when splitEntries = true.",
          "default" : "false",
          "type" : "boolean"
        },
        "split-entries" : {
          "description" : "Sets whether or not entries should be sent individually or whether the entire feed should be sent as a single message",
          "default" : "true",
          "type" : "boolean"
        },
        "start-scheduler" : {
          "description" : "Whether the scheduler should be auto started.",
          "default" : "true",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "throttle-entries" : {
          "description" : "Sets whether all entries identified in a single feed poll should be delivered immediately. If true, only one entry is processed per delay. Only applicable when splitEntries = true.",
          "default" : "true",
          "type" : "boolean"
        },
        "time-unit" : {
          "description" : "Time unit for initialDelay and delay options.",
          "default" : "MILLISECONDS",
          "enum" : [ "NANOSECONDS", "MICROSECONDS", "MILLISECONDS", "SECONDS", "MINUTES", "HOURS", "DAYS" ],
          "type" : "string"
        },
        "use-fixed-delay" : {
          "description" : "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
          "default" : "true",
          "type" : "boolean"
        },
        "username" : {
          "description" : "Sets the username to be used for basic authentication when polling from a HTTP feed.",
          "type" : "string"
        }
      }
    },
    "atomix-map" : {
      "type" : "object",
      "required" : [ "resourceName" ],
      "properties" : {
        "resource-name" : {
          "description" : "The distributed resource name",
          "type" : "string"
        },
        "atomix" : {
          "description" : "The Atomix instance to use",
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "configuration-uri" : {
          "description" : "The Atomix configuration uri.",
          "type" : "string"
        },
        "default-action" : {
          "description" : "The default action.",
          "default" : "PUT",
          "enum" : [ "PUT", "PUT_IF_ABSENT", "GET", "CLEAR", "SIZE", "CONTAINS_KEY", "CONTAINS_VALUE", "IS_EMPTY", "ENTRY_SET", "REMOVE", "REPLACE", "VALUES" ],
          "type" : "string"
        },
        "default-resource-config" : {
          "description" : "The cluster wide default resource configuration.",
          "type" : "string"
        },
        "default-resource-options" : {
          "description" : "The local default resource options.",
          "type" : "string"
        },
        "ephemeral" : {
          "description" : "Sets if the local member should join groups as PersistentMember or not. If set to ephemeral the local member will receive an auto generated ID thus the local one is ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "key" : {
          "description" : "The key to use if none is set in the header or to listen for events for a specific key.",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "nodes" : {
          "description" : "The address of the nodes composing the cluster.",
          "type" : "string"
        },
        "read-consistency" : {
          "description" : "The read consistency level.",
          "enum" : [ "ATOMIC", "ATOMIC_LEASE", "SEQUENTIAL", "LOCAL" ],
          "type" : "string"
        },
        "resource-configs" : {
          "description" : "Cluster wide resources configuration.",
          "type" : "string"
        },
        "resource-options" : {
          "description" : "Local resources configurations",
          "type" : "string"
        },
        "result-header" : {
          "description" : "The header that wil carry the result.",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "transport-class-name" : {
          "description" : "The class name (fqn) of the Atomix transport",
          "default" : "io.atomix.catalyst.transport.netty.NettyTransport",
          "type" : "string"
        },
        "ttl" : {
          "description" : "The resource ttl.",
          "type" : "string"
        }
      }
    },
    "atomix-messaging" : {
      "type" : "object",
      "required" : [ "resourceName" ],
      "properties" : {
        "resource-name" : {
          "description" : "The distributed resource name",
          "type" : "string"
        },
        "atomix" : {
          "description" : "The Atomix instance to use",
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "broadcast-type" : {
          "description" : "The broadcast type.",
          "default" : "ALL",
          "enum" : [ "ALL", "RANDOM" ],
          "type" : "string"
        },
        "channel-name" : {
          "description" : "The messaging channel name",
          "type" : "string"
        },
        "configuration-uri" : {
          "description" : "The Atomix configuration uri.",
          "type" : "string"
        },
        "default-action" : {
          "description" : "The default action.",
          "default" : "DIRECT",
          "enum" : [ "DIRECT", "BROADCAST" ],
          "type" : "string"
        },
        "default-resource-config" : {
          "description" : "The cluster wide default resource configuration.",
          "type" : "string"
        },
        "default-resource-options" : {
          "description" : "The local default resource options.",
          "type" : "string"
        },
        "ephemeral" : {
          "description" : "Sets if the local member should join groups as PersistentMember or not. If set to ephemeral the local member will receive an auto generated ID thus the local one is ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "member-name" : {
          "description" : "The Atomix Group member name",
          "type" : "string"
        },
        "nodes" : {
          "description" : "The address of the nodes composing the cluster.",
          "type" : "string"
        },
        "read-consistency" : {
          "description" : "The read consistency level.",
          "enum" : [ "ATOMIC", "ATOMIC_LEASE", "SEQUENTIAL", "LOCAL" ],
          "type" : "string"
        },
        "resource-configs" : {
          "description" : "Cluster wide resources configuration.",
          "type" : "string"
        },
        "resource-options" : {
          "description" : "Local resources configurations",
          "type" : "string"
        },
        "result-header" : {
          "description" : "The header that wil carry the result.",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "transport-class-name" : {
          "description" : "The class name (fqn) of the Atomix transport",
          "default" : "io.atomix.catalyst.transport.netty.NettyTransport",
          "type" : "string"
        }
      }
    },
    "atomix-multimap" : {
      "type" : "object",
      "required" : [ "resourceName" ],
      "properties" : {
        "resource-name" : {
          "description" : "The distributed resource name",
          "type" : "string"
        },
        "atomix" : {
          "description" : "The Atomix instance to use",
          "type" : "string"
        },
        "configuration-uri" : {
          "description" : "The Atomix configuration uri.",
          "type" : "string"
        },
        "default-action" : {
          "description" : "The default action.",
          "default" : "PUT",
          "enum" : [ "PUT", "GET", "CLEAR", "SIZE", "CONTAINS_KEY", "IS_EMPTY", "REMOVE", "REMOVE_VALUE" ],
          "type" : "string"
        },
        "default-resource-config" : {
          "description" : "The cluster wide default resource configuration.",
          "type" : "string"
        },
        "default-resource-options" : {
          "description" : "The local default resource options.",
          "type" : "string"
        },
        "ephemeral" : {
          "description" : "Sets if the local member should join groups as PersistentMember or not. If set to ephemeral the local member will receive an auto generated ID thus the local one is ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "key" : {
          "description" : "The key to use if none is set in the header or to listen for events for a specific key.",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "nodes" : {
          "description" : "The address of the nodes composing the cluster.",
          "type" : "string"
        },
        "read-consistency" : {
          "description" : "The read consistency level.",
          "enum" : [ "ATOMIC", "ATOMIC_LEASE", "SEQUENTIAL", "LOCAL" ],
          "type" : "string"
        },
        "resource-configs" : {
          "description" : "Cluster wide resources configuration.",
          "type" : "string"
        },
        "resource-options" : {
          "description" : "Local resources configurations",
          "type" : "string"
        },
        "result-header" : {
          "description" : "The header that wil carry the result.",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "transport-class-name" : {
          "description" : "The class name (fqn) of the Atomix transport",
          "default" : "io.atomix.catalyst.transport.netty.NettyTransport",
          "type" : "string"
        },
        "ttl" : {
          "description" : "The resource ttl.",
          "type" : "string"
        }
      }
    },
    "atomix-queue" : {
      "type" : "object",
      "required" : [ "resourceName" ],
      "properties" : {
        "resource-name" : {
          "description" : "The distributed resource name",
          "type" : "string"
        },
        "atomix" : {
          "description" : "The Atomix instance to use",
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "configuration-uri" : {
          "description" : "The Atomix configuration uri.",
          "type" : "string"
        },
        "default-action" : {
          "description" : "The default action.",
          "default" : "ADD",
          "enum" : [ "ADD", "OFFER", "PEEK", "POLL", "CLEAR", "CONTAINS", "IS_EMPTY", "REMOVE", "SIZE" ],
          "type" : "string"
        },
        "default-resource-config" : {
          "description" : "The cluster wide default resource configuration.",
          "type" : "string"
        },
        "default-resource-options" : {
          "description" : "The local default resource options.",
          "type" : "string"
        },
        "ephemeral" : {
          "description" : "Sets if the local member should join groups as PersistentMember or not. If set to ephemeral the local member will receive an auto generated ID thus the local one is ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "nodes" : {
          "description" : "The address of the nodes composing the cluster.",
          "type" : "string"
        },
        "read-consistency" : {
          "description" : "The read consistency level.",
          "enum" : [ "ATOMIC", "ATOMIC_LEASE", "SEQUENTIAL", "LOCAL" ],
          "type" : "string"
        },
        "resource-configs" : {
          "description" : "Cluster wide resources configuration.",
          "type" : "string"
        },
        "resource-options" : {
          "description" : "Local resources configurations",
          "type" : "string"
        },
        "result-header" : {
          "description" : "The header that wil carry the result.",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "transport-class-name" : {
          "description" : "The class name (fqn) of the Atomix transport",
          "default" : "io.atomix.catalyst.transport.netty.NettyTransport",
          "type" : "string"
        }
      }
    },
    "atomix-set" : {
      "type" : "object",
      "required" : [ "resourceName" ],
      "properties" : {
        "resource-name" : {
          "description" : "The distributed resource name",
          "type" : "string"
        },
        "atomix" : {
          "description" : "The Atomix instance to use",
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "configuration-uri" : {
          "description" : "The Atomix configuration uri.",
          "type" : "string"
        },
        "default-action" : {
          "description" : "The default action.",
          "default" : "ADD",
          "enum" : [ "ADD", "CLEAR", "CONTAINS", "IS_EMPTY", "REMOVE", "SIZE" ],
          "type" : "string"
        },
        "default-resource-config" : {
          "description" : "The cluster wide default resource configuration.",
          "type" : "string"
        },
        "default-resource-options" : {
          "description" : "The local default resource options.",
          "type" : "string"
        },
        "ephemeral" : {
          "description" : "Sets if the local member should join groups as PersistentMember or not. If set to ephemeral the local member will receive an auto generated ID thus the local one is ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "nodes" : {
          "description" : "The address of the nodes composing the cluster.",
          "type" : "string"
        },
        "read-consistency" : {
          "description" : "The read consistency level.",
          "enum" : [ "ATOMIC", "ATOMIC_LEASE", "SEQUENTIAL", "LOCAL" ],
          "type" : "string"
        },
        "resource-configs" : {
          "description" : "Cluster wide resources configuration.",
          "type" : "string"
        },
        "resource-options" : {
          "description" : "Local resources configurations",
          "type" : "string"
        },
        "result-header" : {
          "description" : "The header that wil carry the result.",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "transport-class-name" : {
          "description" : "The class name (fqn) of the Atomix transport",
          "default" : "io.atomix.catalyst.transport.netty.NettyTransport",
          "type" : "string"
        },
        "ttl" : {
          "description" : "The resource ttl.",
          "type" : "string"
        }
      }
    },
    "atomix-value" : {
      "type" : "object",
      "required" : [ "resourceName" ],
      "properties" : {
        "resource-name" : {
          "description" : "The distributed resource name",
          "type" : "string"
        },
        "atomix" : {
          "description" : "The Atomix instance to use",
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "configuration-uri" : {
          "description" : "The Atomix configuration uri.",
          "type" : "string"
        },
        "default-action" : {
          "description" : "The default action.",
          "default" : "SET",
          "enum" : [ "SET", "GET", "GET_AND_SET", "COMPARE_AND_SET" ],
          "type" : "string"
        },
        "default-resource-config" : {
          "description" : "The cluster wide default resource configuration.",
          "type" : "string"
        },
        "default-resource-options" : {
          "description" : "The local default resource options.",
          "type" : "string"
        },
        "ephemeral" : {
          "description" : "Sets if the local member should join groups as PersistentMember or not. If set to ephemeral the local member will receive an auto generated ID thus the local one is ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "nodes" : {
          "description" : "The address of the nodes composing the cluster.",
          "type" : "string"
        },
        "read-consistency" : {
          "description" : "The read consistency level.",
          "enum" : [ "ATOMIC", "ATOMIC_LEASE", "SEQUENTIAL", "LOCAL" ],
          "type" : "string"
        },
        "resource-configs" : {
          "description" : "Cluster wide resources configuration.",
          "type" : "string"
        },
        "resource-options" : {
          "description" : "Local resources configurations",
          "type" : "string"
        },
        "result-header" : {
          "description" : "The header that wil carry the result.",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "transport-class-name" : {
          "description" : "The class name (fqn) of the Atomix transport",
          "default" : "io.atomix.catalyst.transport.netty.NettyTransport",
          "type" : "string"
        },
        "ttl" : {
          "description" : "The resource ttl.",
          "type" : "string"
        }
      }
    },
    "avro" : {
      "type" : "object",
      "required" : [ "host", "port", "transport" ],
      "properties" : {
        "host" : {
          "description" : "Hostname to use",
          "type" : "string"
        },
        "message-name" : {
          "description" : "The name of the message to send.",
          "type" : "string"
        },
        "port" : {
          "description" : "Port number to use",
          "type" : "integer"
        },
        "transport" : {
          "description" : "Transport to use, can be either http or netty",
          "enum" : [ "http", "netty" ],
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "protocol" : {
          "description" : "Avro protocol to use",
          "type" : "string"
        },
        "protocol-class-name" : {
          "description" : "Avro protocol to use defined by the FQN class name",
          "type" : "string"
        },
        "protocol-location" : {
          "description" : "Avro protocol location",
          "type" : "string"
        },
        "reflection-protocol" : {
          "description" : "If protocol object provided is reflection protocol. Should be used only with protocol parameter because for protocolClassName protocol type will be auto detected",
          "default" : "false",
          "type" : "boolean"
        },
        "single-parameter" : {
          "description" : "If true, consumer parameter won't be wrapped into array. Will fail if protocol specifies more then 1 parameter for the message",
          "default" : "false",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "uri-authority" : {
          "description" : "Authority to use (username and password)",
          "type" : "string"
        }
      }
    },
    "aws-cw" : {
      "type" : "object",
      "required" : [ "namespace" ],
      "properties" : {
        "namespace" : {
          "description" : "The metric namespace",
          "type" : "string"
        },
        "access-key" : {
          "description" : "Amazon AWS Access Key",
          "type" : "string"
        },
        "amazon-cw-client" : {
          "description" : "To use the AmazonCloudWatch as the client",
          "type" : "string"
        },
        "auto-discover-client" : {
          "description" : "Setting the autoDiscoverClient mechanism, if true, the component will look for a client instance in the registry automatically otherwise it will skip that checking.",
          "default" : "true",
          "type" : "boolean"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "name" : {
          "description" : "The metric name",
          "type" : "string"
        },
        "proxy-host" : {
          "description" : "To define a proxy host when instantiating the CW client",
          "type" : "string"
        },
        "proxy-port" : {
          "description" : "To define a proxy port when instantiating the CW client",
          "type" : "integer"
        },
        "proxy-protocol" : {
          "description" : "To define a proxy protocol when instantiating the CW client",
          "default" : "HTTPS",
          "enum" : [ "HTTP", "HTTPS" ],
          "type" : "string"
        },
        "region" : {
          "description" : "The region in which CW client needs to work. When using this parameter, the configuration will expect the capitalized name of the region (for example AP_EAST_1) You'll need to use the name Regions.EU_WEST_1.name()",
          "type" : "string"
        },
        "secret-key" : {
          "description" : "Amazon AWS Secret Key",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "timestamp" : {
          "description" : "The metric timestamp",
          "type" : "string"
        },
        "unit" : {
          "description" : "The metric unit",
          "type" : "string"
        },
        "value" : {
          "description" : "The metric value",
          "type" : "number"
        }
      }
    },
    "aws-ddb" : {
      "type" : "object",
      "required" : [ "tableName" ],
      "properties" : {
        "table-name" : {
          "description" : "The name of the table currently worked with.",
          "type" : "string"
        },
        "access-key" : {
          "description" : "Amazon AWS Access Key",
          "type" : "string"
        },
        "amazon-ddb-client" : {
          "description" : "To use the AmazonDynamoDB as the client",
          "type" : "string"
        },
        "auto-discover-client" : {
          "description" : "Setting the autoDiscoverClient mechanism, if true, the component will look for a client instance in the registry automatically otherwise it will skip that checking.",
          "default" : "true",
          "type" : "boolean"
        },
        "consistent-read" : {
          "description" : "Determines whether or not strong consistency should be enforced when data is read.",
          "default" : "false",
          "type" : "boolean"
        },
        "key-attribute-name" : {
          "description" : "Attribute name when creating table",
          "type" : "string"
        },
        "key-attribute-type" : {
          "description" : "Attribute type when creating table",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "operation" : {
          "description" : "What operation to perform",
          "default" : "PutItem",
          "enum" : [ "BatchGetItems", "DeleteItem", "DeleteTable", "DescribeTable", "GetItem", "PutItem", "Query", "Scan", "UpdateItem", "UpdateTable" ],
          "type" : "string"
        },
        "proxy-host" : {
          "description" : "To define a proxy host when instantiating the DDB client",
          "type" : "string"
        },
        "proxy-port" : {
          "description" : "To define a proxy port when instantiating the DDB client. When using this parameter, the configuration will expect the capitalized name of the region (for example AP_EAST_1) You'll need to use the name Regions.EU_WEST_1.name()",
          "type" : "integer"
        },
        "proxy-protocol" : {
          "description" : "To define a proxy protocol when instantiating the DDB client",
          "default" : "HTTPS",
          "enum" : [ "HTTP", "HTTPS" ],
          "type" : "string"
        },
        "read-capacity" : {
          "description" : "The provisioned throughput to reserve for reading resources from your table",
          "type" : "integer"
        },
        "region" : {
          "description" : "The region in which DDB client needs to work",
          "type" : "string"
        },
        "secret-key" : {
          "description" : "Amazon AWS Secret Key",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "write-capacity" : {
          "description" : "The provisioned throughput to reserved for writing resources to your table",
          "type" : "integer"
        }
      }
    },
    "aws-ddbstream" : {
      "type" : "object",
      "required" : [ "tableName" ],
      "properties" : {
        "table-name" : {
          "description" : "Name of the dynamodb table",
          "type" : "string"
        },
        "access-key" : {
          "description" : "Amazon AWS Access Key",
          "type" : "string"
        },
        "amazon-dynamo-db-streams-client" : {
          "description" : "Amazon DynamoDB client to use for all requests for this endpoint",
          "type" : "string"
        },
        "auto-discover-client" : {
          "description" : "Setting the autoDiscoverClient mechanism, if true, the component will look for a client instance in the registry automatically otherwise it will skip that checking",
          "default" : "true",
          "type" : "boolean"
        },
        "backoff-error-threshold" : {
          "description" : "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-idle-threshold" : {
          "description" : "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-multiplier" : {
          "description" : "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
          "type" : "integer"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "delay" : {
          "description" : "Milliseconds before the next poll.",
          "default" : "500",
          "type" : "integer"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "greedy" : {
          "description" : "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
          "default" : "false",
          "type" : "boolean"
        },
        "initial-delay" : {
          "description" : "Milliseconds before the first poll starts.",
          "default" : "1000",
          "type" : "integer"
        },
        "iterator-type" : {
          "description" : "Defines where in the DynaboDB stream to start getting records. Note that using TRIM_HORIZON can cause a significant delay before the stream has caught up to real-time. if {AT,AFTER}_SEQUENCE_NUMBER are used, then a sequenceNumberProvider MUST be supplied.",
          "default" : "LATEST",
          "enum" : [ "TRIM_HORIZON", "LATEST", "AT_SEQUENCE_NUMBER", "AFTER_SEQUENCE_NUMBER" ],
          "type" : "string"
        },
        "max-results-per-request" : {
          "description" : "Maximum number of records that will be fetched in each poll",
          "type" : "integer"
        },
        "poll-strategy" : {
          "description" : "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
          "type" : "string"
        },
        "proxy-host" : {
          "description" : "To define a proxy host when instantiating the DDBStreams client",
          "type" : "string"
        },
        "proxy-port" : {
          "description" : "To define a proxy port when instantiating the DDBStreams client",
          "type" : "integer"
        },
        "proxy-protocol" : {
          "description" : "To define a proxy protocol when instantiating the DDBStreams client",
          "default" : "HTTPS",
          "enum" : [ "HTTP", "HTTPS" ],
          "type" : "string"
        },
        "region" : {
          "description" : "The region in which DDBStreams client needs to work",
          "type" : "string"
        },
        "repeat-count" : {
          "description" : "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
          "default" : "0",
          "type" : "integer"
        },
        "run-logging-level" : {
          "description" : "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
          "default" : "TRACE",
          "enum" : [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ],
          "type" : "string"
        },
        "scheduled-executor-service" : {
          "description" : "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
          "type" : "string"
        },
        "scheduler" : {
          "description" : "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
          "default" : "none",
          "type" : "string"
        },
        "scheduler-properties" : {
          "description" : "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
          "type" : "string"
        },
        "secret-key" : {
          "description" : "Amazon AWS Secret Key",
          "type" : "string"
        },
        "send-empty-message-when-idle" : {
          "description" : "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
          "default" : "false",
          "type" : "boolean"
        },
        "sequence-number-provider" : {
          "description" : "Provider for the sequence number when using one of the two ShardIteratorType.{AT,AFTER}_SEQUENCE_NUMBER iterator types. Can be a registry reference or a literal sequence number.",
          "type" : "string"
        },
        "start-scheduler" : {
          "description" : "Whether the scheduler should be auto started.",
          "default" : "true",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "time-unit" : {
          "description" : "Time unit for initialDelay and delay options.",
          "default" : "MILLISECONDS",
          "enum" : [ "NANOSECONDS", "MICROSECONDS", "MILLISECONDS", "SECONDS", "MINUTES", "HOURS", "DAYS" ],
          "type" : "string"
        },
        "use-fixed-delay" : {
          "description" : "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
          "default" : "true",
          "type" : "boolean"
        }
      }
    },
    "aws-ec2" : {
      "type" : "object",
      "required" : [ "label", "operation" ],
      "properties" : {
        "label" : {
          "description" : "Logical name",
          "type" : "string"
        },
        "access-key" : {
          "description" : "Amazon AWS Access Key",
          "type" : "string"
        },
        "amazon-ec2-client" : {
          "description" : "To use a existing configured AmazonEC2Client as client",
          "type" : "string"
        },
        "auto-discover-client" : {
          "description" : "Setting the autoDiscoverClient mechanism, if true, the component will look for a client instance in the registry automatically otherwise it will skip that checking.",
          "default" : "true",
          "type" : "boolean"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "operation" : {
          "description" : "The operation to perform. It can be createAndRunInstances, startInstances, stopInstances, terminateInstances, describeInstances, describeInstancesStatus, rebootInstances, monitorInstances, unmonitorInstances, createTags or deleteTags",
          "enum" : [ "createAndRunInstances", "startInstances", "stopInstances", "terminateInstances", "describeInstances", "describeInstancesStatus", "rebootInstances", "monitorInstances", "unmonitorInstances", "createTags", "deleteTags" ],
          "type" : "string"
        },
        "proxy-host" : {
          "description" : "To define a proxy host when instantiating the EC2 client",
          "type" : "string"
        },
        "proxy-port" : {
          "description" : "To define a proxy port when instantiating the EC2 client",
          "type" : "integer"
        },
        "proxy-protocol" : {
          "description" : "To define a proxy protocol when instantiating the EC2 client",
          "default" : "HTTPS",
          "enum" : [ "HTTP", "HTTPS" ],
          "type" : "string"
        },
        "region" : {
          "description" : "The region in which ECS client needs to work. When using this parameter, the configuration will expect the lowercase name of the region (for example ap-east-1) You'll need to use the name Region.EU_WEST_1.id()",
          "type" : "string"
        },
        "secret-key" : {
          "description" : "Amazon AWS Secret Key",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "aws-ecs" : {
      "type" : "object",
      "required" : [ "label", "operation" ],
      "properties" : {
        "label" : {
          "description" : "Logical name",
          "type" : "string"
        },
        "access-key" : {
          "description" : "Amazon AWS Access Key",
          "type" : "string"
        },
        "auto-discover-client" : {
          "description" : "Setting the autoDiscoverClient mechanism, if true, the component will look for a client instance in the registry automatically otherwise it will skip that checking.",
          "default" : "true",
          "type" : "boolean"
        },
        "ecs-client" : {
          "description" : "To use a existing configured AWS ECS as client",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "operation" : {
          "description" : "The operation to perform",
          "enum" : [ "listClusters", "describeCluster", "createCluster", "deleteCluster" ],
          "type" : "string"
        },
        "proxy-host" : {
          "description" : "To define a proxy host when instantiating the ECS client",
          "type" : "string"
        },
        "proxy-port" : {
          "description" : "To define a proxy port when instantiating the ECS client",
          "type" : "integer"
        },
        "proxy-protocol" : {
          "description" : "To define a proxy protocol when instantiating the ECS client",
          "default" : "HTTPS",
          "enum" : [ "HTTP", "HTTPS" ],
          "type" : "string"
        },
        "region" : {
          "description" : "The region in which ECS client needs to work. When using this parameter, the configuration will expect the capitalized name of the region (for example AP_EAST_1) You'll need to use the name Regions.EU_WEST_1.name()",
          "type" : "string"
        },
        "secret-key" : {
          "description" : "Amazon AWS Secret Key",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "aws-eks" : {
      "type" : "object",
      "required" : [ "label", "operation" ],
      "properties" : {
        "label" : {
          "description" : "Logical name",
          "type" : "string"
        },
        "access-key" : {
          "description" : "Amazon AWS Access Key",
          "type" : "string"
        },
        "auto-discover-client" : {
          "description" : "Setting the autoDiscoverClient mechanism, if true, the component will look for a client instance in the registry automatically otherwise it will skip that checking.",
          "default" : "true",
          "type" : "boolean"
        },
        "eks-client" : {
          "description" : "To use a existing configured AWS EKS as client",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "operation" : {
          "description" : "The operation to perform",
          "enum" : [ "listClusters", "describeCluster", "createCluster", "deleteCluster" ],
          "type" : "string"
        },
        "proxy-host" : {
          "description" : "To define a proxy host when instantiating the EKS client",
          "type" : "string"
        },
        "proxy-port" : {
          "description" : "To define a proxy port when instantiating the EKS client",
          "type" : "integer"
        },
        "proxy-protocol" : {
          "description" : "To define a proxy protocol when instantiating the EKS client",
          "default" : "HTTPS",
          "enum" : [ "HTTP", "HTTPS" ],
          "type" : "string"
        },
        "region" : {
          "description" : "The region in which EKS client needs to work. When using this parameter, the configuration will expect the capitalized name of the region (for example AP_EAST_1) You'll need to use the name Regions.EU_WEST_1.name()",
          "type" : "string"
        },
        "secret-key" : {
          "description" : "Amazon AWS Secret Key",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "aws-iam" : {
      "type" : "object",
      "required" : [ "label", "operation" ],
      "properties" : {
        "label" : {
          "description" : "Logical name",
          "type" : "string"
        },
        "access-key" : {
          "description" : "Amazon AWS Access Key",
          "type" : "string"
        },
        "auto-discover-client" : {
          "description" : "Setting the autoDiscoverClient mechanism, if true, the component will look for a client instance in the registry automatically otherwise it will skip that checking.",
          "default" : "true",
          "type" : "boolean"
        },
        "iam-client" : {
          "description" : "To use a existing configured AWS IAM as client",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "operation" : {
          "description" : "The operation to perform",
          "enum" : [ "listAccessKeys", "createUser", "deleteUser", "getUser", "listUsers", "createAccessKey", "deleteAccessKey", "updateAccessKey", "createGroup", "deleteGroup", "listGroups", "addUserToGroup", "removeUserFromGroup" ],
          "type" : "string"
        },
        "proxy-host" : {
          "description" : "To define a proxy host when instantiating the IAM client",
          "type" : "string"
        },
        "proxy-port" : {
          "description" : "To define a proxy port when instantiating the IAM client",
          "type" : "integer"
        },
        "proxy-protocol" : {
          "description" : "To define a proxy protocol when instantiating the IAM client",
          "default" : "HTTPS",
          "enum" : [ "HTTP", "HTTPS" ],
          "type" : "string"
        },
        "region" : {
          "description" : "The region in which IAM client needs to work. When using this parameter, the configuration will expect the capitalized name of the region (for example AP_EAST_1) You'll need to use the name Regions.EU_WEST_1.name()",
          "type" : "string"
        },
        "secret-key" : {
          "description" : "Amazon AWS Secret Key",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "aws-kinesis" : {
      "type" : "object",
      "required" : [ "streamName" ],
      "properties" : {
        "stream-name" : {
          "description" : "Name of the stream",
          "type" : "string"
        },
        "access-key" : {
          "description" : "Amazon AWS Access Key",
          "type" : "string"
        },
        "amazon-kinesis-client" : {
          "description" : "Amazon Kinesis client to use for all requests for this endpoint",
          "type" : "string"
        },
        "auto-discover-client" : {
          "description" : "Setting the autoDiscoverClient mechanism, if true, the component will look for a client instance in the registry automatically otherwise it will skip that checking",
          "default" : "true",
          "type" : "boolean"
        },
        "backoff-error-threshold" : {
          "description" : "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-idle-threshold" : {
          "description" : "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-multiplier" : {
          "description" : "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
          "type" : "integer"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "delay" : {
          "description" : "Milliseconds before the next poll.",
          "default" : "500",
          "type" : "integer"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "greedy" : {
          "description" : "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
          "default" : "false",
          "type" : "boolean"
        },
        "initial-delay" : {
          "description" : "Milliseconds before the first poll starts.",
          "default" : "1000",
          "type" : "integer"
        },
        "iterator-type" : {
          "description" : "Defines where in the Kinesis stream to start getting records",
          "default" : "TRIM_HORIZON",
          "enum" : [ "AT_SEQUENCE_NUMBER", "AFTER_SEQUENCE_NUMBER", "TRIM_HORIZON", "LATEST", "AT_TIMESTAMP" ],
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "max-results-per-request" : {
          "description" : "Maximum number of records that will be fetched in each poll",
          "default" : "1",
          "type" : "integer"
        },
        "poll-strategy" : {
          "description" : "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
          "type" : "string"
        },
        "proxy-host" : {
          "description" : "To define a proxy host when instantiating the Kinesis client",
          "type" : "string"
        },
        "proxy-port" : {
          "description" : "To define a proxy port when instantiating the Kinesis client",
          "type" : "integer"
        },
        "proxy-protocol" : {
          "description" : "To define a proxy protocol when instantiating the Kinesis client",
          "default" : "HTTPS",
          "enum" : [ "HTTP", "HTTPS" ],
          "type" : "string"
        },
        "region" : {
          "description" : "The region in which Kinesis client needs to work. When using this parameter, the configuration will expect the capitalized name of the region (for example AP_EAST_1)You'll need to use the name Regions.EU_WEST_1.name()",
          "type" : "string"
        },
        "repeat-count" : {
          "description" : "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
          "default" : "0",
          "type" : "integer"
        },
        "run-logging-level" : {
          "description" : "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
          "default" : "TRACE",
          "enum" : [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ],
          "type" : "string"
        },
        "scheduled-executor-service" : {
          "description" : "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
          "type" : "string"
        },
        "scheduler" : {
          "description" : "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
          "default" : "none",
          "type" : "string"
        },
        "scheduler-properties" : {
          "description" : "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
          "type" : "string"
        },
        "secret-key" : {
          "description" : "Amazon AWS Secret Key",
          "type" : "string"
        },
        "send-empty-message-when-idle" : {
          "description" : "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
          "default" : "false",
          "type" : "boolean"
        },
        "sequence-number" : {
          "description" : "The sequence number to start polling from. Required if iteratorType is set to AFTER_SEQUENCE_NUMBER or AT_SEQUENCE_NUMBER",
          "type" : "string"
        },
        "shard-closed" : {
          "description" : "Define what will be the behavior in case of shard closed. Possible value are ignore, silent and fail. In case of ignore a message will be logged and the consumer will restart from the beginning,in case of silent there will be no logging and the consumer will start from the beginning,in case of fail a ReachedClosedStateException will be raised",
          "default" : "ignore",
          "enum" : [ "ignore", "fail", "silent" ],
          "type" : "string"
        },
        "shard-id" : {
          "description" : "Defines which shardId in the Kinesis stream to get records from",
          "type" : "string"
        },
        "start-scheduler" : {
          "description" : "Whether the scheduler should be auto started.",
          "default" : "true",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "time-unit" : {
          "description" : "Time unit for initialDelay and delay options.",
          "default" : "MILLISECONDS",
          "enum" : [ "NANOSECONDS", "MICROSECONDS", "MILLISECONDS", "SECONDS", "MINUTES", "HOURS", "DAYS" ],
          "type" : "string"
        },
        "use-fixed-delay" : {
          "description" : "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
          "default" : "true",
          "type" : "boolean"
        }
      }
    },
    "aws-kinesis-firehose" : {
      "type" : "object",
      "required" : [ "streamName" ],
      "properties" : {
        "stream-name" : {
          "description" : "Name of the stream",
          "type" : "string"
        },
        "access-key" : {
          "description" : "Amazon AWS Access Key",
          "type" : "string"
        },
        "amazon-kinesis-firehose-client" : {
          "description" : "Amazon Kinesis Firehose client to use for all requests for this endpoint",
          "type" : "string"
        },
        "auto-discover-client" : {
          "description" : "Setting the autoDiscoverClient mechanism, if true, the component will look for a client instance in the registry automatically otherwise it will skip that checking",
          "default" : "true",
          "type" : "boolean"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "proxy-host" : {
          "description" : "To define a proxy host when instantiating the Kinesis Firehose client",
          "type" : "string"
        },
        "proxy-port" : {
          "description" : "To define a proxy port when instantiating the Kinesis Firehose client",
          "type" : "integer"
        },
        "proxy-protocol" : {
          "description" : "To define a proxy protocol when instantiating the Kinesis Firehose client",
          "default" : "HTTPS",
          "enum" : [ "HTTP", "HTTPS" ],
          "type" : "string"
        },
        "region" : {
          "description" : "The region in which Kinesis client needs to work. When using this parameter, the configuration will expect the capitalized name of the region (for example AP_EAST_1)You'll need to use the name Regions.EU_WEST_1.name()",
          "type" : "string"
        },
        "secret-key" : {
          "description" : "Amazon AWS Secret Key",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "aws-kms" : {
      "type" : "object",
      "required" : [ "label", "operation" ],
      "properties" : {
        "label" : {
          "description" : "Logical name",
          "type" : "string"
        },
        "access-key" : {
          "description" : "Amazon AWS Access Key",
          "type" : "string"
        },
        "auto-discover-client" : {
          "description" : "Setting the autoDiscoverClient mechanism, if true, the component will look for a client instance in the registry automatically otherwise it will skip that checking.",
          "default" : "true",
          "type" : "boolean"
        },
        "kms-client" : {
          "description" : "To use a existing configured AWS KMS as client",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "operation" : {
          "description" : "The operation to perform",
          "enum" : [ "listKeys", "createKey", "disableKey", "scheduleKeyDeletion", "describeKey", "enableKey" ],
          "type" : "string"
        },
        "proxy-host" : {
          "description" : "To define a proxy host when instantiating the KMS client",
          "type" : "string"
        },
        "proxy-port" : {
          "description" : "To define a proxy port when instantiating the KMS client",
          "type" : "integer"
        },
        "proxy-protocol" : {
          "description" : "To define a proxy protocol when instantiating the KMS client",
          "default" : "HTTPS",
          "enum" : [ "HTTP", "HTTPS" ],
          "type" : "string"
        },
        "region" : {
          "description" : "The region in which KMS client needs to work. When using this parameter, the configuration will expect the capitalized name of the region (for example AP_EAST_1) You'll need to use the name Regions.EU_WEST_1.name()",
          "type" : "string"
        },
        "secret-key" : {
          "description" : "Amazon AWS Secret Key",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "aws-lambda" : {
      "type" : "object",
      "required" : [ "function" ],
      "properties" : {
        "function" : {
          "description" : "Name of the Lambda function.",
          "type" : "string"
        },
        "access-key" : {
          "description" : "Amazon AWS Access Key",
          "type" : "string"
        },
        "auto-discover-client" : {
          "description" : "Setting the autoDiscoverClient mechanism, if true, the component will look for a client instance in the registry automatically otherwise it will skip that checking.",
          "default" : "true",
          "type" : "boolean"
        },
        "aws-lambda-client" : {
          "description" : "To use a existing configured AwsLambdaClient as client",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "operation" : {
          "description" : "The operation to perform. It can be listFunctions, getFunction, createFunction, deleteFunction or invokeFunction",
          "default" : "invokeFunction",
          "enum" : [ "listFunctions", "getFunction", "createAlias", "deleteAlias", "getAlias", "listAliases", "createFunction", "deleteFunction", "invokeFunction", "updateFunction", "createEventSourceMapping", "deleteEventSourceMapping", "listEventSourceMapping", "listTags", "tagResource", "untagResource", "publishVersion", "listVersions" ],
          "type" : "string"
        },
        "proxy-host" : {
          "description" : "To define a proxy host when instantiating the Lambda client",
          "type" : "string"
        },
        "proxy-port" : {
          "description" : "To define a proxy port when instantiating the Lambda client",
          "type" : "integer"
        },
        "proxy-protocol" : {
          "description" : "To define a proxy protocol when instantiating the Lambda client",
          "default" : "HTTPS",
          "enum" : [ "HTTP", "HTTPS" ],
          "type" : "string"
        },
        "region" : {
          "description" : "Amazon AWS Region. When using this parameter, the configuration will expect the capitalized name of the region (for example AP_EAST_1) You'll need to use the name Regions.EU_WEST_1.name()",
          "type" : "string"
        },
        "secret-key" : {
          "description" : "Amazon AWS Secret Key",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "aws-mq" : {
      "type" : "object",
      "required" : [ "label", "operation" ],
      "properties" : {
        "label" : {
          "description" : "Logical name",
          "type" : "string"
        },
        "access-key" : {
          "description" : "Amazon AWS Access Key",
          "type" : "string"
        },
        "amazon-mq-client" : {
          "description" : "To use a existing configured AmazonMQClient as client",
          "type" : "string"
        },
        "auto-discover-client" : {
          "description" : "Setting the autoDiscoverClient mechanism, if true, the component will look for a client instance in the registry automatically otherwise it will skip that checking.",
          "default" : "true",
          "type" : "boolean"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "operation" : {
          "description" : "The operation to perform. It can be listBrokers,createBroker,deleteBroker",
          "enum" : [ "listBrokers", "createBroker", "deleteBroker", "rebootBroker", "updateBroker", "describeBroker" ],
          "type" : "string"
        },
        "proxy-host" : {
          "description" : "To define a proxy host when instantiating the MQ client",
          "type" : "string"
        },
        "proxy-port" : {
          "description" : "To define a proxy port when instantiating the MQ client",
          "type" : "integer"
        },
        "proxy-protocol" : {
          "description" : "To define a proxy protocol when instantiating the MQ client",
          "default" : "HTTPS",
          "enum" : [ "HTTP", "HTTPS" ],
          "type" : "string"
        },
        "region" : {
          "description" : "The region in which MQ client needs to work. When using this parameter, the configuration will expect the capitalized name of the region (for example AP_EAST_1) You'll need to use the name Regions.EU_WEST_1.name()",
          "type" : "string"
        },
        "secret-key" : {
          "description" : "Amazon AWS Secret Key",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "aws-msk" : {
      "type" : "object",
      "required" : [ "label", "operation" ],
      "properties" : {
        "label" : {
          "description" : "Logical name",
          "type" : "string"
        },
        "access-key" : {
          "description" : "Amazon AWS Access Key",
          "type" : "string"
        },
        "auto-discover-client" : {
          "description" : "Setting the autoDiscoverClient mechanism, if true, the component will look for a client instance in the registry automatically otherwise it will skip that checking.",
          "default" : "true",
          "type" : "boolean"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "msk-client" : {
          "description" : "To use a existing configured AWS MSK as client",
          "type" : "string"
        },
        "operation" : {
          "description" : "The operation to perform",
          "enum" : [ "listClusters", "createCluster", "deleteCluster", "describeCluster" ],
          "type" : "string"
        },
        "proxy-host" : {
          "description" : "To define a proxy host when instantiating the MSK client",
          "type" : "string"
        },
        "proxy-port" : {
          "description" : "To define a proxy port when instantiating the MSK client",
          "type" : "integer"
        },
        "proxy-protocol" : {
          "description" : "To define a proxy protocol when instantiating the MSK client",
          "default" : "HTTPS",
          "enum" : [ "HTTP", "HTTPS" ],
          "type" : "string"
        },
        "region" : {
          "description" : "The region in which MSK client needs to work. When using this parameter, the configuration will expect the capitalized name of the region (for example AP_EAST_1) You'll need to use the name Regions.EU_WEST_1.name()",
          "type" : "string"
        },
        "secret-key" : {
          "description" : "Amazon AWS Secret Key",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "aws-s3" : {
      "type" : "object",
      "required" : [ "bucketNameOrArn" ],
      "properties" : {
        "bucket-name-or-arn" : {
          "description" : "Bucket name or ARN",
          "type" : "string"
        },
        "accelerate-mode-enabled" : {
          "description" : "Define if Accelerate Mode enabled is true or false",
          "default" : "false",
          "type" : "boolean"
        },
        "access-key" : {
          "description" : "Amazon AWS Access Key",
          "type" : "string"
        },
        "amazon-s3-client" : {
          "description" : "Reference to a com.amazonaws.services.s3.AmazonS3 in the registry.",
          "type" : "string"
        },
        "auto-create-bucket" : {
          "description" : "Setting the autocreation of the bucket",
          "default" : "true",
          "type" : "boolean"
        },
        "auto-discover-client" : {
          "description" : "Setting the autoDiscoverClient mechanism, if true, the component will look for a client instance in the registry automatically otherwise it will skip that checking.",
          "default" : "true",
          "type" : "boolean"
        },
        "autoclose-body" : {
          "description" : "If this option is true and includeBody is true, then the S3Object.close() method will be called on exchange completion. This option is strongly related to includeBody option. In case of setting includeBody to true and autocloseBody to false, it will be up to the caller to close the S3Object stream. Setting autocloseBody to true, will close the S3Object stream automatically.",
          "default" : "true",
          "type" : "boolean"
        },
        "aws-kms-key-id" : {
          "description" : "Define the id of KMS key to use in case KMS is enabled",
          "type" : "string"
        },
        "backoff-error-threshold" : {
          "description" : "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-idle-threshold" : {
          "description" : "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-multiplier" : {
          "description" : "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
          "type" : "integer"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "chunked-encoding-disabled" : {
          "description" : "Define if disabled Chunked Encoding is true or false",
          "default" : "false",
          "type" : "boolean"
        },
        "delay" : {
          "description" : "Milliseconds before the next poll.",
          "default" : "500",
          "type" : "integer"
        },
        "delete-after-read" : {
          "description" : "Delete objects from S3 after they have been retrieved. The delete is only performed if the Exchange is committed. If a rollback occurs, the object is not deleted. If this option is false, then the same objects will be retrieve over and over again on the polls. Therefore you need to use the Idempotent Consumer EIP in the route to filter out duplicates. You can filter using the S3Constants#BUCKET_NAME and S3Constants#KEY headers, or only the S3Constants#KEY header.",
          "default" : "true",
          "type" : "boolean"
        },
        "delete-after-write" : {
          "description" : "Delete file object after the S3 file has been uploaded",
          "default" : "false",
          "type" : "boolean"
        },
        "delimiter" : {
          "description" : "The delimiter which is used in the com.amazonaws.services.s3.model.ListObjectsRequest to only consume objects we are interested in.",
          "type" : "string"
        },
        "dualstack-enabled" : {
          "description" : "Define if Dualstack enabled is true or false",
          "default" : "false",
          "type" : "boolean"
        },
        "encryption-materials" : {
          "description" : "The encryption materials to use in case of Symmetric/Asymmetric client usage",
          "type" : "string"
        },
        "endpoint-configuration" : {
          "description" : "Amazon AWS Endpoint Configuration",
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "file-name" : {
          "description" : "To get the object from the bucket with the given file name",
          "type" : "string"
        },
        "force-global-bucket-access-enabled" : {
          "description" : "Define if Force Global Bucket Access enabled is true or false",
          "default" : "false",
          "type" : "boolean"
        },
        "greedy" : {
          "description" : "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
          "default" : "false",
          "type" : "boolean"
        },
        "include-body" : {
          "description" : "If it is true, the exchange body will be set to a stream to the contents of the file. If false, the headers will be set with the S3 object metadata, but the body will be null. This option is strongly related to autocloseBody option. In case of setting includeBody to true and autocloseBody to false, it will be up to the caller to close the S3Object stream. Setting autocloseBody to true, will close the S3Object stream automatically.",
          "default" : "true",
          "type" : "boolean"
        },
        "initial-delay" : {
          "description" : "Milliseconds before the first poll starts.",
          "default" : "1000",
          "type" : "integer"
        },
        "key-name" : {
          "description" : "Setting the key name for an element in the bucket through endpoint parameter",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "max-connections" : {
          "description" : "Set the maxConnections parameter in the S3 client configuration",
          "default" : "60",
          "type" : "integer"
        },
        "max-messages-per-poll" : {
          "description" : "Gets the maximum number of messages as a limit to poll at each polling. Gets the maximum number of messages as a limit to poll at each polling. The default value is 10. Use 0 or a negative number to set it as unlimited.",
          "default" : "10",
          "type" : "integer"
        },
        "multi-part-upload" : {
          "description" : "If it is true, camel will upload the file with multi part format, the part size is decided by the option of partSize",
          "default" : "false",
          "type" : "boolean"
        },
        "operation" : {
          "description" : "The operation to do in case the user don't want to do only an upload",
          "enum" : [ "copyObject", "deleteBucket", "listBuckets", "downloadLink" ],
          "type" : "string"
        },
        "part-size" : {
          "description" : "Setup the partSize which is used in multi part upload, the default size is 25M.",
          "default" : "26214400",
          "type" : "integer"
        },
        "path-style-access" : {
          "description" : "Whether or not the S3 client should use path style access",
          "default" : "false",
          "type" : "boolean"
        },
        "payload-signing-enabled" : {
          "description" : "Define if Payload Signing enabled is true or false",
          "default" : "false",
          "type" : "boolean"
        },
        "policy" : {
          "description" : "The policy for this queue to set in the com.amazonaws.services.s3.AmazonS3#setBucketPolicy() method.",
          "type" : "string"
        },
        "poll-strategy" : {
          "description" : "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
          "type" : "string"
        },
        "prefix" : {
          "description" : "The prefix which is used in the com.amazonaws.services.s3.model.ListObjectsRequest to only consume objects we are interested in.",
          "type" : "string"
        },
        "proxy-host" : {
          "description" : "To define a proxy host when instantiating the S3 client",
          "type" : "string"
        },
        "proxy-port" : {
          "description" : "Specify a proxy port to be used inside the client definition.",
          "type" : "integer"
        },
        "proxy-protocol" : {
          "description" : "To define a proxy protocol when instantiating the S3 client",
          "default" : "HTTPS",
          "enum" : [ "HTTP", "HTTPS" ],
          "type" : "string"
        },
        "region" : {
          "description" : "The region in which S3 client needs to work. When using this parameter, the configuration will expect the capitalized name of the region (for example AP_EAST_1) You'll need to use the name Regions.EU_WEST_1.name()",
          "type" : "string"
        },
        "repeat-count" : {
          "description" : "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
          "default" : "0",
          "type" : "integer"
        },
        "run-logging-level" : {
          "description" : "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
          "default" : "TRACE",
          "enum" : [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ],
          "type" : "string"
        },
        "scheduled-executor-service" : {
          "description" : "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
          "type" : "string"
        },
        "scheduler" : {
          "description" : "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
          "default" : "none",
          "type" : "string"
        },
        "scheduler-properties" : {
          "description" : "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
          "type" : "string"
        },
        "secret-key" : {
          "description" : "Amazon AWS Secret Key",
          "type" : "string"
        },
        "send-empty-message-when-idle" : {
          "description" : "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
          "default" : "false",
          "type" : "boolean"
        },
        "server-side-encryption" : {
          "description" : "Sets the server-side encryption algorithm when encrypting the object using AWS-managed keys. For example use AES256.",
          "type" : "string"
        },
        "start-scheduler" : {
          "description" : "Whether the scheduler should be auto started.",
          "default" : "true",
          "type" : "boolean"
        },
        "storage-class" : {
          "description" : "The storage class to set in the com.amazonaws.services.s3.model.PutObjectRequest request.",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "time-unit" : {
          "description" : "Time unit for initialDelay and delay options.",
          "default" : "MILLISECONDS",
          "enum" : [ "NANOSECONDS", "MICROSECONDS", "MILLISECONDS", "SECONDS", "MINUTES", "HOURS", "DAYS" ],
          "type" : "string"
        },
        "use-aws-kms" : {
          "description" : "Define if KMS must be used or not",
          "default" : "false",
          "type" : "boolean"
        },
        "use-encryption" : {
          "description" : "Define if encryption must be used or not",
          "default" : "false",
          "type" : "boolean"
        },
        "use-fixed-delay" : {
          "description" : "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
          "default" : "true",
          "type" : "boolean"
        },
        "use-iam-credentials" : {
          "description" : "Set whether the S3 client should expect to load credentials on an EC2 instance or to expect static credentials to be passed in.",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "aws-sdb" : {
      "type" : "object",
      "required" : [ "domainName" ],
      "properties" : {
        "domain-name" : {
          "description" : "The name of the domain currently worked with.",
          "type" : "string"
        },
        "access-key" : {
          "description" : "Amazon AWS Access Key",
          "type" : "string"
        },
        "amazon-sdb-client" : {
          "description" : "To use the AmazonSimpleDB as the client",
          "type" : "string"
        },
        "consistent-read" : {
          "description" : "Determines whether or not strong consistency should be enforced when data is read.",
          "default" : "false",
          "type" : "boolean"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "max-number-of-domains" : {
          "description" : "The maximum number of domain names you want returned. The range is 1 to 100.",
          "type" : "integer"
        },
        "operation" : {
          "description" : "Operation to perform",
          "default" : "PutAttributes",
          "enum" : [ "BatchDeleteAttributes", "BatchPutAttributes", "DeleteAttributes", "DeleteDomain", "DomainMetadata", "GetAttributes", "ListDomains", "PutAttributes", "Select" ],
          "type" : "string"
        },
        "proxy-host" : {
          "description" : "To define a proxy host when instantiating the SDB client",
          "type" : "string"
        },
        "proxy-port" : {
          "description" : "To define a proxy port when instantiating the SDB client",
          "type" : "integer"
        },
        "proxy-protocol" : {
          "description" : "To define a proxy protocol when instantiating the SDB client",
          "default" : "HTTPS",
          "enum" : [ "HTTP", "HTTPS" ],
          "type" : "string"
        },
        "region" : {
          "description" : "The region in which SDB client needs to work. When using this parameter, the configuration will expect the capitalized name of the region (for example AP_EAST_1) You'll need to use the name Regions.EU_WEST_1.name()",
          "type" : "string"
        },
        "secret-key" : {
          "description" : "Amazon AWS Secret Key",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "aws-ses" : {
      "type" : "object",
      "required" : [ "from" ],
      "properties" : {
        "from" : {
          "description" : "The sender's email address.",
          "type" : "string"
        },
        "access-key" : {
          "description" : "Amazon AWS Access Key",
          "type" : "string"
        },
        "amazon-ses-client" : {
          "description" : "To use the AmazonSimpleEmailService as the client",
          "type" : "string"
        },
        "auto-discover-client" : {
          "description" : "Setting the autoDiscoverClient mechanism, if true, the component will look for a client instance in the registry automatically otherwise it will skip that checking.",
          "default" : "true",
          "type" : "boolean"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "proxy-host" : {
          "description" : "To define a proxy host when instantiating the SES client",
          "type" : "string"
        },
        "proxy-port" : {
          "description" : "To define a proxy port when instantiating the SES client",
          "type" : "integer"
        },
        "proxy-protocol" : {
          "description" : "To define a proxy protocol when instantiating the SES client",
          "default" : "HTTPS",
          "enum" : [ "HTTP", "HTTPS" ],
          "type" : "string"
        },
        "region" : {
          "description" : "The region in which SES client needs to work. When using this parameter, the configuration will expect the capitalized name of the region (for example AP_EAST_1) You'll need to use the name Regions.EU_WEST_1.name()",
          "type" : "string"
        },
        "reply-to-addresses" : {
          "description" : "List of reply-to email address(es) for the message, override it using 'CamelAwsSesReplyToAddresses' header.",
          "type" : "string"
        },
        "return-path" : {
          "description" : "The email address to which bounce notifications are to be forwarded, override it using 'CamelAwsSesReturnPath' header.",
          "type" : "string"
        },
        "secret-key" : {
          "description" : "Amazon AWS Secret Key",
          "type" : "string"
        },
        "subject" : {
          "description" : "The subject which is used if the message header 'CamelAwsSesSubject' is not present.",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "to" : {
          "description" : "List of destination email address. Can be overriden with 'CamelAwsSesTo' header.",
          "type" : "string"
        }
      }
    },
    "aws-sns" : {
      "type" : "object",
      "required" : [ "topicNameOrArn" ],
      "properties" : {
        "topic-name-or-arn" : {
          "description" : "Topic name or ARN",
          "type" : "string"
        },
        "access-key" : {
          "description" : "Amazon AWS Access Key",
          "type" : "string"
        },
        "amazon-sns-client" : {
          "description" : "To use the AmazonSNS as the client",
          "type" : "string"
        },
        "amazon-sqs-client" : {
          "description" : "An SQS Client to use as bridge between SNS and SQS",
          "type" : "string"
        },
        "auto-create-topic" : {
          "description" : "Setting the autocreation of the topic",
          "default" : "true",
          "type" : "boolean"
        },
        "auto-discover-client" : {
          "description" : "Setting the autoDiscoverClient mechanism, if true, the component will look for a client instance in the registry automatically otherwise it will skip that checking.",
          "default" : "true",
          "type" : "boolean"
        },
        "header-filter-strategy" : {
          "description" : "To use a custom HeaderFilterStrategy to map headers to/from Camel.",
          "type" : "string"
        },
        "kms-master-key-id" : {
          "description" : "The ID of an AWS-managed customer master key (CMK) for Amazon SNS or a custom CMK.",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "message-structure" : {
          "description" : "The message structure to use such as json",
          "type" : "string"
        },
        "policy" : {
          "description" : "The policy for this queue",
          "type" : "string"
        },
        "proxy-host" : {
          "description" : "To define a proxy host when instantiating the SNS client",
          "type" : "string"
        },
        "proxy-port" : {
          "description" : "To define a proxy port when instantiating the SNS client",
          "type" : "integer"
        },
        "proxy-protocol" : {
          "description" : "To define a proxy protocol when instantiating the SNS client",
          "default" : "HTTPS",
          "enum" : [ "HTTP", "HTTPS" ],
          "type" : "string"
        },
        "queue-url" : {
          "description" : "The queueUrl to subscribe to",
          "type" : "string"
        },
        "region" : {
          "description" : "The region in which SNS client needs to work. When using this parameter, the configuration will expect the capitalized name of the region (for example AP_EAST_1) You'll need to use the name Regions.EU_WEST_1.name()",
          "type" : "string"
        },
        "secret-key" : {
          "description" : "Amazon AWS Secret Key",
          "type" : "string"
        },
        "server-side-encryption-enabled" : {
          "description" : "Define if Server Side Encryption is enabled or not on the topic",
          "default" : "false",
          "type" : "boolean"
        },
        "subject" : {
          "description" : "The subject which is used if the message header 'CamelAwsSnsSubject' is not present.",
          "type" : "string"
        },
        "subscribe-sn-sto-sqs" : {
          "description" : "Define if the subscription between SNS Topic and SQS must be done or not",
          "default" : "false",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "aws-sqs" : {
      "type" : "object",
      "required" : [ "queueNameOrArn" ],
      "properties" : {
        "queue-name-or-arn" : {
          "description" : "Queue name or ARN",
          "type" : "string"
        },
        "access-key" : {
          "description" : "Amazon AWS Access Key",
          "type" : "string"
        },
        "amazon-aws-host" : {
          "description" : "The hostname of the Amazon AWS cloud.",
          "default" : "amazonaws.com",
          "type" : "string"
        },
        "amazon-sqs-client" : {
          "description" : "To use the AmazonSQS as client",
          "type" : "string"
        },
        "attribute-names" : {
          "description" : "A list of attribute names to receive when consuming. Multiple names can be separated by comma.",
          "type" : "string"
        },
        "auto-create-queue" : {
          "description" : "Setting the autocreation of the queue",
          "default" : "true",
          "type" : "boolean"
        },
        "auto-discover-client" : {
          "description" : "Setting the autoDiscoverClient mechanism, if true, the component will look for a client instance in the registry automatically otherwise it will skip that checking.",
          "default" : "true",
          "type" : "boolean"
        },
        "backoff-error-threshold" : {
          "description" : "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-idle-threshold" : {
          "description" : "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-multiplier" : {
          "description" : "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
          "type" : "integer"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "concurrent-consumers" : {
          "description" : "Allows you to use multiple threads to poll the sqs queue to increase throughput",
          "default" : "1",
          "type" : "integer"
        },
        "default-visibility-timeout" : {
          "description" : "The default visibility timeout (in seconds)",
          "type" : "integer"
        },
        "delay" : {
          "description" : "Milliseconds before the next poll.",
          "default" : "500",
          "type" : "integer"
        },
        "delay-queue" : {
          "description" : "Define if you want to apply delaySeconds option to the queue or on single messages",
          "default" : "false",
          "type" : "boolean"
        },
        "delay-seconds" : {
          "description" : "Delay sending messages for a number of seconds.",
          "type" : "integer"
        },
        "delete-after-read" : {
          "description" : "Delete message from SQS after it has been read",
          "default" : "true",
          "type" : "boolean"
        },
        "delete-if-filtered" : {
          "description" : "Whether or not to send the DeleteMessage to the SQS queue if an exchange fails to get through a filter. If 'false' and exchange does not make it through a Camel filter upstream in the route, then don't send DeleteMessage.",
          "default" : "true",
          "type" : "boolean"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "extend-message-visibility" : {
          "description" : "If enabled then a scheduled background task will keep extending the message visibility on SQS. This is needed if it takes a long time to process the message. If set to true defaultVisibilityTimeout must be set. See details at Amazon docs.",
          "default" : "false",
          "type" : "boolean"
        },
        "greedy" : {
          "description" : "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
          "default" : "false",
          "type" : "boolean"
        },
        "header-filter-strategy" : {
          "description" : "To use a custom HeaderFilterStrategy to map headers to/from Camel.",
          "type" : "string"
        },
        "initial-delay" : {
          "description" : "Milliseconds before the first poll starts.",
          "default" : "1000",
          "type" : "integer"
        },
        "kms-data-key-reuse-period-seconds" : {
          "description" : "The length of time, in seconds, for which Amazon SQS can reuse a data key to encrypt or decrypt messages before calling AWS KMS again. An integer representing seconds, between 60 seconds (1 minute) and 86,400 seconds (24 hours). Default: 300 (5 minutes).",
          "type" : "integer"
        },
        "kms-master-key-id" : {
          "description" : "The ID of an AWS-managed customer master key (CMK) for Amazon SQS or a custom CMK.",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "max-messages-per-poll" : {
          "description" : "Gets the maximum number of messages as a limit to poll at each polling. Is default unlimited, but use 0 or negative number to disable it as unlimited.",
          "type" : "integer"
        },
        "maximum-message-size" : {
          "description" : "The maximumMessageSize (in bytes) an SQS message can contain for this queue.",
          "type" : "integer"
        },
        "message-attribute-names" : {
          "description" : "A list of message attribute names to receive when consuming. Multiple names can be separated by comma.",
          "type" : "string"
        },
        "message-deduplication-id-strategy" : {
          "description" : "Only for FIFO queues. Strategy for setting the messageDeduplicationId on the message. Can be one of the following options: useExchangeId, useContentBasedDeduplication. For the useContentBasedDeduplication option, no messageDeduplicationId will be set on the message.",
          "default" : "useExchangeId",
          "enum" : [ "useExchangeId", "useContentBasedDeduplication" ],
          "type" : "string"
        },
        "message-group-id-strategy" : {
          "description" : "Only for FIFO queues. Strategy for setting the messageGroupId on the message. Can be one of the following options: useConstant, useExchangeId, usePropertyValue. For the usePropertyValue option, the value of property CamelAwsMessageGroupId will be used.",
          "enum" : [ "useConstant", "useExchangeId", "usePropertyValue" ],
          "type" : "string"
        },
        "message-retention-period" : {
          "description" : "The messageRetentionPeriod (in seconds) a message will be retained by SQS for this queue.",
          "type" : "integer"
        },
        "operation" : {
          "description" : "The operation to do in case the user don't want to send only a message",
          "enum" : [ "sendBatchMessage", "deleteMessage", "listQueues" ],
          "type" : "string"
        },
        "policy" : {
          "description" : "The policy for this queue",
          "type" : "string"
        },
        "poll-strategy" : {
          "description" : "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
          "type" : "string"
        },
        "protocol" : {
          "description" : "The underlying protocol used to communicate with SQS",
          "default" : "https",
          "type" : "string"
        },
        "proxy-host" : {
          "description" : "To define a proxy host when instantiating the SQS client",
          "type" : "string"
        },
        "proxy-port" : {
          "description" : "To define a proxy port when instantiating the SQS client",
          "type" : "integer"
        },
        "proxy-protocol" : {
          "description" : "To define a proxy protocol when instantiating the SQS client",
          "default" : "HTTPS",
          "enum" : [ "HTTP", "HTTPS" ],
          "type" : "string"
        },
        "queue-owner-aws-account-id" : {
          "description" : "Specify the queue owner aws account id when you need to connect the queue with different account owner.",
          "type" : "string"
        },
        "queue-url" : {
          "description" : "To define the queueUrl explicitly. All other parameters, which would influence the queueUrl, are ignored. This parameter is intended to be used, to connect to a mock implementation of SQS, for testing purposes.",
          "type" : "string"
        },
        "receive-message-wait-time-seconds" : {
          "description" : "If you do not specify WaitTimeSeconds in the request, the queue attribute ReceiveMessageWaitTimeSeconds is used to determine how long to wait.",
          "type" : "integer"
        },
        "redrive-policy" : {
          "description" : "Specify the policy that send message to DeadLetter queue. See detail at Amazon docs.",
          "type" : "string"
        },
        "region" : {
          "description" : "Specify the queue region which could be used with queueOwnerAWSAccountId to build the service URL. When using this parameter, the configuration will expect the capitalized name of the region (for example AP_EAST_1) You'll need to use the name Regions.EU_WEST_1.name()",
          "type" : "string"
        },
        "repeat-count" : {
          "description" : "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
          "default" : "0",
          "type" : "integer"
        },
        "run-logging-level" : {
          "description" : "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
          "default" : "TRACE",
          "enum" : [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ],
          "type" : "string"
        },
        "scheduled-executor-service" : {
          "description" : "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
          "type" : "string"
        },
        "scheduler" : {
          "description" : "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
          "default" : "none",
          "type" : "string"
        },
        "scheduler-properties" : {
          "description" : "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
          "type" : "string"
        },
        "secret-key" : {
          "description" : "Amazon AWS Secret Key",
          "type" : "string"
        },
        "send-empty-message-when-idle" : {
          "description" : "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
          "default" : "false",
          "type" : "boolean"
        },
        "server-side-encryption-enabled" : {
          "description" : "Define if Server Side Encryption is enabled or not on the queue",
          "default" : "false",
          "type" : "boolean"
        },
        "start-scheduler" : {
          "description" : "Whether the scheduler should be auto started.",
          "default" : "true",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "time-unit" : {
          "description" : "Time unit for initialDelay and delay options.",
          "default" : "MILLISECONDS",
          "enum" : [ "NANOSECONDS", "MICROSECONDS", "MILLISECONDS", "SECONDS", "MINUTES", "HOURS", "DAYS" ],
          "type" : "string"
        },
        "use-fixed-delay" : {
          "description" : "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
          "default" : "true",
          "type" : "boolean"
        },
        "visibility-timeout" : {
          "description" : "The duration (in seconds) that the received messages are hidden from subsequent retrieve requests after being retrieved by a ReceiveMessage request to set in the com.amazonaws.services.sqs.model.SetQueueAttributesRequest. This only make sense if its different from defaultVisibilityTimeout. It changes the queue visibility timeout attribute permanently.",
          "type" : "integer"
        },
        "wait-time-seconds" : {
          "description" : "Duration in seconds (0 to 20) that the ReceiveMessage action call will wait until a message is in the queue to include in the response.",
          "type" : "integer"
        }
      }
    },
    "aws-swf" : {
      "type" : "object",
      "required" : [ "type" ],
      "properties" : {
        "type" : {
          "description" : "Activity or workflow",
          "enum" : [ "activity", "workflow" ],
          "type" : "string"
        },
        "access-key" : {
          "description" : "Amazon AWS Access Key.",
          "type" : "string"
        },
        "activity-list" : {
          "description" : "The list name to consume activities from.",
          "type" : "string"
        },
        "activity-scheduling-options" : {
          "description" : "Activity scheduling options",
          "type" : "string"
        },
        "activity-thread-pool-size" : {
          "description" : "Maximum number of threads in work pool for activity.",
          "default" : "100",
          "type" : "integer"
        },
        "activity-type-execution-options" : {
          "description" : "Activity execution options",
          "type" : "string"
        },
        "activity-type-registration-options" : {
          "description" : "Activity registration options",
          "type" : "string"
        },
        "amazon-sw-client" : {
          "description" : "To use the given AmazonSimpleWorkflowClient as client",
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "child-policy" : {
          "description" : "The policy to use on child workflows when terminating a workflow.",
          "type" : "string"
        },
        "client-configuration-parameters" : {
          "description" : "To configure the ClientConfiguration using the key/values from the Map.",
          "type" : "string"
        },
        "data-converter" : {
          "description" : "An instance of com.amazonaws.services.simpleworkflow.flow.DataConverter to use for serializing/deserializing the data.",
          "type" : "string"
        },
        "domain-name" : {
          "description" : "The workflow domain to use.",
          "type" : "string"
        },
        "event-name" : {
          "description" : "The workflow or activity event name to use.",
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "execution-start-to-close-timeout" : {
          "description" : "Set the execution start to close timeout.",
          "default" : "3600",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "operation" : {
          "description" : "Workflow operation",
          "default" : "START",
          "enum" : [ "SIGNAL", "CANCEL", "TERMINATE", "GET_STATE", "START", "DESCRIBE", "GET_HISTORY" ],
          "type" : "string"
        },
        "region" : {
          "description" : "Amazon AWS Region. When using this parameter, the configuration will expect the capitalized name of the region (for example AP_EAST_1) You'll need to use the name Regions.EU_WEST_1.name()",
          "type" : "string"
        },
        "s-w-client-parameters" : {
          "description" : "To configure the AmazonSimpleWorkflowClient using the key/values from the Map.",
          "type" : "string"
        },
        "secret-key" : {
          "description" : "Amazon AWS Secret Key.",
          "type" : "string"
        },
        "signal-name" : {
          "description" : "The name of the signal to send to the workflow.",
          "type" : "string"
        },
        "start-workflow-options-parameters" : {
          "description" : "To configure the StartWorkflowOptions using the key/values from the Map.",
          "type" : "string"
        },
        "state-result-type" : {
          "description" : "The type of the result when a workflow state is queried.",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "task-start-to-close-timeout" : {
          "description" : "Set the task start to close timeout.",
          "default" : "600",
          "type" : "string"
        },
        "termination-details" : {
          "description" : "Details for terminating a workflow.",
          "type" : "string"
        },
        "termination-reason" : {
          "description" : "The reason for terminating a workflow.",
          "type" : "string"
        },
        "version" : {
          "description" : "The workflow or activity event version to use.",
          "type" : "string"
        },
        "workflow-list" : {
          "description" : "The list name to consume workflows from.",
          "type" : "string"
        },
        "workflow-type-registration-options" : {
          "description" : "Workflow registration options",
          "type" : "string"
        }
      }
    },
    "aws-translate" : {
      "type" : "object",
      "required" : [ "label", "operation" ],
      "properties" : {
        "label" : {
          "description" : "Logical name",
          "type" : "string"
        },
        "access-key" : {
          "description" : "Amazon AWS Access Key",
          "type" : "string"
        },
        "auto-discover-client" : {
          "description" : "Setting the autoDiscoverClient mechanism, if true, the component will look for a client instance in the registry automatically otherwise it will skip that checking.",
          "default" : "true",
          "type" : "boolean"
        },
        "autodetect-source-language" : {
          "description" : "Being able to autodetect the source language",
          "default" : "false",
          "type" : "boolean"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "operation" : {
          "description" : "The operation to perform",
          "default" : "translateText",
          "enum" : [ "translateText" ],
          "type" : "string"
        },
        "proxy-host" : {
          "description" : "To define a proxy host when instantiating the Translate client",
          "type" : "string"
        },
        "proxy-port" : {
          "description" : "To define a proxy port when instantiating the Translate client",
          "type" : "integer"
        },
        "proxy-protocol" : {
          "description" : "To define a proxy protocol when instantiating the Translate client",
          "default" : "HTTPS",
          "enum" : [ "HTTP", "HTTPS" ],
          "type" : "string"
        },
        "region" : {
          "description" : "The region in which Translate client needs to work. When using this parameter, the configuration will expect the capitalized name of the region (for example AP_EAST_1) You'll need to use the name Regions.EU_WEST_1.name()",
          "type" : "string"
        },
        "secret-key" : {
          "description" : "Amazon AWS Secret Key",
          "type" : "string"
        },
        "source-language" : {
          "description" : "Source language to use",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "target-language" : {
          "description" : "Target language to use",
          "type" : "string"
        },
        "translate-client" : {
          "description" : "To use a existing configured AWS Translate as client",
          "type" : "string"
        }
      }
    },
    "aws2-athena" : {
      "type" : "object",
      "required" : [ "label" ],
      "properties" : {
        "label" : {
          "description" : "Logical name",
          "type" : "string"
        },
        "access-key" : {
          "description" : "Amazon AWS Access Key.",
          "type" : "string"
        },
        "amazon-athena-client" : {
          "description" : "The AmazonAthena instance to use as the client.",
          "type" : "string"
        },
        "client-request-token" : {
          "description" : "A unique string to ensure issues queries are idempotent. It is unlikely you will need to set this.",
          "type" : "string"
        },
        "database" : {
          "description" : "The Athena database to use.",
          "type" : "string"
        },
        "delay" : {
          "description" : "Milliseconds before the next poll for query execution status. See the section 'Waiting for Query Completion and Retrying Failed Queries' to learn more.",
          "default" : "2000",
          "type" : "integer"
        },
        "encryption-option" : {
          "description" : "The encryption type to use when storing query results in S3. One of SSE_S3, SSE_KMS, or CSE_KMS.",
          "enum" : [ "SSE_S3", "SSE_KMS", "CSE_KMS", "null" ],
          "type" : "string"
        },
        "include-trace" : {
          "description" : "Include useful trace information at the beginning of queries as an SQL comment (prefixed with --).",
          "default" : "false",
          "type" : "boolean"
        },
        "initial-delay" : {
          "description" : "Milliseconds before the first poll for query execution status. See the section 'Waiting for Query Completion and Retrying Failed Queries' to learn more.",
          "default" : "1000",
          "type" : "integer"
        },
        "kms-key" : {
          "description" : "For SSE-KMS and CSE-KMS, this is the KMS key ARN or ID.",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "max-attempts" : {
          "description" : "Maximum number of times to attempt a query. Set to 1 to disable retries. See the section 'Waiting for Query Completion and Retrying Failed Queries' to learn more.",
          "default" : "1",
          "type" : "integer"
        },
        "max-results" : {
          "description" : "Max number of results to return for the given operation (if supported by the Athena API endpoint). If not set, will use the Athena API default for the given operation.",
          "type" : "integer"
        },
        "next-token" : {
          "description" : "Pagination token to use in the case where the response from the previous request was truncated.",
          "type" : "string"
        },
        "operation" : {
          "description" : "The Athena API function to call.",
          "default" : "startQueryExecution",
          "enum" : [ "getQueryExecution", "getQueryResults", "listQueryExecutions", "startQueryExecution" ],
          "type" : "string"
        },
        "output-location" : {
          "description" : "The location in Amazon S3 where query results are stored, such as s3://path/to/query/bucket/. Ensure this value ends with a forward slash ('/').",
          "type" : "string"
        },
        "output-type" : {
          "description" : "How query results should be returned. One of StreamList (default - return a GetQueryResultsIterable that can page through all results), SelectList (returns at most 1,000 rows at a time, plus a NextToken value as a header than can be used for manual pagination of results), S3Pointer (return an S3 path pointing to the results).",
          "default" : "StreamList",
          "enum" : [ "StreamList", "SelectList", "S3Pointer" ],
          "type" : "string"
        },
        "proxy-host" : {
          "description" : "To define a proxy host when instantiating the Athena client.",
          "type" : "string"
        },
        "proxy-port" : {
          "description" : "To define a proxy port when instantiating the Athena client.",
          "type" : "integer"
        },
        "proxy-protocol" : {
          "description" : "To define a proxy protocol when instantiating the Athena client.",
          "default" : "HTTPS",
          "enum" : [ "HTTP", "HTTPS" ],
          "type" : "string"
        },
        "query-execution-id" : {
          "description" : "The unique ID identifying the query execution.",
          "type" : "string"
        },
        "query-string" : {
          "description" : "The SQL query to run. Except for simple queries, prefer setting this as the body of the Exchange or as a header using Athena2Constants.QUERY_STRING to avoid having to deal with URL encoding issues.",
          "type" : "string"
        },
        "region" : {
          "description" : "The region in which Athena client needs to work. When using this parameter, the configuration will expect the lowercase name of the region (for example ap-east-1). You'll need to use the name Region.EU_WEST_1.id().",
          "type" : "string"
        },
        "reset-wait-timeout-on-retry" : {
          "description" : "Reset the waitTimeout countdown in the event of a query retry. If set to true, potential max time spent waiting for queries is equal to waitTimeout x maxAttempts. See the section 'Waiting for Query Completion and Retrying Failed Queries' to learn more.",
          "default" : "true",
          "type" : "boolean"
        },
        "retry" : {
          "description" : "Optional comma separated list of error types to retry the query for. Use 'retryable' to retry all retryable failure conditions (e.g. generic errors and resources exhausted), 'generic' to retry 'GENERIC_INTERNAL_ERROR' failures, 'exhausted' to retry queries that have exhausted resource limits, 'always' to always retry regardless of failure condition, or 'never' or null to never retry (default). See the section 'Waiting for Query Completion and Retrying Failed Queries' to learn more.",
          "default" : "never",
          "enum" : [ "never", "always", "retryable", "exhausted", "generic" ],
          "type" : "string"
        },
        "secret-key" : {
          "description" : "Amazon AWS Secret Key.",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "wait-timeout" : {
          "description" : "Optional max wait time in millis to wait for a successful query completion. See the section 'Waiting for Query Completion and Retrying Failed Queries' to learn more.",
          "default" : "0",
          "type" : "integer"
        },
        "work-group" : {
          "description" : "The workgroup to use for running the query.",
          "type" : "string"
        }
      }
    },
    "aws2-cw" : {
      "type" : "object",
      "required" : [ "namespace" ],
      "properties" : {
        "namespace" : {
          "description" : "The metric namespace",
          "type" : "string"
        },
        "access-key" : {
          "description" : "Amazon AWS Access Key",
          "type" : "string"
        },
        "amazon-cw-client" : {
          "description" : "To use the AmazonCloudWatch as the client",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "name" : {
          "description" : "The metric name",
          "type" : "string"
        },
        "proxy-host" : {
          "description" : "To define a proxy host when instantiating the CW client",
          "type" : "string"
        },
        "proxy-port" : {
          "description" : "To define a proxy port when instantiating the CW client",
          "type" : "integer"
        },
        "proxy-protocol" : {
          "description" : "To define a proxy protocol when instantiating the CW client",
          "default" : "HTTPS",
          "enum" : [ "HTTP", "HTTPS" ],
          "type" : "string"
        },
        "region" : {
          "description" : "The region in which EKS client needs to work. When using this parameter, the configuration will expect the lowercase name of the region (for example ap-east-1) You'll need to use the name Region.EU_WEST_1.id()",
          "type" : "string"
        },
        "secret-key" : {
          "description" : "Amazon AWS Secret Key",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "timestamp" : {
          "description" : "The metric timestamp",
          "type" : "string"
        },
        "trust-all-certificates" : {
          "description" : "If we want to trust all certificates in case of overriding the endpoint",
          "default" : "false",
          "type" : "boolean"
        },
        "unit" : {
          "description" : "The metric unit",
          "type" : "string"
        },
        "value" : {
          "description" : "The metric value",
          "type" : "number"
        }
      }
    },
    "aws2-ddb" : {
      "type" : "object",
      "required" : [ "tableName" ],
      "properties" : {
        "table-name" : {
          "description" : "The name of the table currently worked with.",
          "type" : "string"
        },
        "access-key" : {
          "description" : "Amazon AWS Access Key",
          "type" : "string"
        },
        "amazon-ddb-client" : {
          "description" : "To use the AmazonDynamoDB as the client",
          "type" : "string"
        },
        "consistent-read" : {
          "description" : "Determines whether or not strong consistency should be enforced when data is read.",
          "default" : "false",
          "type" : "boolean"
        },
        "key-attribute-name" : {
          "description" : "Attribute name when creating table",
          "type" : "string"
        },
        "key-attribute-type" : {
          "description" : "Attribute type when creating table",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "operation" : {
          "description" : "What operation to perform",
          "default" : "PutItem",
          "enum" : [ "BatchGetItems", "DeleteItem", "DeleteTable", "DescribeTable", "GetItem", "PutItem", "Query", "Scan", "UpdateItem", "UpdateTable" ],
          "type" : "string"
        },
        "proxy-host" : {
          "description" : "To define a proxy host when instantiating the DDB client",
          "type" : "string"
        },
        "proxy-port" : {
          "description" : "The region in which DynamoDB client needs to work. When using this parameter, the configuration will expect the lowercase name of the region (for example ap-east-1) You'll need to use the name Region.EU_WEST_1.id()",
          "type" : "integer"
        },
        "proxy-protocol" : {
          "description" : "To define a proxy protocol when instantiating the DDB client",
          "default" : "HTTPS",
          "enum" : [ "HTTP", "HTTPS" ],
          "type" : "string"
        },
        "read-capacity" : {
          "description" : "The provisioned throughput to reserve for reading resources from your table",
          "type" : "integer"
        },
        "region" : {
          "description" : "The region in which DDB client needs to work",
          "type" : "string"
        },
        "secret-key" : {
          "description" : "Amazon AWS Secret Key",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "trust-all-certificates" : {
          "description" : "If we want to trust all certificates in case of overriding the endpoint",
          "default" : "false",
          "type" : "boolean"
        },
        "write-capacity" : {
          "description" : "The provisioned throughput to reserved for writing resources to your table",
          "type" : "integer"
        }
      }
    },
    "aws2-ddbstream" : {
      "type" : "object",
      "required" : [ "tableName" ],
      "properties" : {
        "table-name" : {
          "description" : "Name of the dynamodb table",
          "type" : "string"
        },
        "access-key" : {
          "description" : "Amazon AWS Access Key",
          "type" : "string"
        },
        "amazon-dynamo-db-streams-client" : {
          "description" : "Amazon DynamoDB client to use for all requests for this endpoint",
          "type" : "string"
        },
        "backoff-error-threshold" : {
          "description" : "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-idle-threshold" : {
          "description" : "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-multiplier" : {
          "description" : "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
          "type" : "integer"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "delay" : {
          "description" : "Milliseconds before the next poll.",
          "default" : "500",
          "type" : "integer"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "greedy" : {
          "description" : "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
          "default" : "false",
          "type" : "boolean"
        },
        "initial-delay" : {
          "description" : "Milliseconds before the first poll starts.",
          "default" : "1000",
          "type" : "integer"
        },
        "iterator-type" : {
          "description" : "Defines where in the DynaboDB stream to start getting records. Note that using TRIM_HORIZON can cause a significant delay before the stream has caught up to real-time. if {AT,AFTER}_SEQUENCE_NUMBER are used, then a sequenceNumberProvider MUST be supplied.",
          "default" : "LATEST",
          "enum" : [ "TRIM_HORIZON", "LATEST", "AT_SEQUENCE_NUMBER", "AFTER_SEQUENCE_NUMBER", "null" ],
          "type" : "string"
        },
        "max-results-per-request" : {
          "description" : "Maximum number of records that will be fetched in each poll",
          "type" : "integer"
        },
        "poll-strategy" : {
          "description" : "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
          "type" : "string"
        },
        "proxy-host" : {
          "description" : "To define a proxy host when instantiating the DDBStreams client",
          "type" : "string"
        },
        "proxy-port" : {
          "description" : "To define a proxy port when instantiating the DDBStreams client",
          "type" : "integer"
        },
        "proxy-protocol" : {
          "description" : "To define a proxy protocol when instantiating the DDBStreams client",
          "default" : "HTTPS",
          "enum" : [ "HTTP", "HTTPS" ],
          "type" : "string"
        },
        "region" : {
          "description" : "The region in which DDBStreams client needs to work",
          "type" : "string"
        },
        "repeat-count" : {
          "description" : "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
          "default" : "0",
          "type" : "integer"
        },
        "run-logging-level" : {
          "description" : "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
          "default" : "TRACE",
          "enum" : [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ],
          "type" : "string"
        },
        "scheduled-executor-service" : {
          "description" : "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
          "type" : "string"
        },
        "scheduler" : {
          "description" : "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
          "default" : "none",
          "type" : "string"
        },
        "scheduler-properties" : {
          "description" : "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
          "type" : "string"
        },
        "secret-key" : {
          "description" : "Amazon AWS Secret Key",
          "type" : "string"
        },
        "send-empty-message-when-idle" : {
          "description" : "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
          "default" : "false",
          "type" : "boolean"
        },
        "sequence-number-provider" : {
          "description" : "Provider for the sequence number when using one of the two ShardIteratorType.{AT,AFTER}_SEQUENCE_NUMBER iterator types. Can be a registry reference or a literal sequence number.",
          "type" : "string"
        },
        "start-scheduler" : {
          "description" : "Whether the scheduler should be auto started.",
          "default" : "true",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "time-unit" : {
          "description" : "Time unit for initialDelay and delay options.",
          "default" : "MILLISECONDS",
          "enum" : [ "NANOSECONDS", "MICROSECONDS", "MILLISECONDS", "SECONDS", "MINUTES", "HOURS", "DAYS" ],
          "type" : "string"
        },
        "trust-all-certificates" : {
          "description" : "If we want to trust all certificates in case of overriding the endpoint",
          "default" : "false",
          "type" : "boolean"
        },
        "use-fixed-delay" : {
          "description" : "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
          "default" : "true",
          "type" : "boolean"
        }
      }
    },
    "aws2-ec2" : {
      "type" : "object",
      "required" : [ "label", "operation" ],
      "properties" : {
        "label" : {
          "description" : "Logical name",
          "type" : "string"
        },
        "access-key" : {
          "description" : "Amazon AWS Access Key",
          "type" : "string"
        },
        "amazon-ec2-client" : {
          "description" : "To use a existing configured AmazonEC2Client as client",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "operation" : {
          "description" : "The operation to perform. It can be createAndRunInstances, startInstances, stopInstances, terminateInstances, describeInstances, describeInstancesStatus, rebootInstances, monitorInstances, unmonitorInstances, createTags or deleteTags",
          "enum" : [ "createAndRunInstances", "startInstances", "stopInstances", "terminateInstances", "describeInstances", "describeInstancesStatus", "rebootInstances", "monitorInstances", "unmonitorInstances", "createTags", "deleteTags" ],
          "type" : "string"
        },
        "pojo-request" : {
          "description" : "If we want to use a POJO request as body or not",
          "default" : "false",
          "type" : "boolean"
        },
        "proxy-host" : {
          "description" : "To define a proxy host when instantiating the EC2 client",
          "type" : "string"
        },
        "proxy-port" : {
          "description" : "To define a proxy port when instantiating the EC2 client",
          "type" : "integer"
        },
        "proxy-protocol" : {
          "description" : "To define a proxy protocol when instantiating the EC2 client",
          "default" : "HTTPS",
          "enum" : [ "HTTP", "HTTPS" ],
          "type" : "string"
        },
        "region" : {
          "description" : "The region in which EC2 client needs to work. When using this parameter, the configuration will expect the lowercase name of the region (for example ap-east-1) You'll need to use the name Region.EU_WEST_1.id()",
          "type" : "string"
        },
        "secret-key" : {
          "description" : "Amazon AWS Secret Key",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "trust-all-certificates" : {
          "description" : "If we want to trust all certificates in case of overriding the endpoint",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "aws2-ecs" : {
      "type" : "object",
      "required" : [ "label", "operation" ],
      "properties" : {
        "label" : {
          "description" : "Logical name",
          "type" : "string"
        },
        "access-key" : {
          "description" : "Amazon AWS Access Key",
          "type" : "string"
        },
        "ecs-client" : {
          "description" : "To use a existing configured AWS ECS as client",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "operation" : {
          "description" : "The operation to perform",
          "enum" : [ "listClusters", "describeCluster", "createCluster", "deleteCluster" ],
          "type" : "string"
        },
        "pojo-request" : {
          "description" : "If we want to use a POJO request as body or not",
          "default" : "false",
          "type" : "boolean"
        },
        "proxy-host" : {
          "description" : "To define a proxy host when instantiating the ECS client",
          "type" : "string"
        },
        "proxy-port" : {
          "description" : "To define a proxy port when instantiating the ECS client",
          "type" : "integer"
        },
        "proxy-protocol" : {
          "description" : "To define a proxy protocol when instantiating the ECS client",
          "default" : "HTTPS",
          "enum" : [ "HTTP", "HTTPS" ],
          "type" : "string"
        },
        "region" : {
          "description" : "The region in which ECS client needs to work. When using this parameter, the configuration will expect the lowercase name of the region (for example ap-east-1) You'll need to use the name Region.EU_WEST_1.id()",
          "type" : "string"
        },
        "secret-key" : {
          "description" : "Amazon AWS Secret Key",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "trust-all-certificates" : {
          "description" : "If we want to trust all certificates in case of overriding the endpoint",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "aws2-eks" : {
      "type" : "object",
      "required" : [ "label", "operation" ],
      "properties" : {
        "label" : {
          "description" : "Logical name",
          "type" : "string"
        },
        "access-key" : {
          "description" : "Amazon AWS Access Key",
          "type" : "string"
        },
        "eks-client" : {
          "description" : "To use a existing configured AWS EKS as client",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "operation" : {
          "description" : "The operation to perform",
          "enum" : [ "listClusters", "describeCluster", "createCluster", "deleteCluster" ],
          "type" : "string"
        },
        "pojo-request" : {
          "description" : "If we want to use a POJO request as body or not",
          "default" : "false",
          "type" : "boolean"
        },
        "proxy-host" : {
          "description" : "To define a proxy host when instantiating the EKS client",
          "type" : "string"
        },
        "proxy-port" : {
          "description" : "To define a proxy port when instantiating the EKS client",
          "type" : "integer"
        },
        "proxy-protocol" : {
          "description" : "To define a proxy protocol when instantiating the EKS client",
          "default" : "HTTPS",
          "enum" : [ "HTTP", "HTTPS" ],
          "type" : "string"
        },
        "region" : {
          "description" : "The region in which EKS client needs to work. When using this parameter, the configuration will expect the lowercase name of the region (for example ap-east-1) You'll need to use the name Region.EU_WEST_1.id()",
          "type" : "string"
        },
        "secret-key" : {
          "description" : "Amazon AWS Secret Key",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "trust-all-certificates" : {
          "description" : "If we want to trust all certificates in case of overriding the endpoint",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "aws2-eventbridge" : {
      "type" : "object",
      "required" : [ "eventbusNameOrArn", "operation" ],
      "properties" : {
        "eventbus-name-or-arn" : {
          "description" : "Event bus name or ARN",
          "type" : "string"
        },
        "access-key" : {
          "description" : "Amazon AWS Access Key",
          "type" : "string"
        },
        "event-pattern-file" : {
          "description" : "EventPattern File",
          "type" : "string"
        },
        "eventbridge-client" : {
          "description" : "To use a existing configured AWS Eventbridge as client",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "operation" : {
          "description" : "The operation to perform",
          "default" : "putRule",
          "enum" : [ "putRule", "putTargets", "removeTargets", "deleteRule", "enableRule", "disableRule", "describeRule", "listRules", "listTargetsByRule", "listRuleNamesByTarget" ],
          "type" : "string"
        },
        "pojo-request" : {
          "description" : "If we want to use a POJO request as body or not",
          "default" : "false",
          "type" : "boolean"
        },
        "proxy-host" : {
          "description" : "To define a proxy host when instantiating the Eventbridge client",
          "type" : "string"
        },
        "proxy-port" : {
          "description" : "To define a proxy port when instantiating the Eventbridge client",
          "type" : "integer"
        },
        "proxy-protocol" : {
          "description" : "To define a proxy protocol when instantiating the Eventbridge client",
          "default" : "HTTPS",
          "enum" : [ "HTTP", "HTTPS" ],
          "type" : "string"
        },
        "region" : {
          "description" : "The region in which Eventbridge client needs to work. When using this parameter, the configuration will expect the lowercase name of the region (for example ap-east-1) You'll need to use the name Region.EU_WEST_1.id()",
          "type" : "string"
        },
        "secret-key" : {
          "description" : "Amazon AWS Secret Key",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "trust-all-certificates" : {
          "description" : "If we want to trust all certificates in case of overriding the endpoint",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "aws2-iam" : {
      "type" : "object",
      "required" : [ "label", "operation" ],
      "properties" : {
        "label" : {
          "description" : "Logical name",
          "type" : "string"
        },
        "access-key" : {
          "description" : "Amazon AWS Access Key",
          "type" : "string"
        },
        "iam-client" : {
          "description" : "To use a existing configured AWS IAM as client",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "operation" : {
          "description" : "The operation to perform",
          "enum" : [ "listAccessKeys", "createUser", "deleteUser", "getUser", "listUsers", "createAccessKey", "deleteAccessKey", "updateAccessKey", "createGroup", "deleteGroup", "listGroups", "addUserToGroup", "removeUserFromGroup" ],
          "type" : "string"
        },
        "pojo-request" : {
          "description" : "If we want to use a POJO request as body or not",
          "default" : "false",
          "type" : "boolean"
        },
        "proxy-host" : {
          "description" : "To define a proxy host when instantiating the IAM client",
          "type" : "string"
        },
        "proxy-port" : {
          "description" : "To define a proxy port when instantiating the IAM client",
          "type" : "integer"
        },
        "proxy-protocol" : {
          "description" : "To define a proxy protocol when instantiating the IAM client",
          "default" : "HTTPS",
          "enum" : [ "HTTP", "HTTPS" ],
          "type" : "string"
        },
        "region" : {
          "description" : "The region in which IAM client needs to work. When using this parameter, the configuration will expect the lowercase name of the region (for example ap-east-1) You'll need to use the name Region.EU_WEST_1.id()",
          "default" : "aws-global",
          "type" : "string"
        },
        "secret-key" : {
          "description" : "Amazon AWS Secret Key",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "trust-all-certificates" : {
          "description" : "If we want to trust all certificates in case of overriding the endpoint",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "aws2-kinesis" : {
      "type" : "object",
      "required" : [ "streamName" ],
      "properties" : {
        "stream-name" : {
          "description" : "Name of the stream",
          "type" : "string"
        },
        "access-key" : {
          "description" : "Amazon AWS Access Key",
          "type" : "string"
        },
        "amazon-kinesis-client" : {
          "description" : "Amazon Kinesis client to use for all requests for this endpoint",
          "type" : "string"
        },
        "backoff-error-threshold" : {
          "description" : "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-idle-threshold" : {
          "description" : "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-multiplier" : {
          "description" : "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
          "type" : "integer"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "cbor-enabled" : {
          "description" : "This option will set the CBOR_ENABLED property during the execution",
          "default" : "true",
          "type" : "boolean"
        },
        "delay" : {
          "description" : "Milliseconds before the next poll.",
          "default" : "500",
          "type" : "integer"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "greedy" : {
          "description" : "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
          "default" : "false",
          "type" : "boolean"
        },
        "initial-delay" : {
          "description" : "Milliseconds before the first poll starts.",
          "default" : "1000",
          "type" : "integer"
        },
        "iterator-type" : {
          "description" : "Defines where in the Kinesis stream to start getting records",
          "default" : "TRIM_HORIZON",
          "enum" : [ "AT_SEQUENCE_NUMBER", "AFTER_SEQUENCE_NUMBER", "TRIM_HORIZON", "LATEST", "AT_TIMESTAMP", "null" ],
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "max-results-per-request" : {
          "description" : "Maximum number of records that will be fetched in each poll",
          "default" : "1",
          "type" : "integer"
        },
        "poll-strategy" : {
          "description" : "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
          "type" : "string"
        },
        "proxy-host" : {
          "description" : "To define a proxy host when instantiating the Kinesis client",
          "type" : "string"
        },
        "proxy-port" : {
          "description" : "To define a proxy port when instantiating the Kinesis client",
          "type" : "integer"
        },
        "proxy-protocol" : {
          "description" : "To define a proxy protocol when instantiating the Kinesis client",
          "default" : "HTTPS",
          "enum" : [ "HTTP", "HTTPS" ],
          "type" : "string"
        },
        "region" : {
          "description" : "The region in which Kinesis Firehose client needs to work. When using this parameter, the configuration will expect the lowercase name of the region (for example ap-east-1) You'll need to use the name Region.EU_WEST_1.id()",
          "type" : "string"
        },
        "repeat-count" : {
          "description" : "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
          "default" : "0",
          "type" : "integer"
        },
        "run-logging-level" : {
          "description" : "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
          "default" : "TRACE",
          "enum" : [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ],
          "type" : "string"
        },
        "scheduled-executor-service" : {
          "description" : "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
          "type" : "string"
        },
        "scheduler" : {
          "description" : "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
          "default" : "none",
          "type" : "string"
        },
        "scheduler-properties" : {
          "description" : "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
          "type" : "string"
        },
        "secret-key" : {
          "description" : "Amazon AWS Secret Key",
          "type" : "string"
        },
        "send-empty-message-when-idle" : {
          "description" : "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
          "default" : "false",
          "type" : "boolean"
        },
        "sequence-number" : {
          "description" : "The sequence number to start polling from. Required if iteratorType is set to AFTER_SEQUENCE_NUMBER or AT_SEQUENCE_NUMBER",
          "type" : "string"
        },
        "shard-closed" : {
          "description" : "Define what will be the behavior in case of shard closed. Possible value are ignore, silent and fail. In case of ignore a message will be logged and the consumer will restart from the beginning,in case of silent there will be no logging and the consumer will start from the beginning,in case of fail a ReachedClosedStateException will be raised",
          "default" : "ignore",
          "enum" : [ "ignore", "fail", "silent" ],
          "type" : "string"
        },
        "shard-id" : {
          "description" : "Defines which shardId in the Kinesis stream to get records from",
          "type" : "string"
        },
        "start-scheduler" : {
          "description" : "Whether the scheduler should be auto started.",
          "default" : "true",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "time-unit" : {
          "description" : "Time unit for initialDelay and delay options.",
          "default" : "MILLISECONDS",
          "enum" : [ "NANOSECONDS", "MICROSECONDS", "MILLISECONDS", "SECONDS", "MINUTES", "HOURS", "DAYS" ],
          "type" : "string"
        },
        "trust-all-certificates" : {
          "description" : "If we want to trust all certificates in case of overriding the endpoint",
          "default" : "false",
          "type" : "boolean"
        },
        "use-fixed-delay" : {
          "description" : "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
          "default" : "true",
          "type" : "boolean"
        }
      }
    },
    "aws2-kinesis-firehose" : {
      "type" : "object",
      "required" : [ "streamName" ],
      "properties" : {
        "stream-name" : {
          "description" : "Name of the stream",
          "type" : "string"
        },
        "access-key" : {
          "description" : "Amazon AWS Access Key",
          "type" : "string"
        },
        "amazon-kinesis-firehose-client" : {
          "description" : "Amazon Kinesis Firehose client to use for all requests for this endpoint",
          "type" : "string"
        },
        "cbor-enabled" : {
          "description" : "This option will set the CBOR_ENABLED property during the execution",
          "default" : "true",
          "type" : "boolean"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "operation" : {
          "description" : "The operation to do in case the user don't want to send only a record",
          "enum" : [ "sendBatchRecord", "createDeliveryStream", "deleteDeliveryStream", "describeDeliveryStream", "updateDestination" ],
          "type" : "string"
        },
        "proxy-host" : {
          "description" : "To define a proxy host when instantiating the Kinesis Firehose client",
          "type" : "string"
        },
        "proxy-port" : {
          "description" : "To define a proxy port when instantiating the Kinesis Firehose client",
          "type" : "integer"
        },
        "proxy-protocol" : {
          "description" : "To define a proxy protocol when instantiating the Kinesis Firehose client",
          "default" : "HTTPS",
          "enum" : [ "HTTP", "HTTPS" ],
          "type" : "string"
        },
        "region" : {
          "description" : "The region in which Kinesis Firehose client needs to work. When using this parameter, the configuration will expect the lowercase name of the region (for example ap-east-1) You'll need to use the name Region.EU_WEST_1.id()",
          "type" : "string"
        },
        "secret-key" : {
          "description" : "Amazon AWS Secret Key",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "trust-all-certificates" : {
          "description" : "If we want to trust all certificates in case of overriding the endpoint",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "aws2-kms" : {
      "type" : "object",
      "required" : [ "label", "operation" ],
      "properties" : {
        "label" : {
          "description" : "Logical name",
          "type" : "string"
        },
        "access-key" : {
          "description" : "Amazon AWS Access Key",
          "type" : "string"
        },
        "kms-client" : {
          "description" : "To use a existing configured AWS KMS as client",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "operation" : {
          "description" : "The operation to perform",
          "enum" : [ "listKeys", "createKey", "disableKey", "scheduleKeyDeletion", "describeKey", "enableKey" ],
          "type" : "string"
        },
        "pojo-request" : {
          "description" : "If we want to use a POJO request as body or not",
          "default" : "false",
          "type" : "boolean"
        },
        "proxy-host" : {
          "description" : "To define a proxy host when instantiating the KMS client",
          "type" : "string"
        },
        "proxy-port" : {
          "description" : "To define a proxy port when instantiating the KMS client",
          "type" : "integer"
        },
        "proxy-protocol" : {
          "description" : "To define a proxy protocol when instantiating the KMS client",
          "default" : "HTTPS",
          "enum" : [ "HTTP", "HTTPS" ],
          "type" : "string"
        },
        "region" : {
          "description" : "The region in which EKS client needs to work. When using this parameter, the configuration will expect the lowercase name of the region (for example ap-east-1) You'll need to use the name Region.EU_WEST_1.id()",
          "type" : "string"
        },
        "secret-key" : {
          "description" : "Amazon AWS Secret Key",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "trust-all-certificates" : {
          "description" : "If we want to trust all certificates in case of overriding the endpoint",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "aws2-lambda" : {
      "type" : "object",
      "required" : [ "function" ],
      "properties" : {
        "function" : {
          "description" : "Name of the Lambda function.",
          "type" : "string"
        },
        "access-key" : {
          "description" : "Amazon AWS Access Key",
          "type" : "string"
        },
        "aws-lambda-client" : {
          "description" : "To use a existing configured AwsLambdaClient as client",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "operation" : {
          "description" : "The operation to perform. It can be listFunctions, getFunction, createFunction, deleteFunction or invokeFunction",
          "default" : "invokeFunction",
          "enum" : [ "listFunctions", "getFunction", "createAlias", "deleteAlias", "getAlias", "listAliases", "createFunction", "deleteFunction", "invokeFunction", "updateFunction", "createEventSourceMapping", "deleteEventSourceMapping", "listEventSourceMapping", "listTags", "tagResource", "untagResource", "publishVersion", "listVersions" ],
          "type" : "string"
        },
        "pojo-request" : {
          "description" : "If we want to use a POJO request as body or not",
          "default" : "false",
          "type" : "boolean"
        },
        "proxy-host" : {
          "description" : "To define a proxy host when instantiating the Lambda client",
          "type" : "string"
        },
        "proxy-port" : {
          "description" : "To define a proxy port when instantiating the Lambda client",
          "type" : "integer"
        },
        "proxy-protocol" : {
          "description" : "To define a proxy protocol when instantiating the Lambda client",
          "default" : "HTTPS",
          "enum" : [ "HTTP", "HTTPS" ],
          "type" : "string"
        },
        "region" : {
          "description" : "The region in which ECS client needs to work. When using this parameter, the configuration will expect the lowercase name of the region (for example ap-east-1) You'll need to use the name Region.EU_WEST_1.id()",
          "type" : "string"
        },
        "secret-key" : {
          "description" : "Amazon AWS Secret Key",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "trust-all-certificates" : {
          "description" : "If we want to trust all certificates in case of overriding the endpoint",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "aws2-mq" : {
      "type" : "object",
      "required" : [ "label", "operation" ],
      "properties" : {
        "label" : {
          "description" : "Logical name",
          "type" : "string"
        },
        "access-key" : {
          "description" : "Amazon AWS Access Key",
          "type" : "string"
        },
        "amazon-mq-client" : {
          "description" : "To use a existing configured AmazonMQClient as client",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "operation" : {
          "description" : "The operation to perform. It can be listBrokers,createBroker,deleteBroker",
          "enum" : [ "listBrokers", "createBroker", "deleteBroker", "rebootBroker", "updateBroker", "describeBroker" ],
          "type" : "string"
        },
        "pojo-request" : {
          "description" : "If we want to use a POJO request as body or not",
          "default" : "false",
          "type" : "boolean"
        },
        "proxy-host" : {
          "description" : "To define a proxy host when instantiating the MQ client",
          "type" : "string"
        },
        "proxy-port" : {
          "description" : "To define a proxy port when instantiating the MQ client",
          "type" : "integer"
        },
        "proxy-protocol" : {
          "description" : "To define a proxy protocol when instantiating the MQ client",
          "default" : "HTTPS",
          "enum" : [ "HTTP", "HTTPS" ],
          "type" : "string"
        },
        "region" : {
          "description" : "The region in which MQ client needs to work. When using this parameter, the configuration will expect the lowercase name of the region (for example ap-east-1) You'll need to use the name Region.EU_WEST_1.id()",
          "type" : "string"
        },
        "secret-key" : {
          "description" : "Amazon AWS Secret Key",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "trust-all-certificates" : {
          "description" : "If we want to trust all certificates in case of overriding the endpoint",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "aws2-msk" : {
      "type" : "object",
      "required" : [ "label", "operation" ],
      "properties" : {
        "label" : {
          "description" : "Logical name",
          "type" : "string"
        },
        "access-key" : {
          "description" : "Amazon AWS Access Key",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "msk-client" : {
          "description" : "To use a existing configured AWS MSK as client",
          "type" : "string"
        },
        "operation" : {
          "description" : "The operation to perform",
          "enum" : [ "listClusters", "createCluster", "deleteCluster", "describeCluster" ],
          "type" : "string"
        },
        "pojo-request" : {
          "description" : "If we want to use a POJO request as body or not",
          "default" : "false",
          "type" : "boolean"
        },
        "proxy-host" : {
          "description" : "To define a proxy host when instantiating the MSK client",
          "type" : "string"
        },
        "proxy-port" : {
          "description" : "To define a proxy port when instantiating the MSK client",
          "type" : "integer"
        },
        "proxy-protocol" : {
          "description" : "To define a proxy protocol when instantiating the MSK client",
          "default" : "HTTPS",
          "enum" : [ "HTTP", "HTTPS" ],
          "type" : "string"
        },
        "region" : {
          "description" : "The region in which MSK client needs to work. When using this parameter, the configuration will expect the lowercase name of the region (for example ap-east-1) You'll need to use the name Region.EU_WEST_1.id()",
          "type" : "string"
        },
        "secret-key" : {
          "description" : "Amazon AWS Secret Key",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "trust-all-certificates" : {
          "description" : "If we want to trust all certificates in case of overriding the endpoint",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "aws2-s3" : {
      "type" : "object",
      "required" : [ "bucketNameOrArn" ],
      "properties" : {
        "bucket-name-or-arn" : {
          "description" : "Bucket name or ARN",
          "type" : "string"
        },
        "access-key" : {
          "description" : "Amazon AWS Access Key",
          "type" : "string"
        },
        "amazon-s3-client" : {
          "description" : "Reference to a com.amazonaws.services.s3.AmazonS3 in the registry.",
          "type" : "string"
        },
        "amazon-s3-presigner" : {
          "description" : "An S3 Presigner for Request, used mainly in createDownloadLink operation",
          "type" : "string"
        },
        "auto-create-bucket" : {
          "description" : "Setting the autocreation of the S3 bucket bucketName. This will apply also in case of moveAfterRead option enabled and it will create the destinationBucket if it doesn't exist already.",
          "default" : "true",
          "type" : "boolean"
        },
        "autoclose-body" : {
          "description" : "If this option is true and includeBody is false, then the S3Object.close() method will be called on exchange completion. This option is strongly related to includeBody option. In case of setting includeBody to false and autocloseBody to false, it will be up to the caller to close the S3Object stream. Setting autocloseBody to true, will close the S3Object stream automatically.",
          "default" : "true",
          "type" : "boolean"
        },
        "aws-kms-key-id" : {
          "description" : "Define the id of KMS key to use in case KMS is enabled",
          "type" : "string"
        },
        "backoff-error-threshold" : {
          "description" : "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-idle-threshold" : {
          "description" : "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-multiplier" : {
          "description" : "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
          "type" : "integer"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "customer-algorithm" : {
          "description" : "Define the customer algorithm to use in case CustomerKey is enabled",
          "type" : "string"
        },
        "customer-key-id" : {
          "description" : "Define the id of Customer key to use in case CustomerKey is enabled",
          "type" : "string"
        },
        "customer-key-md5" : {
          "description" : "Define the MD5 of Customer key to use in case CustomerKey is enabled",
          "type" : "string"
        },
        "delay" : {
          "description" : "Milliseconds before the next poll.",
          "default" : "500",
          "type" : "integer"
        },
        "delete-after-read" : {
          "description" : "Delete objects from S3 after they have been retrieved. The delete is only performed if the Exchange is committed. If a rollback occurs, the object is not deleted. If this option is false, then the same objects will be retrieve over and over again on the polls. Therefore you need to use the Idempotent Consumer EIP in the route to filter out duplicates. You can filter using the AWS2S3Constants#BUCKET_NAME and AWS2S3Constants#KEY headers, or only the AWS2S3Constants#KEY header.",
          "default" : "true",
          "type" : "boolean"
        },
        "delete-after-write" : {
          "description" : "Delete file object after the S3 file has been uploaded",
          "default" : "false",
          "type" : "boolean"
        },
        "delimiter" : {
          "description" : "The delimiter which is used in the com.amazonaws.services.s3.model.ListObjectsRequest to only consume objects we are interested in.",
          "type" : "string"
        },
        "destination-bucket" : {
          "description" : "Define the destination bucket where an object must be moved when moveAfterRead is set to true.",
          "type" : "string"
        },
        "destination-bucket-prefix" : {
          "description" : "Define the destination bucket prefix to use when an object must be moved and moveAfterRead is set to true.",
          "type" : "string"
        },
        "destination-bucket-suffix" : {
          "description" : "Define the destination bucket suffix to use when an object must be moved and moveAfterRead is set to true.",
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "file-name" : {
          "description" : "To get the object from the bucket with the given file name",
          "type" : "string"
        },
        "greedy" : {
          "description" : "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
          "default" : "false",
          "type" : "boolean"
        },
        "include-body" : {
          "description" : "If it is true, the S3Object exchange will be consumed and put into the body and closed. If false the S3Object stream will be put raw into the body and the headers will be set with the S3 object metadata. This option is strongly related to autocloseBody option. In case of setting includeBody to true because the S3Object stream will be consumed then it will also be closed in case of includeBody false then it will be up to the caller to close the S3Object stream. However setting autocloseBody to true when includeBody is false it will schedule to close the S3Object stream automatically on exchange completion.",
          "default" : "true",
          "type" : "boolean"
        },
        "include-folders" : {
          "description" : "If it is true, the folders/directories will be consumed. If it is false, they will be ignored, and Exchanges will not be created for those",
          "default" : "true",
          "type" : "boolean"
        },
        "initial-delay" : {
          "description" : "Milliseconds before the first poll starts.",
          "default" : "1000",
          "type" : "integer"
        },
        "key-name" : {
          "description" : "Setting the key name for an element in the bucket through endpoint parameter",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "max-connections" : {
          "description" : "Set the maxConnections parameter in the S3 client configuration",
          "default" : "60",
          "type" : "integer"
        },
        "max-messages-per-poll" : {
          "description" : "Gets the maximum number of messages as a limit to poll at each polling. Gets the maximum number of messages as a limit to poll at each polling. The default value is 10. Use 0 or a negative number to set it as unlimited.",
          "default" : "10",
          "type" : "integer"
        },
        "move-after-read" : {
          "description" : "Move objects from S3 bucket to a different bucket after they have been retrieved. To accomplish the operation the destinationBucket option must be set. The copy bucket operation is only performed if the Exchange is committed. If a rollback occurs, the object is not moved.",
          "default" : "false",
          "type" : "boolean"
        },
        "multi-part-upload" : {
          "description" : "If it is true, camel will upload the file with multi part format, the part size is decided by the option of partSize",
          "default" : "false",
          "type" : "boolean"
        },
        "operation" : {
          "description" : "The operation to do in case the user don't want to do only an upload",
          "enum" : [ "copyObject", "listObjects", "deleteObject", "deleteBucket", "listBuckets", "getObject", "getObjectRange" ],
          "type" : "string"
        },
        "override-endpoint" : {
          "description" : "Set the need for overidding the endpoint. This option needs to be used in combination with uriEndpointOverride option",
          "default" : "false",
          "type" : "boolean"
        },
        "part-size" : {
          "description" : "Setup the partSize which is used in multi part upload, the default size is 25M.",
          "default" : "26214400",
          "type" : "integer"
        },
        "pojo-request" : {
          "description" : "If we want to use a POJO request as body or not",
          "default" : "false",
          "type" : "boolean"
        },
        "policy" : {
          "description" : "The policy for this queue to set in the com.amazonaws.services.s3.AmazonS3#setBucketPolicy() method.",
          "type" : "string"
        },
        "poll-strategy" : {
          "description" : "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
          "type" : "string"
        },
        "prefix" : {
          "description" : "The prefix which is used in the com.amazonaws.services.s3.model.ListObjectsRequest to only consume objects we are interested in.",
          "type" : "string"
        },
        "proxy-host" : {
          "description" : "To define a proxy host when instantiating the SQS client",
          "type" : "string"
        },
        "proxy-port" : {
          "description" : "Specify a proxy port to be used inside the client definition.",
          "type" : "integer"
        },
        "proxy-protocol" : {
          "description" : "To define a proxy protocol when instantiating the S3 client",
          "default" : "HTTPS",
          "enum" : [ "HTTP", "HTTPS" ],
          "type" : "string"
        },
        "region" : {
          "description" : "The region in which S3 client needs to work. When using this parameter, the configuration will expect the lowercase name of the region (for example ap-east-1) You'll need to use the name Region.EU_WEST_1.id()",
          "type" : "string"
        },
        "repeat-count" : {
          "description" : "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
          "default" : "0",
          "type" : "integer"
        },
        "run-logging-level" : {
          "description" : "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
          "default" : "TRACE",
          "enum" : [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ],
          "type" : "string"
        },
        "scheduled-executor-service" : {
          "description" : "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
          "type" : "string"
        },
        "scheduler" : {
          "description" : "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
          "default" : "none",
          "type" : "string"
        },
        "scheduler-properties" : {
          "description" : "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
          "type" : "string"
        },
        "secret-key" : {
          "description" : "Amazon AWS Secret Key",
          "type" : "string"
        },
        "send-empty-message-when-idle" : {
          "description" : "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
          "default" : "false",
          "type" : "boolean"
        },
        "start-scheduler" : {
          "description" : "Whether the scheduler should be auto started.",
          "default" : "true",
          "type" : "boolean"
        },
        "storage-class" : {
          "description" : "The storage class to set in the com.amazonaws.services.s3.model.PutObjectRequest request.",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "time-unit" : {
          "description" : "Time unit for initialDelay and delay options.",
          "default" : "MILLISECONDS",
          "enum" : [ "NANOSECONDS", "MICROSECONDS", "MILLISECONDS", "SECONDS", "MINUTES", "HOURS", "DAYS" ],
          "type" : "string"
        },
        "trust-all-certificates" : {
          "description" : "If we want to trust all certificates in case of overriding the endpoint",
          "default" : "false",
          "type" : "boolean"
        },
        "uri-endpoint-override" : {
          "description" : "Set the overriding uri endpoint. This option needs to be used in combination with overrideEndpoint option",
          "type" : "string"
        },
        "use-aws-kms" : {
          "description" : "Define if KMS must be used or not",
          "default" : "false",
          "type" : "boolean"
        },
        "use-customer-key" : {
          "description" : "Define if Customer Key must be used or not",
          "default" : "false",
          "type" : "boolean"
        },
        "use-default-credentials-provider" : {
          "description" : "Set whether the S3 client should expect to load credentials through a default credentials provider or to expect static credentials to be passed in.",
          "default" : "false",
          "type" : "boolean"
        },
        "use-fixed-delay" : {
          "description" : "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
          "default" : "true",
          "type" : "boolean"
        }
      }
    },
    "aws2-ses" : {
      "type" : "object",
      "required" : [ "from" ],
      "properties" : {
        "from" : {
          "description" : "The sender's email address.",
          "type" : "string"
        },
        "access-key" : {
          "description" : "Amazon AWS Access Key",
          "type" : "string"
        },
        "amazon-ses-client" : {
          "description" : "To use the AmazonSimpleEmailService as the client",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "proxy-host" : {
          "description" : "To define a proxy host when instantiating the SES client",
          "type" : "string"
        },
        "proxy-port" : {
          "description" : "To define a proxy port when instantiating the SES client",
          "type" : "integer"
        },
        "proxy-protocol" : {
          "description" : "To define a proxy protocol when instantiating the SES client",
          "default" : "HTTPS",
          "enum" : [ "HTTP", "HTTPS" ],
          "type" : "string"
        },
        "region" : {
          "description" : "The region in which SES client needs to work. When using this parameter, the configuration will expect the lowercase name of the region (for example ap-east-1) You'll need to use the name Region.EU_WEST_1.id()",
          "type" : "string"
        },
        "reply-to-addresses" : {
          "description" : "List of reply-to email address(es) for the message, override it using 'CamelAwsSesReplyToAddresses' header.",
          "type" : "string"
        },
        "return-path" : {
          "description" : "The email address to which bounce notifications are to be forwarded, override it using 'CamelAwsSesReturnPath' header.",
          "type" : "string"
        },
        "secret-key" : {
          "description" : "Amazon AWS Secret Key",
          "type" : "string"
        },
        "subject" : {
          "description" : "The subject which is used if the message header 'CamelAwsSesSubject' is not present.",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "to" : {
          "description" : "List of destination email address. Can be overriden with 'CamelAwsSesTo' header.",
          "type" : "string"
        },
        "trust-all-certificates" : {
          "description" : "If we want to trust all certificates in case of overriding the endpoint",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "aws2-sns" : {
      "type" : "object",
      "required" : [ "topicNameOrArn" ],
      "properties" : {
        "topic-name-or-arn" : {
          "description" : "Topic name or ARN",
          "type" : "string"
        },
        "access-key" : {
          "description" : "Amazon AWS Access Key",
          "type" : "string"
        },
        "amazon-sns-client" : {
          "description" : "To use the AmazonSNS as the client",
          "type" : "string"
        },
        "auto-create-topic" : {
          "description" : "Setting the autocreation of the topic",
          "default" : "true",
          "type" : "boolean"
        },
        "header-filter-strategy" : {
          "description" : "To use a custom HeaderFilterStrategy to map headers to/from Camel.",
          "type" : "string"
        },
        "kms-master-key-id" : {
          "description" : "The ID of an AWS-managed customer master key (CMK) for Amazon SNS or a custom CMK.",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "message-deduplication-id-strategy" : {
          "description" : "Only for FIFO Topic. Strategy for setting the messageDeduplicationId on the message. Can be one of the following options: useExchangeId, useContentBasedDeduplication. For the useContentBasedDeduplication option, no messageDeduplicationId will be set on the message.",
          "default" : "useExchangeId",
          "enum" : [ "useExchangeId", "useContentBasedDeduplication" ],
          "type" : "string"
        },
        "message-group-id-strategy" : {
          "description" : "Only for FIFO Topic. Strategy for setting the messageGroupId on the message. Can be one of the following options: useConstant, useExchangeId, usePropertyValue. For the usePropertyValue option, the value of property CamelAwsMessageGroupId will be used.",
          "enum" : [ "useConstant", "useExchangeId", "usePropertyValue" ],
          "type" : "string"
        },
        "message-structure" : {
          "description" : "The message structure to use such as json",
          "type" : "string"
        },
        "policy" : {
          "description" : "The policy for this queue",
          "type" : "string"
        },
        "proxy-host" : {
          "description" : "To define a proxy host when instantiating the SNS client",
          "type" : "string"
        },
        "proxy-port" : {
          "description" : "To define a proxy port when instantiating the SNS client",
          "type" : "integer"
        },
        "proxy-protocol" : {
          "description" : "To define a proxy protocol when instantiating the SNS client",
          "default" : "HTTPS",
          "enum" : [ "HTTP", "HTTPS" ],
          "type" : "string"
        },
        "queue-url" : {
          "description" : "The queueUrl to subscribe to",
          "type" : "string"
        },
        "region" : {
          "description" : "The region in which SNS client needs to work. When using this parameter, the configuration will expect the lowercase name of the region (for example ap-east-1) You'll need to use the name Region.EU_WEST_1.id()",
          "type" : "string"
        },
        "secret-key" : {
          "description" : "Amazon AWS Secret Key",
          "type" : "string"
        },
        "server-side-encryption-enabled" : {
          "description" : "Define if Server Side Encryption is enabled or not on the topic",
          "default" : "false",
          "type" : "boolean"
        },
        "subject" : {
          "description" : "The subject which is used if the message header 'CamelAwsSnsSubject' is not present.",
          "type" : "string"
        },
        "subscribe-sn-sto-sqs" : {
          "description" : "Define if the subscription between SNS Topic and SQS must be done or not",
          "default" : "false",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "trust-all-certificates" : {
          "description" : "If we want to trust all certificates in case of overriding the endpoint",
          "default" : "false",
          "type" : "boolean"
        },
        "use-default-credentials-provider" : {
          "description" : "Set whether the SNS client should expect to load credentials on an AWS infra instance or to expect static credentials to be passed in.",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "aws2-sqs" : {
      "type" : "object",
      "required" : [ "queueNameOrArn" ],
      "properties" : {
        "queue-name-or-arn" : {
          "description" : "Queue name or ARN",
          "type" : "string"
        },
        "access-key" : {
          "description" : "Amazon AWS Access Key",
          "type" : "string"
        },
        "amazon-aws-host" : {
          "description" : "The hostname of the Amazon AWS cloud.",
          "default" : "amazonaws.com",
          "type" : "string"
        },
        "amazon-sqs-client" : {
          "description" : "To use the AmazonSQS as client",
          "type" : "string"
        },
        "attribute-names" : {
          "description" : "A list of attribute names to receive when consuming. Multiple names can be separated by comma.",
          "type" : "string"
        },
        "auto-create-queue" : {
          "description" : "Setting the autocreation of the queue",
          "default" : "true",
          "type" : "boolean"
        },
        "backoff-error-threshold" : {
          "description" : "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-idle-threshold" : {
          "description" : "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-multiplier" : {
          "description" : "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
          "type" : "integer"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "concurrent-consumers" : {
          "description" : "Allows you to use multiple threads to poll the sqs queue to increase throughput",
          "default" : "1",
          "type" : "integer"
        },
        "default-visibility-timeout" : {
          "description" : "The default visibility timeout (in seconds)",
          "type" : "integer"
        },
        "delay" : {
          "description" : "Milliseconds before the next poll.",
          "default" : "500",
          "type" : "integer"
        },
        "delay-queue" : {
          "description" : "Define if you want to apply delaySeconds option to the queue or on single messages",
          "default" : "false",
          "type" : "boolean"
        },
        "delay-seconds" : {
          "description" : "Delay sending messages for a number of seconds.",
          "type" : "integer"
        },
        "delete-after-read" : {
          "description" : "Delete message from SQS after it has been read",
          "default" : "true",
          "type" : "boolean"
        },
        "delete-if-filtered" : {
          "description" : "Whether or not to send the DeleteMessage to the SQS queue if an exchange fails to get through a filter. If 'false' and exchange does not make it through a Camel filter upstream in the route, then don't send DeleteMessage.",
          "default" : "true",
          "type" : "boolean"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "extend-message-visibility" : {
          "description" : "If enabled then a scheduled background task will keep extending the message visibility on SQS. This is needed if it takes a long time to process the message. If set to true defaultVisibilityTimeout must be set. See details at Amazon docs.",
          "default" : "false",
          "type" : "boolean"
        },
        "greedy" : {
          "description" : "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
          "default" : "false",
          "type" : "boolean"
        },
        "header-filter-strategy" : {
          "description" : "To use a custom HeaderFilterStrategy to map headers to/from Camel.",
          "type" : "string"
        },
        "initial-delay" : {
          "description" : "Milliseconds before the first poll starts.",
          "default" : "1000",
          "type" : "integer"
        },
        "kms-data-key-reuse-period-seconds" : {
          "description" : "The length of time, in seconds, for which Amazon SQS can reuse a data key to encrypt or decrypt messages before calling AWS KMS again. An integer representing seconds, between 60 seconds (1 minute) and 86,400 seconds (24 hours). Default: 300 (5 minutes).",
          "type" : "integer"
        },
        "kms-master-key-id" : {
          "description" : "The ID of an AWS-managed customer master key (CMK) for Amazon SQS or a custom CMK.",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "max-messages-per-poll" : {
          "description" : "Gets the maximum number of messages as a limit to poll at each polling. Is default unlimited, but use 0 or negative number to disable it as unlimited.",
          "type" : "integer"
        },
        "maximum-message-size" : {
          "description" : "The maximumMessageSize (in bytes) an SQS message can contain for this queue.",
          "type" : "integer"
        },
        "message-attribute-names" : {
          "description" : "A list of message attribute names to receive when consuming. Multiple names can be separated by comma.",
          "type" : "string"
        },
        "message-deduplication-id-strategy" : {
          "description" : "Only for FIFO queues. Strategy for setting the messageDeduplicationId on the message. Can be one of the following options: useExchangeId, useContentBasedDeduplication. For the useContentBasedDeduplication option, no messageDeduplicationId will be set on the message.",
          "default" : "useExchangeId",
          "enum" : [ "useExchangeId", "useContentBasedDeduplication" ],
          "type" : "string"
        },
        "message-group-id-strategy" : {
          "description" : "Only for FIFO queues. Strategy for setting the messageGroupId on the message. Can be one of the following options: useConstant, useExchangeId, usePropertyValue. For the usePropertyValue option, the value of property CamelAwsMessageGroupId will be used.",
          "enum" : [ "useConstant", "useExchangeId", "usePropertyValue" ],
          "type" : "string"
        },
        "message-retention-period" : {
          "description" : "The messageRetentionPeriod (in seconds) a message will be retained by SQS for this queue.",
          "type" : "integer"
        },
        "operation" : {
          "description" : "The operation to do in case the user don't want to send only a message",
          "enum" : [ "sendBatchMessage", "deleteMessage", "listQueues", "purgeQueue" ],
          "type" : "string"
        },
        "policy" : {
          "description" : "The policy for this queue",
          "type" : "string"
        },
        "poll-strategy" : {
          "description" : "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
          "type" : "string"
        },
        "protocol" : {
          "description" : "The underlying protocol used to communicate with SQS",
          "default" : "https",
          "type" : "string"
        },
        "proxy-host" : {
          "description" : "To define a proxy host when instantiating the SQS client",
          "type" : "string"
        },
        "proxy-port" : {
          "description" : "To define a proxy port when instantiating the SQS client",
          "type" : "integer"
        },
        "proxy-protocol" : {
          "description" : "To define a proxy protocol when instantiating the SQS client",
          "default" : "HTTPS",
          "enum" : [ "HTTP", "HTTPS" ],
          "type" : "string"
        },
        "queue-owner-aws-account-id" : {
          "description" : "Specify the queue owner aws account id when you need to connect the queue with different account owner.",
          "type" : "string"
        },
        "queue-url" : {
          "description" : "To define the queueUrl explicitly. All other parameters, which would influence the queueUrl, are ignored. This parameter is intended to be used, to connect to a mock implementation of SQS, for testing purposes.",
          "type" : "string"
        },
        "receive-message-wait-time-seconds" : {
          "description" : "If you do not specify WaitTimeSeconds in the request, the queue attribute ReceiveMessageWaitTimeSeconds is used to determine how long to wait.",
          "type" : "integer"
        },
        "redrive-policy" : {
          "description" : "Specify the policy that send message to DeadLetter queue. See detail at Amazon docs.",
          "type" : "string"
        },
        "region" : {
          "description" : "The region in which SQS client needs to work. When using this parameter, the configuration will expect the lowercase name of the region (for example ap-east-1) You'll need to use the name Region.EU_WEST_1.id()",
          "type" : "string"
        },
        "repeat-count" : {
          "description" : "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
          "default" : "0",
          "type" : "integer"
        },
        "run-logging-level" : {
          "description" : "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
          "default" : "TRACE",
          "enum" : [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ],
          "type" : "string"
        },
        "scheduled-executor-service" : {
          "description" : "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
          "type" : "string"
        },
        "scheduler" : {
          "description" : "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
          "default" : "none",
          "type" : "string"
        },
        "scheduler-properties" : {
          "description" : "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
          "type" : "string"
        },
        "secret-key" : {
          "description" : "Amazon AWS Secret Key",
          "type" : "string"
        },
        "send-empty-message-when-idle" : {
          "description" : "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
          "default" : "false",
          "type" : "boolean"
        },
        "server-side-encryption-enabled" : {
          "description" : "Define if Server Side Encryption is enabled or not on the queue",
          "default" : "false",
          "type" : "boolean"
        },
        "start-scheduler" : {
          "description" : "Whether the scheduler should be auto started.",
          "default" : "true",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "time-unit" : {
          "description" : "Time unit for initialDelay and delay options.",
          "default" : "MILLISECONDS",
          "enum" : [ "NANOSECONDS", "MICROSECONDS", "MILLISECONDS", "SECONDS", "MINUTES", "HOURS", "DAYS" ],
          "type" : "string"
        },
        "trust-all-certificates" : {
          "description" : "If we want to trust all certificates in case of overriding the endpoint",
          "default" : "false",
          "type" : "boolean"
        },
        "use-default-credentials-provider" : {
          "description" : "Set whether the SQS client should expect to load credentials on an AWS infra instance or to expect static credentials to be passed in.",
          "default" : "false",
          "type" : "boolean"
        },
        "use-fixed-delay" : {
          "description" : "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
          "default" : "true",
          "type" : "boolean"
        },
        "visibility-timeout" : {
          "description" : "The duration (in seconds) that the received messages are hidden from subsequent retrieve requests after being retrieved by a ReceiveMessage request to set in the com.amazonaws.services.sqs.model.SetQueueAttributesRequest. This only make sense if its different from defaultVisibilityTimeout. It changes the queue visibility timeout attribute permanently.",
          "type" : "integer"
        },
        "wait-time-seconds" : {
          "description" : "Duration in seconds (0 to 20) that the ReceiveMessage action call will wait until a message is in the queue to include in the response.",
          "type" : "integer"
        }
      }
    },
    "aws2-sts" : {
      "type" : "object",
      "required" : [ "label", "operation" ],
      "properties" : {
        "label" : {
          "description" : "Logical name",
          "type" : "string"
        },
        "access-key" : {
          "description" : "Amazon AWS Access Key",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "operation" : {
          "description" : "The operation to perform",
          "default" : "assumeRole",
          "enum" : [ "assumeRole", "getSessionToken", "getFederationToken" ],
          "type" : "string"
        },
        "pojo-request" : {
          "description" : "If we want to use a POJO request as body or not",
          "default" : "false",
          "type" : "boolean"
        },
        "proxy-host" : {
          "description" : "To define a proxy host when instantiating the STS client",
          "type" : "string"
        },
        "proxy-port" : {
          "description" : "To define a proxy port when instantiating the STS client",
          "type" : "integer"
        },
        "proxy-protocol" : {
          "description" : "To define a proxy protocol when instantiating the STS client",
          "default" : "HTTPS",
          "enum" : [ "HTTP", "HTTPS" ],
          "type" : "string"
        },
        "region" : {
          "description" : "The region in which STS client needs to work. When using this parameter, the configuration will expect the lowercase name of the region (for example ap-east-1) You'll need to use the name Region.EU_WEST_1.id()",
          "default" : "aws-global",
          "type" : "string"
        },
        "secret-key" : {
          "description" : "Amazon AWS Secret Key",
          "type" : "string"
        },
        "sts-client" : {
          "description" : "To use a existing configured AWS STS as client",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "trust-all-certificates" : {
          "description" : "If we want to trust all certificates in case of overriding the endpoint",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "aws2-translate" : {
      "type" : "object",
      "required" : [ "label", "operation" ],
      "properties" : {
        "label" : {
          "description" : "Logical name",
          "type" : "string"
        },
        "access-key" : {
          "description" : "Amazon AWS Access Key",
          "type" : "string"
        },
        "autodetect-source-language" : {
          "description" : "Being able to autodetect the source language",
          "default" : "false",
          "type" : "boolean"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "operation" : {
          "description" : "The operation to perform",
          "default" : "translateText",
          "enum" : [ "translateText" ],
          "type" : "string"
        },
        "pojo-request" : {
          "description" : "If we want to use a POJO request as body or not",
          "default" : "false",
          "type" : "boolean"
        },
        "proxy-host" : {
          "description" : "To define a proxy host when instantiating the Translate client",
          "type" : "string"
        },
        "proxy-port" : {
          "description" : "To define a proxy port when instantiating the Translate client",
          "type" : "integer"
        },
        "proxy-protocol" : {
          "description" : "To define a proxy protocol when instantiating the Translate client",
          "default" : "HTTPS",
          "enum" : [ "HTTP", "HTTPS" ],
          "type" : "string"
        },
        "region" : {
          "description" : "The region in which Translate client needs to work. When using this parameter, the configuration will expect the lowercase name of the region (for example ap-east-1) You'll need to use the name Region.EU_WEST_1.id()",
          "type" : "string"
        },
        "secret-key" : {
          "description" : "Amazon AWS Secret Key",
          "type" : "string"
        },
        "source-language" : {
          "description" : "Source language to use",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "target-language" : {
          "description" : "Target language to use",
          "type" : "string"
        },
        "translate-client" : {
          "description" : "To use a existing configured AWS Translate as client",
          "type" : "string"
        },
        "trust-all-certificates" : {
          "description" : "If we want to trust all certificates in case of overriding the endpoint",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "azure-blob" : {
      "type" : "object",
      "required" : [ "containerOrBlobUri" ],
      "properties" : {
        "container-or-blob-uri" : {
          "description" : "Container or Blob compact Uri",
          "type" : "string"
        },
        "azure-blob-client" : {
          "description" : "The blob service client",
          "type" : "string"
        },
        "blob-metadata" : {
          "description" : "Set the blob meta-data",
          "type" : "string"
        },
        "blob-offset" : {
          "description" : "Set the blob offset for the upload or download operations, default is 0",
          "default" : "0",
          "type" : "integer"
        },
        "blob-prefix" : {
          "description" : "Set a prefix which can be used for listing the blobs",
          "type" : "string"
        },
        "blob-type" : {
          "description" : "Set a blob type, 'blockblob' is default",
          "default" : "blockblob",
          "enum" : [ "blockblob", "appendblob", "pageblob" ],
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "close-stream-after-read" : {
          "description" : "Close the stream after read or keep it open, default is true",
          "default" : "true",
          "type" : "boolean"
        },
        "close-stream-after-write" : {
          "description" : "Close the stream after write or keep it open, default is true",
          "default" : "true",
          "type" : "boolean"
        },
        "credentials" : {
          "description" : "Set the storage credentials, required in most cases",
          "type" : "string"
        },
        "credentials-account-key" : {
          "description" : "Set the storage account key used during authentication phase",
          "type" : "string"
        },
        "credentials-account-name" : {
          "description" : "Set the storage account name used during authentication phase",
          "type" : "string"
        },
        "data-length" : {
          "description" : "Set the data length for the download or page blob upload operations",
          "type" : "integer"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "file-dir" : {
          "description" : "Set the file directory where the downloaded blobs will be saved to",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "operation" : {
          "description" : "Blob service operation hint to the producer",
          "default" : "listBlobs",
          "enum" : [ "getBlob", "deleteBlob", "listBlobs", "updateBlockBlob", "uploadBlobBlocks", "commitBlobBlockList", "getBlobBlockList", "createAppendBlob", "updateAppendBlob", "createPageBlob", "updatePageBlob", "resizePageBlob", "clearPageBlob", "getPageBlobRanges" ],
          "type" : "string"
        },
        "public-for-read" : {
          "description" : "Storage resources can be public for reading their content, if this property is enabled then the credentials do not have to be set",
          "default" : "false",
          "type" : "boolean"
        },
        "stream-read-size" : {
          "description" : "Set the minimum read size in bytes when reading the blob content",
          "type" : "integer"
        },
        "stream-write-size" : {
          "description" : "Set the size of the buffer for writing block and page blocks",
          "type" : "integer"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "use-flat-listing" : {
          "description" : "Specify if the flat or hierarchical blob listing should be used",
          "default" : "true",
          "type" : "boolean"
        },
        "validate-client-uri" : {
          "description" : "Whether to validate the Azure client URI",
          "default" : "true",
          "type" : "boolean"
        }
      }
    },
    "azure-eventhubs" : {
      "type" : "object",
      "properties" : {
        "event-hub-name" : {
          "description" : "EventHubs name under a specific namcespace",
          "type" : "string"
        },
        "namespace" : {
          "description" : "EventHubs namespace created in Azure Portal",
          "type" : "string"
        },
        "amqp-retry-options" : {
          "description" : "Sets the retry policy for EventHubAsyncClient. If not specified, the default retry options are used.",
          "type" : "string"
        },
        "amqp-transport-type" : {
          "description" : "Sets the transport type by which all the communication with Azure Event Hubs occurs. Default value is AmqpTransportType#AMQP.",
          "default" : "AMQP",
          "enum" : [ "Amqp", "AmqpWebSockets" ],
          "type" : "string"
        },
        "auto-discover-client" : {
          "description" : "Setting the autoDiscoverClient mechanism, if true, the component will look for a client instance in the registry automatically otherwise it will skip that checking.",
          "default" : "true",
          "type" : "boolean"
        },
        "blob-access-key" : {
          "description" : "In case you chose the default BlobCheckpointStore, this sets access key for the associated azure account name to be used for authentication with azure blob services",
          "type" : "string"
        },
        "blob-account-name" : {
          "description" : "In case you chose the default BlobCheckpointStore, this sets Azure account name to be used for authentication with azure blob services.",
          "type" : "string"
        },
        "blob-container-name" : {
          "description" : "In case you chose the default BlobCheckpointStore, this sets the blob container that shall be used by the BlobCheckpointStore to store the checkpoint offsets",
          "type" : "string"
        },
        "blob-storage-shared-key-credential" : {
          "description" : "In case you chose the default BlobCheckpointStore, StorageSharedKeyCredential can be injected to create the azure client, this holds the important authentication information",
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "checkpoint-store" : {
          "description" : "Sets the CheckpointStore the EventProcessorClient will use for storing partition ownership and checkpoint information. Users can, optionally, provide their own implementation of CheckpointStore which will store ownership and checkpoint information. By default it set to use com.azure.messaging.eventhubs.checkpointstore.blob.BlobCheckpointStore which stores all checkpoint offsets into Azure Blob Storage",
          "default" : "BlobCheckpointStore",
          "type" : "string"
        },
        "connection-string" : {
          "description" : "Instead of supplying namespace, sharedAccessKey, sharedAccessName ... etc, you can just supply the connection string for your eventHub. The connection string for EventHubs already include all the necessary information to connection to your EventHub. To learn on how to generate the connection string, take a look at this documentation: https://docs.microsoft.com/en-us/azure/event-hubs/event-hubs-get-connection-string",
          "type" : "string"
        },
        "consumer-group-name" : {
          "description" : "Sets the name of the consumer group this consumer is associated with. Events are read in the context of this group. The name of the consumer group that is created by default is {link #DEFAULT_CONSUMER_GROUP_NAME $Default}.",
          "default" : "$Default",
          "type" : "string"
        },
        "event-position" : {
          "description" : "Sets the map containing the event position to use for each partition if a checkpoint for the partition does not exist in CheckpointStore. This map is keyed off of the partition id. If there is no checkpoint in CheckpointStore and there is no entry in this map, the processing of the partition will start from {link EventPosition#latest() latest} position.",
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "partition-id" : {
          "description" : "Sets the identifier of the Event Hub partition that the events will be sent to. If the identifier is not specified, the Event Hubs service will be responsible for routing events that are sent to an available partition.",
          "type" : "string"
        },
        "partition-key" : {
          "description" : "Sets a hashing key to be provided for the batch of events, which instructs the Event Hubs service to map this key to a specific partition. The selection of a partition is stable for a given partition hashing key. Should any other batches of events be sent using the same exact partition hashing key, the Event Hubs service will route them all to the same partition. This should be specified only when there is a need to group events by partition, but there is flexibility into which partition they are routed. If ensuring that a batch of events is sent only to a specific partition, it is recommended that the {link #setPartitionId(String) identifier of the position be specified directly} when sending the batch.",
          "type" : "string"
        },
        "prefetch-count" : {
          "description" : "Sets the count used by the receiver to control the number of events the Event Hub consumer will actively receive and queue locally without regard to whether a receive operation is currently active.",
          "default" : "500",
          "type" : "integer"
        },
        "producer-async-client" : {
          "description" : "Sets the EventHubProducerAsyncClient.An asynchronous producer responsible for transmitting EventData to a specific Event Hub, grouped together in batches. Depending on the options specified when creating an {linkEventDataBatch}, the events may be automatically routed to an available partition or specific to a partition. Use by this component to produce the data in camel producer.",
          "type" : "string"
        },
        "shared-access-key" : {
          "description" : "The generated value for the SharedAccessName",
          "type" : "string"
        },
        "shared-access-name" : {
          "description" : "The name you chose for your EventHubs SAS keys",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "azure-queue" : {
      "type" : "object",
      "required" : [ "containerAndQueueUri" ],
      "properties" : {
        "container-and-queue-uri" : {
          "description" : "Container Queue compact Uri",
          "type" : "string"
        },
        "azure-queue-client" : {
          "description" : "The queue service client",
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "credentials" : {
          "description" : "Set the storage credentials, required in most cases",
          "type" : "string"
        },
        "credentials-account-key" : {
          "description" : "Set the storage account key used during authentication phase",
          "type" : "string"
        },
        "credentials-account-name" : {
          "description" : "Set the storage account name used during authentication phase",
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "message-time-to-live" : {
          "description" : "Message Time To Live in seconds",
          "type" : "integer"
        },
        "message-visibility-delay" : {
          "description" : "Message Visibility Delay in seconds",
          "type" : "integer"
        },
        "operation" : {
          "description" : "Queue service operation hint to the producer",
          "default" : "listQueues",
          "enum" : [ "listQueues", "createQueue", "deleteQueue", "addMessage", "retrieveMessage", "peekMessage", "updateMessage", "deleteMessage" ],
          "type" : "string"
        },
        "queue-prefix" : {
          "description" : "Set a prefix which can be used for listing the queues",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "validate-client-uri" : {
          "description" : "Whether to validate the Azure client URI",
          "default" : "true",
          "type" : "boolean"
        }
      }
    },
    "azure-storage-blob" : {
      "type" : "object",
      "properties" : {
        "account-name" : {
          "description" : "Azure account name to be used for authentication with azure blob services",
          "type" : "string"
        },
        "container-name" : {
          "description" : "The blob container name",
          "type" : "string"
        },
        "access-key" : {
          "description" : "Access key for the associated azure account name to be used for authentication with azure blob services",
          "type" : "string"
        },
        "auto-discover-client" : {
          "description" : "Setting the autoDiscoverClient mechanism, if true, the component will look for a client instance in the registry automatically otherwise it will skip that checking.",
          "default" : "true",
          "type" : "boolean"
        },
        "blob-name" : {
          "description" : "The blob name, to consume specific blob from a container. However on producer, is only required for the operations on the blob level",
          "type" : "string"
        },
        "blob-offset" : {
          "description" : "Set the blob offset for the upload or download operations, default is 0",
          "default" : "0",
          "type" : "integer"
        },
        "blob-sequence-number" : {
          "description" : "A user-controlled value that you can use to track requests. The value of the sequence number must be between 0 and 263 - 1.The default value is 0.",
          "default" : "0",
          "type" : "integer"
        },
        "blob-service-client" : {
          "description" : "Client to a storage account. This client does not hold any state about a particular storage account but is instead a convenient way of sending off appropriate requests to the resource on the service. It may also be used to construct URLs to blobs and containers. This client contains operations on a service account. Operations on a container are available on BlobContainerClient through getBlobContainerClient(String), and operations on a blob are available on BlobClient through getBlobContainerClient(String).getBlobClient(String).",
          "type" : "string"
        },
        "blob-type" : {
          "description" : "The blob type in order to initiate the appropriate settings for each blob type",
          "default" : "blockblob",
          "enum" : [ "blockblob", "appendblob", "pageblob" ],
          "type" : "string"
        },
        "block-list-type" : {
          "description" : "Specifies which type of blocks to return.",
          "default" : "COMMITTED",
          "enum" : [ "committed", "uncommitted", "all" ],
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "close-stream-after-read" : {
          "description" : "Close the stream after read or keep it open, default is true",
          "default" : "true",
          "type" : "boolean"
        },
        "close-stream-after-write" : {
          "description" : "Close the stream after write or keep it open, default is true",
          "default" : "true",
          "type" : "boolean"
        },
        "commit-block-list-later" : {
          "description" : "When is set to true, the staged blocks will not be committed directly.",
          "default" : "true",
          "type" : "boolean"
        },
        "create-append-blob" : {
          "description" : "When is set to true, the append blocks will be created when committing append blocks.",
          "default" : "true",
          "type" : "boolean"
        },
        "create-page-blob" : {
          "description" : "When is set to true, the page blob will be created when uploading page blob.",
          "default" : "true",
          "type" : "boolean"
        },
        "credentials" : {
          "description" : "StorageSharedKeyCredential can be injected to create the azure client, this holds the important authentication information",
          "type" : "string"
        },
        "data-count" : {
          "description" : "How many bytes to include in the range. Must be greater than or equal to 0 if specified.",
          "type" : "integer"
        },
        "download-link-expiration" : {
          "description" : "Override the default expiration (millis) of URL download link.",
          "type" : "integer"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "file-dir" : {
          "description" : "The file directory where the downloaded blobs will be saved to, this can be used in both, producer and consumer",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "max-results-per-page" : {
          "description" : "Specifies the maximum number of blobs to return, including all BlobPrefix elements. If the request does not specify maxResultsPerPage or specifies a value greater than 5,000, the server will return up to 5,000 items.",
          "type" : "integer"
        },
        "max-retry-requests" : {
          "description" : "Specifies the maximum number of additional HTTP Get requests that will be made while reading the data from a response body.",
          "default" : "0",
          "type" : "integer"
        },
        "operation" : {
          "description" : "The blob operation that can be used with this component on the producer",
          "default" : "listBlobContainers",
          "enum" : [ "listBlobContainers", "createBlobContainer", "deleteBlobContainer", "listBlobs", "getBlob", "deleteBlob", "downloadBlobToFile", "downloadLink", "uploadBlockBlob", "stageBlockBlobList", "commitBlobBlockList", "getBlobBlockList", "createAppendBlob", "commitAppendBlob", "createPageBlob", "uploadPageBlob", "resizePageBlob", "clearPageBlob", "getPageBlobRanges" ],
          "type" : "string"
        },
        "page-blob-size" : {
          "description" : "Specifies the maximum size for the page blob, up to 8 TB. The page blob size must be aligned to a 512-byte boundary.",
          "default" : "512",
          "type" : "integer"
        },
        "prefix" : {
          "description" : "Filters the results to return only blobs whose names begin with the specified prefix. May be null to return all blobs.",
          "type" : "string"
        },
        "regex" : {
          "description" : "Filters the results to return only blobs whose names match the specified regular expression. May be null to return all if both prefix and regex are set, regex takes the priority and prefix is ignored.",
          "type" : "string"
        },
        "service-client" : {
          "description" : "Client to a storage account. This client does not hold any state about a particular storage account but is instead a convenient way of sending off appropriate requests to the resource on the service. It may also be used to construct URLs to blobs and containers. This client contains operations on a service account. Operations on a container are available on BlobContainerClient through BlobServiceClient#getBlobContainerClient(String), and operations on a blob are available on BlobClient through BlobContainerClient#getBlobClient(String).",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "timeout" : {
          "description" : "An optional timeout value beyond which a RuntimeException will be raised.",
          "type" : "string"
        }
      }
    },
    "azure-storage-queue" : {
      "type" : "object",
      "properties" : {
        "account-name" : {
          "description" : "Azure account name to be used for authentication with azure queue services",
          "type" : "string"
        },
        "queue-name" : {
          "description" : "The queue resource name",
          "type" : "string"
        },
        "access-key" : {
          "description" : "Access key for the associated azure account name to be used for authentication with azure queue services",
          "type" : "string"
        },
        "auto-discover-client" : {
          "description" : "Setting the autoDiscoverClient mechanism, if true, the component will look for a client instance in the registry automatically otherwise it will skip that checking.",
          "default" : "true",
          "type" : "boolean"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "create-queue" : {
          "description" : "When is set to true, the queue will be automatically created when sending messages to the queue.",
          "default" : "true",
          "type" : "boolean"
        },
        "credentials" : {
          "description" : "StorageSharedKeyCredential can be injected to create the azure client, this holds the important authentication information",
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "max-messages" : {
          "description" : "Maximum number of messages to get, if there are less messages exist in the queue than requested all the messages will be returned. If left empty only 1 message will be retrieved, the allowed range is 1 to 32 messages.",
          "default" : "1",
          "type" : "integer"
        },
        "message-id" : {
          "description" : "The ID of the message to be deleted or updated.",
          "type" : "string"
        },
        "operation" : {
          "description" : "Queue service operation hint to the producer",
          "enum" : [ "listQueues", "createQueue", "deleteQueue", "clearQueue", "sendMessage", "deleteMessage", "receiveMessages", "peekMessages", "updateMessage" ],
          "type" : "string"
        },
        "pop-receipt" : {
          "description" : "Unique identifier that must match for the message to be deleted or updated.",
          "type" : "string"
        },
        "service-client" : {
          "description" : "Service client to a storage account to interact with the queue service. This client does not hold any state about a particular storage account but is instead a convenient way of sending off appropriate requests to the resource on the service. This client contains all the operations for interacting with a queue account in Azure Storage. Operations allowed by the client are creating, listing, and deleting queues, retrieving and updating properties of the account, and retrieving statistics of the account.",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "time-to-live" : {
          "description" : "How long the message will stay alive in the queue. If unset the value will default to 7 days, if -1 is passed the message will not expire. The time to live must be -1 or any positive number. The format should be in this form: PnDTnHnMn.nS., e.g: PT20.345S -- parses as 20.345 seconds, P2D -- parses as 2 days However, in case you are using EndpointDsl/ComponentDsl, you can do something like Duration.ofSeconds() since these Java APIs are typesafe.",
          "type" : "string"
        },
        "timeout" : {
          "description" : "An optional timeout applied to the operation. If a response is not returned before the timeout concludes a RuntimeException will be thrown.",
          "type" : "string"
        },
        "visibility-timeout" : {
          "description" : "The timeout period for how long the message is invisible in the queue. The timeout must be between 1 seconds and 7 days. The format should be in this form: PnDTnHnMn.nS., e.g: PT20.345S -- parses as 20.345 seconds, P2D -- parses as 2 days However, in case you are using EndpointDsl/ComponentDsl, you can do something like Duration.ofSeconds() since these Java APIs are typesafe.",
          "type" : "string"
        }
      }
    },
    "bean" : {
      "type" : "object",
      "required" : [ "beanName" ],
      "properties" : {
        "bean-name" : {
          "description" : "Sets the name of the bean to invoke",
          "type" : "string"
        },
        "cache" : {
          "description" : "Use scope option instead.",
          "type" : "boolean"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "method" : {
          "description" : "Sets the name of the method to invoke on the bean",
          "type" : "string"
        },
        "parameters" : {
          "description" : "Used for configuring additional properties on the bean",
          "type" : "string"
        },
        "scope" : {
          "description" : "Scope of bean. When using singleton scope (default) the bean is created or looked up only once and reused for the lifetime of the endpoint. The bean should be thread-safe in case concurrent threads is calling the bean at the same time. When using request scope the bean is created or looked up once per request (exchange). This can be used if you want to store state on a bean while processing a request and you want to call the same bean instance multiple times while processing the request. The bean does not have to be thread-safe as the instance is only called from the same request. When using prototype scope, then the bean will be looked up or created per call. However in case of lookup then this is delegated to the bean registry such as Spring or CDI (if in use), which depends on their configuration can act as either singleton or prototype scope. so when using prototype then this depends on the delegated registry.",
          "default" : "Singleton",
          "enum" : [ "Singleton", "Request", "Prototype" ],
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "bean-validator" : {
      "type" : "object",
      "required" : [ "label" ],
      "properties" : {
        "label" : {
          "description" : "Where label is an arbitrary text value describing the endpoint",
          "type" : "string"
        },
        "constraint-validator-factory" : {
          "description" : "To use a custom ConstraintValidatorFactory",
          "type" : "string"
        },
        "group" : {
          "description" : "To use a custom validation group",
          "default" : "javax.validation.groups.Default",
          "type" : "string"
        },
        "ignore-xml-configuration" : {
          "description" : "Whether to ignore data from the META-INF/validation.xml file.",
          "default" : "false",
          "type" : "boolean"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "message-interpolator" : {
          "description" : "To use a custom MessageInterpolator",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "traversable-resolver" : {
          "description" : "To use a custom TraversableResolver",
          "type" : "string"
        },
        "validation-provider-resolver" : {
          "description" : "To use a a custom ValidationProviderResolver",
          "type" : "string"
        },
        "validator-factory" : {
          "description" : "To use a custom ValidatorFactory",
          "type" : "string"
        }
      }
    },
    "beanstalk" : {
      "type" : "object",
      "properties" : {
        "connection-settings" : {
          "description" : "Connection settings host:port/tube",
          "type" : "string"
        },
        "await-job" : {
          "description" : "Whether to wait for job to complete before ack the job from beanstalk",
          "default" : "true",
          "type" : "boolean"
        },
        "backoff-error-threshold" : {
          "description" : "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-idle-threshold" : {
          "description" : "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-multiplier" : {
          "description" : "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
          "type" : "integer"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "command" : {
          "description" : "put means to put the job into Beanstalk. Job body is specified in the Camel message body. Job ID will be returned in beanstalk.jobId message header. delete, release, touch or bury expect Job ID in the message header beanstalk.jobId. Result of the operation is returned in beanstalk.result message header kick expects the number of jobs to kick in the message body and returns the number of jobs actually kicked out in the message header beanstalk.result.",
          "enum" : [ "bury", "release", "put", "touch", "delete", "kick" ],
          "type" : "string"
        },
        "delay" : {
          "description" : "Milliseconds before the next poll.",
          "default" : "500",
          "type" : "integer"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "greedy" : {
          "description" : "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
          "default" : "false",
          "type" : "boolean"
        },
        "initial-delay" : {
          "description" : "Milliseconds before the first poll starts.",
          "default" : "1000",
          "type" : "integer"
        },
        "job-delay" : {
          "description" : "Job delay in seconds.",
          "default" : "0",
          "type" : "integer"
        },
        "job-priority" : {
          "description" : "Job priority. (0 is the highest, see Beanstalk protocol)",
          "default" : "1000",
          "type" : "integer"
        },
        "job-time-to-run" : {
          "description" : "Job time to run in seconds. (when 0, the beanstalkd daemon raises it to 1 automatically, see Beanstalk protocol)",
          "default" : "60",
          "type" : "integer"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "on-failure" : {
          "description" : "Command to use when processing failed.",
          "enum" : [ "bury", "release", "put", "touch", "delete", "kick" ],
          "type" : "string"
        },
        "poll-strategy" : {
          "description" : "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
          "type" : "string"
        },
        "repeat-count" : {
          "description" : "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
          "default" : "0",
          "type" : "integer"
        },
        "run-logging-level" : {
          "description" : "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
          "default" : "TRACE",
          "enum" : [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ],
          "type" : "string"
        },
        "scheduled-executor-service" : {
          "description" : "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
          "type" : "string"
        },
        "scheduler" : {
          "description" : "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
          "default" : "none",
          "type" : "string"
        },
        "scheduler-properties" : {
          "description" : "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
          "type" : "string"
        },
        "send-empty-message-when-idle" : {
          "description" : "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
          "default" : "false",
          "type" : "boolean"
        },
        "start-scheduler" : {
          "description" : "Whether the scheduler should be auto started.",
          "default" : "true",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "time-unit" : {
          "description" : "Time unit for initialDelay and delay options.",
          "default" : "MILLISECONDS",
          "enum" : [ "NANOSECONDS", "MICROSECONDS", "MILLISECONDS", "SECONDS", "MINUTES", "HOURS", "DAYS" ],
          "type" : "string"
        },
        "use-block-io" : {
          "description" : "Whether to use blockIO.",
          "default" : "true",
          "type" : "boolean"
        },
        "use-fixed-delay" : {
          "description" : "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
          "default" : "true",
          "type" : "boolean"
        }
      }
    },
    "bonita" : {
      "type" : "object",
      "required" : [ "operation" ],
      "properties" : {
        "operation" : {
          "description" : "Operation to use",
          "enum" : [ "startCase" ],
          "type" : "string"
        },
        "hostname" : {
          "description" : "Hostname where Bonita engine runs",
          "default" : "localhost",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "password" : {
          "description" : "Password to authenticate to Bonita engine.",
          "type" : "string"
        },
        "port" : {
          "description" : "Port of the server hosting Bonita engine",
          "default" : "8080",
          "type" : "string"
        },
        "process-name" : {
          "description" : "Name of the process involved in the operation",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "username" : {
          "description" : "Username to authenticate to Bonita engine.",
          "type" : "string"
        }
      }
    },
    "box" : {
      "type" : "object",
      "required" : [ "apiName", "methodName" ],
      "properties" : {
        "api-name" : {
          "description" : "What kind of operation to perform",
          "enum" : [ "COLLABORATIONS", "COMMENTS", "EVENT_LOGS", "FILES", "FOLDERS", "GROUPS", "EVENTS", "SEARCH", "TASKS", "USERS" ],
          "type" : "string"
        },
        "method-name" : {
          "description" : "What sub operation to use for the selected operation",
          "type" : "string"
        },
        "access-token-cache" : {
          "description" : "Custom Access Token Cache for storing and retrieving access tokens.",
          "type" : "string"
        },
        "authentication-type" : {
          "description" : "The type of authentication for connection. Types of Authentication: STANDARD_AUTHENTICATION - OAuth 2.0 (3-legged) SERVER_AUTHENTICATION - OAuth 2.0 with JSON Web Tokens",
          "default" : "APP_USER_AUTHENTICATION",
          "type" : "string"
        },
        "client-id" : {
          "description" : "Box application client ID",
          "type" : "string"
        },
        "client-secret" : {
          "description" : "Box application client secret",
          "type" : "string"
        },
        "encryption-algorithm" : {
          "description" : "The type of encryption algorithm for JWT. Supported Algorithms: RSA_SHA_256 RSA_SHA_384 RSA_SHA_512",
          "default" : "RSA_SHA_256",
          "enum" : [ "RSA_SHA_256", "RSA_SHA_384", "RSA_SHA_512" ],
          "type" : "string"
        },
        "enterprise-id" : {
          "description" : "The enterprise ID to use for an App Enterprise.",
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "http-params" : {
          "description" : "Custom HTTP params for settings like proxy host",
          "type" : "string"
        },
        "in-body" : {
          "description" : "Sets the name of a parameter to be passed in the exchange In Body",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "max-cache-entries" : {
          "description" : "The maximum number of access tokens in cache.",
          "default" : "100",
          "type" : "integer"
        },
        "private-key-file" : {
          "description" : "The private key for generating the JWT signature.",
          "type" : "string"
        },
        "private-key-password" : {
          "description" : "The password for the private key.",
          "type" : "string"
        },
        "public-key-id" : {
          "description" : "The ID for public key for validating the JWT signature.",
          "type" : "string"
        },
        "ssl-context-parameters" : {
          "description" : "To configure security using SSLContextParameters.",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "user-id" : {
          "description" : "The user ID to use for an App User.",
          "type" : "string"
        },
        "user-name" : {
          "description" : "Box user name, MUST be provided",
          "type" : "string"
        },
        "user-password" : {
          "description" : "Box user password, MUST be provided if authSecureStorage is not set, or returns null on first call",
          "type" : "string"
        }
      }
    },
    "braintree" : {
      "type" : "object",
      "required" : [ "apiName", "methodName" ],
      "properties" : {
        "api-name" : {
          "description" : "What kind of operation to perform",
          "enum" : [ "ADD_ON", "ADDRESS", "CLIENT_TOKEN", "CREDIT_CARD_VERIFICATION", "CUSTOMER", "DISCOUNT", "DISPUTE", "DOCUMENT_UPLOAD", "MERCHANT_ACCOUNT", "PAYMENT_METHOD", "PAYMENT_METHOD_NONCE", "PLAN", "REPORT", "SETTLEMENT_BATCH_SUMMARY", "SUBSCRIPTION", "TRANSACTION", "WEBHOOK_NOTIFICATION" ],
          "type" : "string"
        },
        "method-name" : {
          "description" : "What sub operation to use for the selected operation",
          "enum" : [ "accept", "addFileEvidence", "addTextEvidence", "cancel", "cancelRelease", "cloneTransaction", "create", "createForCurrency", "credit", "delete", "fetchMerchantAccounts", "finalize", "find", "generate", "grant", "holdInEscrow", "parse", "refund", "releaseFromEscrow", "removeEvidence", "retryCharge", "revoke", "sale", "search", "submitForPartialSettlement", "submitForSettlement", "transactionLevelFees", "update", "updateDetails", "verify", "voidTransaction" ],
          "type" : "string"
        },
        "access-token" : {
          "description" : "The access token granted by a merchant to another in order to process transactions on their behalf. Used in place of environment, merchant id, public key and private key fields.",
          "type" : "string"
        },
        "environment" : {
          "description" : "The environment Either SANDBOX or PRODUCTION",
          "type" : "string"
        },
        "http-log-level" : {
          "description" : "Set logging level for http calls, see java.util.logging.Level",
          "enum" : [ "OFF", "SEVERE", "WARNING", "INFO", "CONFIG", "FINE", "FINER", "FINEST", "ALL" ],
          "type" : "string"
        },
        "http-log-name" : {
          "description" : "Set log category to use to log http calls.",
          "default" : "Braintree",
          "type" : "string"
        },
        "http-read-timeout" : {
          "description" : "Set read timeout for http calls.",
          "type" : "integer"
        },
        "in-body" : {
          "description" : "Sets the name of a parameter to be passed in the exchange In Body",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "log-handler-enabled" : {
          "description" : "Sets whether to enable the BraintreeLogHandler. It may be desirable to set this to 'false' where an existing JUL - SLF4J logger bridge is on the classpath. This option can also be configured globally on the BraintreeComponent.",
          "default" : "true",
          "type" : "boolean"
        },
        "merchant-id" : {
          "description" : "The merchant id provided by Braintree.",
          "type" : "string"
        },
        "private-key" : {
          "description" : "The private key provided by Braintree.",
          "type" : "string"
        },
        "proxy-host" : {
          "description" : "The proxy host",
          "type" : "string"
        },
        "proxy-port" : {
          "description" : "The proxy port",
          "type" : "integer"
        },
        "public-key" : {
          "description" : "The public key provided by Braintree.",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "browse" : {
      "type" : "object",
      "required" : [ "name" ],
      "properties" : {
        "name" : {
          "description" : "A name which can be any string to uniquely identify the endpoint",
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "caffeine-cache" : {
      "type" : "object",
      "required" : [ "cacheName" ],
      "properties" : {
        "cache-name" : {
          "description" : "the cache name",
          "type" : "string"
        },
        "action" : {
          "description" : "To configure the default cache action. If an action is set in the message header, then the operation from the header takes precedence.",
          "type" : "string"
        },
        "cache-loader" : {
          "description" : "To configure a CacheLoader in case of a LoadCache use",
          "type" : "string"
        },
        "create-cache-if-not-exist" : {
          "description" : "Configure if a cache need to be created if it does exist or can't be pre-configured.",
          "default" : "true",
          "type" : "boolean"
        },
        "eviction-type" : {
          "description" : "Set the eviction Type for this cache",
          "default" : "SIZE_BASED",
          "enum" : [ "size_based", "time_based" ],
          "type" : "string"
        },
        "expire-after-access-time" : {
          "description" : "Set the expire After Access Time in case of time based Eviction (in seconds)",
          "default" : "300",
          "type" : "integer"
        },
        "expire-after-write-time" : {
          "description" : "Set the expire After Access Write in case of time based Eviction (in seconds)",
          "default" : "300",
          "type" : "integer"
        },
        "initial-capacity" : {
          "description" : "Set the initial Capacity for the cache",
          "default" : "10000",
          "type" : "integer"
        },
        "key" : {
          "description" : "To configure the default action key. If a key is set in the message header, then the key from the header takes precedence.",
          "type" : "string"
        },
        "key-type" : {
          "description" : "The cache key type, default java.lang.Object",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "maximum-size" : {
          "description" : "Set the maximum size for the cache",
          "default" : "10000",
          "type" : "integer"
        },
        "removal-listener" : {
          "description" : "Set a specific removal Listener for the cache",
          "type" : "string"
        },
        "stats-counter" : {
          "description" : "Set a specific Stats Counter for the cache stats",
          "type" : "string"
        },
        "stats-enabled" : {
          "description" : "To enable stats on the cache",
          "default" : "false",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "value-type" : {
          "description" : "The cache value type, default java.lang.Object",
          "type" : "string"
        }
      }
    },
    "caffeine-loadcache" : {
      "type" : "object",
      "required" : [ "cacheName" ],
      "properties" : {
        "cache-name" : {
          "description" : "the cache name",
          "type" : "string"
        },
        "action" : {
          "description" : "To configure the default cache action. If an action is set in the message header, then the operation from the header takes precedence.",
          "type" : "string"
        },
        "cache-loader" : {
          "description" : "To configure a CacheLoader in case of a LoadCache use",
          "type" : "string"
        },
        "create-cache-if-not-exist" : {
          "description" : "Configure if a cache need to be created if it does exist or can't be pre-configured.",
          "default" : "true",
          "type" : "boolean"
        },
        "eviction-type" : {
          "description" : "Set the eviction Type for this cache",
          "default" : "SIZE_BASED",
          "enum" : [ "size_based", "time_based" ],
          "type" : "string"
        },
        "expire-after-access-time" : {
          "description" : "Set the expire After Access Time in case of time based Eviction (in seconds)",
          "default" : "300",
          "type" : "integer"
        },
        "expire-after-write-time" : {
          "description" : "Set the expire After Access Write in case of time based Eviction (in seconds)",
          "default" : "300",
          "type" : "integer"
        },
        "initial-capacity" : {
          "description" : "Set the initial Capacity for the cache",
          "default" : "10000",
          "type" : "integer"
        },
        "key" : {
          "description" : "To configure the default action key. If a key is set in the message header, then the key from the header takes precedence.",
          "type" : "string"
        },
        "key-type" : {
          "description" : "The cache key type, default java.lang.Object",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "maximum-size" : {
          "description" : "Set the maximum size for the cache",
          "default" : "10000",
          "type" : "integer"
        },
        "removal-listener" : {
          "description" : "Set a specific removal Listener for the cache",
          "type" : "string"
        },
        "stats-counter" : {
          "description" : "Set a specific Stats Counter for the cache stats",
          "type" : "string"
        },
        "stats-enabled" : {
          "description" : "To enable stats on the cache",
          "default" : "false",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "value-type" : {
          "description" : "The cache value type, default java.lang.Object",
          "type" : "string"
        }
      }
    },
    "chatscript" : {
      "type" : "object",
      "required" : [ "botName", "host" ],
      "properties" : {
        "bot-name" : {
          "description" : "Name of the Bot in CS to converse with",
          "type" : "string"
        },
        "host" : {
          "description" : "Hostname or IP of the server on which CS server is running",
          "type" : "string"
        },
        "port" : {
          "description" : "Port on which ChatScript is listening to",
          "default" : "1024",
          "type" : "integer"
        },
        "chat-user-name" : {
          "description" : "Username who initializes the CS conversation. To be set when chat is initialized from camel route",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "reset-chat" : {
          "description" : "Issues :reset command to start a new conversation everytime",
          "default" : "false",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "chunk" : {
      "type" : "object",
      "required" : [ "resourceUri" ],
      "properties" : {
        "resource-uri" : {
          "description" : "Path to the resource. You can prefix with: classpath, file, http, ref, or bean. classpath, file and http loads the resource using these protocols (classpath is default). ref will lookup the resource in the registry. bean will call a method on a bean to be used as the resource. For bean you can specify the method name after dot, eg bean:myBean.myMethod.",
          "type" : "string"
        },
        "allow-context-map-all" : {
          "description" : "Sets whether the context map should allow access to all details. By default only the message body and headers can be accessed. This option can be enabled for full access to the current Exchange and CamelContext. Doing so impose a potential security risk as this opens access to the full power of CamelContext API.",
          "default" : "false",
          "type" : "boolean"
        },
        "allow-template-from-header" : {
          "description" : "Whether to allow to use resource template from header or not (default false). Enabling this allows to specify dynamic templates via message header. However this can be seen as a potential security vulnerability if the header is coming from a malicious user, so use this with care.",
          "default" : "false",
          "type" : "boolean"
        },
        "content-cache" : {
          "description" : "Sets whether to use resource content cache or not",
          "default" : "false",
          "type" : "boolean"
        },
        "encoding" : {
          "description" : "Define the encoding of the body",
          "type" : "string"
        },
        "extension" : {
          "description" : "Define the file extension of the template",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "theme-folder" : {
          "description" : "Define the themes folder to scan",
          "type" : "string"
        },
        "theme-layer" : {
          "description" : "Define the theme layer to elaborate",
          "type" : "string"
        },
        "theme-subfolder" : {
          "description" : "Define the themes subfolder to scan",
          "type" : "string"
        }
      }
    },
    "class" : {
      "type" : "object",
      "required" : [ "beanName" ],
      "properties" : {
        "bean-name" : {
          "description" : "Sets the name of the bean to invoke",
          "type" : "string"
        },
        "cache" : {
          "description" : "Use scope option instead.",
          "type" : "boolean"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "method" : {
          "description" : "Sets the name of the method to invoke on the bean",
          "type" : "string"
        },
        "parameters" : {
          "description" : "Used for configuring additional properties on the bean",
          "type" : "string"
        },
        "scope" : {
          "description" : "Scope of bean. When using singleton scope (default) the bean is created or looked up only once and reused for the lifetime of the endpoint. The bean should be thread-safe in case concurrent threads is calling the bean at the same time. When using request scope the bean is created or looked up once per request (exchange). This can be used if you want to store state on a bean while processing a request and you want to call the same bean instance multiple times while processing the request. The bean does not have to be thread-safe as the instance is only called from the same request. When using prototype scope, then the bean will be looked up or created per call. However in case of lookup then this is delegated to the bean registry such as Spring or CDI (if in use), which depends on their configuration can act as either singleton or prototype scope. so when using prototype then this depends on the delegated registry.",
          "default" : "Singleton",
          "enum" : [ "Singleton", "Request", "Prototype" ],
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "cm-sms" : {
      "type" : "object",
      "required" : [ "host", "defaultFrom", "productToken" ],
      "properties" : {
        "host" : {
          "description" : "SMS Provider HOST with scheme",
          "type" : "string"
        },
        "default-from" : {
          "description" : "This is the sender name. The maximum length is 11 characters.",
          "type" : "string"
        },
        "default-max-number-of-parts" : {
          "description" : "If it is a multipart message forces the max number. Message can be truncated. Technically the gateway will first check if a message is larger than 160 characters, if so, the message will be cut into multiple 153 characters parts limited by these parameters.",
          "default" : "8",
          "type" : "integer"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "product-token" : {
          "description" : "The unique token to use",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "test-connection-on-startup" : {
          "description" : "Whether to test the connection to the SMS Gateway on startup",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "cmis" : {
      "type" : "object",
      "required" : [ "cmsUrl" ],
      "properties" : {
        "cms-url" : {
          "description" : "URL to the cmis repository",
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "page-size" : {
          "description" : "Number of nodes to retrieve per page",
          "default" : "100",
          "type" : "integer"
        },
        "password" : {
          "description" : "Password for the cmis repository",
          "type" : "string"
        },
        "query" : {
          "description" : "The cmis query to execute against the repository. If not specified, the consumer will retrieve every node from the content repository by iterating the content tree recursively",
          "type" : "string"
        },
        "query-mode" : {
          "description" : "If true, will execute the cmis query from the message body and return result, otherwise will create a node in the cmis repository",
          "default" : "false",
          "type" : "boolean"
        },
        "read-content" : {
          "description" : "If set to true, the content of document node will be retrieved in addition to the properties",
          "default" : "false",
          "type" : "boolean"
        },
        "read-count" : {
          "description" : "Max number of nodes to read",
          "type" : "integer"
        },
        "repository-id" : {
          "description" : "The Id of the repository to use. If not specified the first available repository is used",
          "type" : "string"
        },
        "session-facade-factory" : {
          "description" : "To use a custom CMISSessionFacadeFactory to create the CMISSessionFacade instances",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "username" : {
          "description" : "Username for the cmis repository",
          "type" : "string"
        }
      }
    },
    "coap" : {
      "type" : "object",
      "properties" : {
        "uri" : {
          "description" : "The URI for the CoAP endpoint",
          "type" : "string"
        },
        "alias" : {
          "description" : "Sets the alias used to query the KeyStore for the private key and certificate. This parameter is used when we are enabling TLS with certificates on the service side, and similarly on the client side when TLS is used with certificates and client authentication. If the parameter is not specified then the default behavior is to use the first alias in the keystore that contains a key entry. This configuration parameter does not apply to configuring TLS via a Raw Public Key or a Pre-Shared Key.",
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "cipher-suites" : {
          "description" : "Sets the cipherSuites String. This is a comma separated String of ciphersuites to configure. If it is not specified, then it falls back to getting the ciphersuites from the sslContextParameters object.",
          "type" : "string"
        },
        "client-authentication" : {
          "description" : "Sets the configuration options for server-side client-authentication requirements. The value must be one of NONE, WANT, REQUIRE. If this value is not specified, then it falls back to checking the sslContextParameters.getServerParameters().getClientAuthentication() value.",
          "type" : "string"
        },
        "coap-method-restrict" : {
          "description" : "Comma separated list of methods that the CoAP consumer will bind to. The default is to bind to all methods (DELETE, GET, POST, PUT).",
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "private-key" : {
          "description" : "Set the configured private key for use with Raw Public Key.",
          "type" : "string"
        },
        "psk-store" : {
          "description" : "Set the PskStore to use for pre-shared key.",
          "type" : "string"
        },
        "public-key" : {
          "description" : "Set the configured public key for use with Raw Public Key.",
          "type" : "string"
        },
        "recommended-cipher-suites-only" : {
          "description" : "The CBC cipher suites are not recommended. If you want to use them, you first need to set the recommendedCipherSuitesOnly option to false.",
          "default" : "true",
          "type" : "boolean"
        },
        "ssl-context-parameters" : {
          "description" : "Set the SSLContextParameters object for setting up TLS. This is required for coapstcp, and for coaps when we are using certificates for TLS (as opposed to RPK or PKS).",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "trusted-rpk-store" : {
          "description" : "Set the TrustedRpkStore to use to determine trust in raw public keys.",
          "type" : "string"
        }
      }
    },
    "coaps" : {
      "type" : "object",
      "$ref" : "#/definitions/coap"
    },
    "coap+tcp" : {
      "type" : "object",
      "$ref" : "#/definitions/coap"
    },
    "coaps+tcp" : {
      "type" : "object",
      "$ref" : "#/definitions/coap"
    },
    "cometd" : {
      "type" : "object",
      "required" : [ "channelName", "host", "port" ],
      "properties" : {
        "channel-name" : {
          "description" : "The channelName represents a topic that can be subscribed to by the Camel endpoints.",
          "type" : "string"
        },
        "host" : {
          "description" : "Hostname",
          "type" : "string"
        },
        "port" : {
          "description" : "Host port number",
          "type" : "integer"
        },
        "allowed-origins" : {
          "description" : "The origins domain that support to cross, if the crosssOriginFilterOn is true",
          "default" : "*",
          "type" : "string"
        },
        "base-resource" : {
          "description" : "The root directory for the web resources or classpath. Use the protocol file: or classpath: depending if you want that the component loads the resource from file system or classpath. Classpath is required for OSGI deployment where the resources are packaged in the jar",
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "cross-origin-filter-on" : {
          "description" : "If true, the server will support for cross-domain filtering",
          "default" : "false",
          "type" : "boolean"
        },
        "disconnect-local-session" : {
          "description" : "Whether to disconnect local sessions after publishing a message to its channel. Disconnecting local session is needed as they are not swept by default by CometD, and therefore you can run out of memory.",
          "default" : "false",
          "type" : "boolean"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "filter-path" : {
          "description" : "The filterPath will be used by the CrossOriginFilter, if the crosssOriginFilterOn is true",
          "type" : "string"
        },
        "interval" : {
          "description" : "The client side poll timeout in milliseconds. How long a client will wait between reconnects",
          "type" : "integer"
        },
        "json-commented" : {
          "description" : "If true, the server will accept JSON wrapped in a comment and will generate JSON wrapped in a comment. This is a defence against Ajax Hijacking.",
          "default" : "true",
          "type" : "boolean"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "log-level" : {
          "description" : "Logging level. 0=none, 1=info, 2=debug.",
          "default" : "1",
          "enum" : [ "0", "1", "2" ],
          "type" : "integer"
        },
        "max-interval" : {
          "description" : "The max client side poll timeout in milliseconds. A client will be removed if a connection is not received in this time.",
          "default" : "30000",
          "type" : "integer"
        },
        "multi-frame-interval" : {
          "description" : "The client side poll timeout, if multiple connections are detected from the same browser.",
          "default" : "1500",
          "type" : "integer"
        },
        "session-headers-enabled" : {
          "description" : "Whether to include the server session headers in the Camel message when creating a Camel Message for incoming requests.",
          "default" : "false",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "timeout" : {
          "description" : "The server side poll timeout in milliseconds. This is how long the server will hold a reconnect request before responding.",
          "default" : "240000",
          "type" : "integer"
        }
      }
    },
    "cometds" : {
      "type" : "object",
      "$ref" : "#/definitions/cometd"
    },
    "consul" : {
      "type" : "object",
      "required" : [ "apiEndpoint" ],
      "properties" : {
        "api-endpoint" : {
          "description" : "The API endpoint",
          "type" : "string"
        },
        "acl-token" : {
          "description" : "Sets the ACL token to be used with Consul",
          "type" : "string"
        },
        "action" : {
          "description" : "The default action. Can be overridden by CamelConsulAction",
          "type" : "string"
        },
        "block-seconds" : {
          "description" : "The second to wait for a watch event, default 10 seconds",
          "default" : "10",
          "type" : "integer"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "connect-timeout" : {
          "description" : "Connect timeout for OkHttpClient",
          "type" : "string"
        },
        "connect-timeout-millis" : {
          "description" : "Connect timeout for OkHttpClient. Deprecation note: Use connectTimeout instead",
          "type" : "integer"
        },
        "consistency-mode" : {
          "description" : "The consistencyMode used for queries, default ConsistencyMode.DEFAULT",
          "default" : "DEFAULT",
          "enum" : [ "DEFAULT", "STALE", "CONSISTENT" ],
          "type" : "string"
        },
        "consul-client" : {
          "description" : "Reference to a com.orbitz.consul.Consul in the registry.",
          "type" : "string"
        },
        "datacenter" : {
          "description" : "The data center",
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "first-index" : {
          "description" : "The first index for watch for, default 0",
          "default" : "0",
          "type" : "string"
        },
        "key" : {
          "description" : "The default key. Can be overridden by CamelConsulKey",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "near-node" : {
          "description" : "The near node to use for queries.",
          "type" : "string"
        },
        "node-meta" : {
          "description" : "The note meta-data to use for queries.",
          "type" : "string"
        },
        "password" : {
          "description" : "Sets the password to be used for basic authentication",
          "type" : "string"
        },
        "ping-instance" : {
          "description" : "Configure if the AgentClient should attempt a ping before returning the Consul instance",
          "default" : "true",
          "type" : "boolean"
        },
        "read-timeout" : {
          "description" : "Read timeout for OkHttpClient",
          "type" : "string"
        },
        "read-timeout-millis" : {
          "description" : "Read timeout for OkHttpClient. Deprecation note: Use readTimeout instead",
          "type" : "integer"
        },
        "recursive" : {
          "description" : "Recursively watch, default false",
          "default" : "false",
          "type" : "boolean"
        },
        "ssl-context-parameters" : {
          "description" : "SSL configuration using an org.apache.camel.support.jsse.SSLContextParameters instance.",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "tags" : {
          "description" : "Set tags. You can separate multiple tags by comma.",
          "type" : "string"
        },
        "url" : {
          "description" : "The Consul agent URL",
          "type" : "string"
        },
        "user-name" : {
          "description" : "Sets the username to be used for basic authentication",
          "type" : "string"
        },
        "value-as-string" : {
          "description" : "Default to transform values retrieved from Consul i.e. on KV endpoint to string.",
          "default" : "false",
          "type" : "boolean"
        },
        "write-timeout" : {
          "description" : "Write timeout for OkHttpClient",
          "type" : "string"
        },
        "write-timeout-millis" : {
          "description" : "Write timeout for OkHttpClient. Deprecation note: Use writeTimeout instead",
          "type" : "string"
        }
      }
    },
    "controlbus" : {
      "type" : "object",
      "required" : [ "command" ],
      "properties" : {
        "command" : {
          "description" : "Command can be either route or language",
          "enum" : [ "route", "language" ],
          "type" : "string"
        },
        "language" : {
          "description" : "Allows you to specify the name of a Language to use for evaluating the message body. If there is any result from the evaluation, then the result is put in the message body.",
          "enum" : [ "bean", "constant", "el", "exchangeProperty", "file", "groovy", "header", "jsonpath", "mvel", "ognl", "ref", "simple", "spel", "sql", "terser", "tokenize", "xpath", "xquery", "xtokenize" ],
          "type" : "string"
        },
        "action" : {
          "description" : "To denote an action that can be either: start, stop, or status. To either start or stop a route, or to get the status of the route as output in the message body. You can use suspend and resume from Camel 2.11.1 onwards to either suspend or resume a route. And from Camel 2.11.1 onwards you can use stats to get performance statics returned in XML format; the routeId option can be used to define which route to get the performance stats for, if routeId is not defined, then you get statistics for the entire CamelContext. The restart action will restart the route.",
          "enum" : [ "start", "stop", "suspend", "resume", "restart", "status", "stats" ],
          "type" : "string"
        },
        "async" : {
          "description" : "Whether to execute the control bus task asynchronously. Important: If this option is enabled, then any result from the task is not set on the Exchange. This is only possible if executing tasks synchronously.",
          "default" : "false",
          "type" : "boolean"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "logging-level" : {
          "description" : "Logging level used for logging when task is done, or if any exceptions occurred during processing the task.",
          "default" : "INFO",
          "enum" : [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ],
          "type" : "string"
        },
        "restart-delay" : {
          "description" : "The delay in millis to use when restarting a route.",
          "default" : "1000",
          "type" : "integer"
        },
        "route-id" : {
          "description" : "To specify a route by its id. The special keyword current indicates the current route.",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "corda" : {
      "type" : "object",
      "required" : [ "node" ],
      "properties" : {
        "node" : {
          "description" : "The url for the corda node",
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "contract-state-class" : {
          "description" : "A contract state (or just state) contains opaque data used by a contract program. It can be thought of as a disk file that the program can use to persist data across transactions. States are immutable: once created they are never updated, instead, any changes must generate a new successor state. States can be updated (consumed) only once: the notary is responsible for ensuring there is no double spending by only signing a transaction if the input states are all free.",
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "flow-logic-arguments" : {
          "description" : "Start the given flow with the given arguments, returning an Observable with a single observation of the result of running the flow. The flowLogicClass must be annotated with net.corda.core.flows.StartableByRPC.",
          "type" : "string"
        },
        "flow-logic-class" : {
          "description" : "Start the given flow with the given arguments, returning an Observable with a single observation of the result of running the flow. The flowLogicClass must be annotated with net.corda.core.flows.StartableByRPC.",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "operation" : {
          "description" : "Operation to use",
          "type" : "string"
        },
        "page-specification" : {
          "description" : "PageSpecification allows specification of a page number (starting from 1) and page size (defaulting to 200 with a maximum page size of (Integer.MAX_INT) Note: we default the page number to 200 to enable queries without requiring a page specification but enabling detection of large results sets that fall out of the 200 requirement. Max page size should be used with extreme caution as results may exceed your JVM memory footprint.",
          "default" : "200",
          "type" : "string"
        },
        "password" : {
          "description" : "Password for login",
          "type" : "string"
        },
        "process-snapshot" : {
          "description" : "Whether to process snapshots or not",
          "default" : "true",
          "type" : "boolean"
        },
        "query-criteria" : {
          "description" : "QueryCriteria assumes underlying schema tables are correctly indexed for performance.",
          "type" : "string"
        },
        "sort" : {
          "description" : "Sort allows specification of a set of entity attribute names and their associated directionality and null handling, to be applied upon processing a query specification.",
          "enum" : [ "ASC", "DESC" ],
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "username" : {
          "description" : "Username for login",
          "type" : "string"
        }
      }
    },
    "couchbase" : {
      "type" : "object",
      "required" : [ "hostname", "protocol", "bucket" ],
      "properties" : {
        "hostname" : {
          "description" : "The hostname to use",
          "type" : "string"
        },
        "port" : {
          "description" : "The port number to use",
          "default" : "8091",
          "type" : "integer"
        },
        "protocol" : {
          "description" : "The protocol to use",
          "type" : "string"
        },
        "additional-hosts" : {
          "description" : "The additional hosts",
          "type" : "string"
        },
        "auto-start-id-for-inserts" : {
          "description" : "Define if we want an autostart Id when we are doing an insert operation",
          "default" : "false",
          "type" : "boolean"
        },
        "backoff-error-threshold" : {
          "description" : "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-idle-threshold" : {
          "description" : "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-multiplier" : {
          "description" : "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
          "type" : "integer"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "bucket" : {
          "description" : "The bucket to use",
          "type" : "string"
        },
        "collection" : {
          "description" : "The collection to use",
          "type" : "string"
        },
        "connect-timeout" : {
          "description" : "Define the timeoutconnect in milliseconds",
          "default" : "2500",
          "type" : "string"
        },
        "consumer-processed-strategy" : {
          "description" : "Define the consumer Processed strategy to use",
          "default" : "none",
          "type" : "string"
        },
        "delay" : {
          "description" : "Milliseconds before the next poll.",
          "default" : "500",
          "type" : "integer"
        },
        "descending" : {
          "description" : "Define if this operation is descending or not",
          "default" : "false",
          "type" : "boolean"
        },
        "design-document-name" : {
          "description" : "The design document name to use",
          "default" : "beer",
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "full-document" : {
          "description" : "If true consumer will return complete document instead data defined in view",
          "default" : "false",
          "type" : "boolean"
        },
        "greedy" : {
          "description" : "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
          "default" : "false",
          "type" : "boolean"
        },
        "initial-delay" : {
          "description" : "Milliseconds before the first poll starts.",
          "default" : "1000",
          "type" : "integer"
        },
        "key" : {
          "description" : "The key to use",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "limit" : {
          "description" : "The output limit to use",
          "default" : "-1",
          "type" : "integer"
        },
        "operation" : {
          "description" : "The operation to do",
          "default" : "CCB_PUT",
          "type" : "string"
        },
        "password" : {
          "description" : "The password to use",
          "type" : "string"
        },
        "persist-to" : {
          "description" : "Where to persist the data",
          "default" : "0",
          "type" : "integer"
        },
        "poll-strategy" : {
          "description" : "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
          "type" : "string"
        },
        "producer-retry-attempts" : {
          "description" : "Define the number of retry attempts",
          "default" : "2",
          "type" : "integer"
        },
        "producer-retry-pause" : {
          "description" : "Define the retry pause between different attempts",
          "default" : "5000",
          "type" : "integer"
        },
        "query-timeout" : {
          "description" : "Define the operation timeout in milliseconds",
          "default" : "2500",
          "type" : "string"
        },
        "range-end-key" : {
          "description" : "Define a range for the end key",
          "type" : "string"
        },
        "range-start-key" : {
          "description" : "Define a range for the start key",
          "type" : "string"
        },
        "repeat-count" : {
          "description" : "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
          "default" : "0",
          "type" : "integer"
        },
        "replicate-to" : {
          "description" : "Where to replicate the data",
          "default" : "0",
          "type" : "integer"
        },
        "run-logging-level" : {
          "description" : "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
          "default" : "TRACE",
          "enum" : [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ],
          "type" : "string"
        },
        "scheduled-executor-service" : {
          "description" : "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
          "type" : "string"
        },
        "scheduler" : {
          "description" : "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
          "default" : "none",
          "type" : "string"
        },
        "scheduler-properties" : {
          "description" : "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
          "type" : "string"
        },
        "scope" : {
          "description" : "The scope to use",
          "type" : "string"
        },
        "send-empty-message-when-idle" : {
          "description" : "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
          "default" : "false",
          "type" : "boolean"
        },
        "skip" : {
          "description" : "Define the skip to use",
          "default" : "-1",
          "type" : "integer"
        },
        "start-scheduler" : {
          "description" : "Whether the scheduler should be auto started.",
          "default" : "true",
          "type" : "boolean"
        },
        "starting-id-for-inserts-from" : {
          "description" : "Define the starting Id where we are doing an insert operation",
          "type" : "integer"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "time-unit" : {
          "description" : "Time unit for initialDelay and delay options.",
          "default" : "MILLISECONDS",
          "enum" : [ "NANOSECONDS", "MICROSECONDS", "MILLISECONDS", "SECONDS", "MINUTES", "HOURS", "DAYS" ],
          "type" : "string"
        },
        "use-fixed-delay" : {
          "description" : "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
          "default" : "true",
          "type" : "boolean"
        },
        "username" : {
          "description" : "The username to use",
          "type" : "string"
        },
        "view-name" : {
          "description" : "The view name to use",
          "default" : "brewery_beers",
          "type" : "string"
        }
      }
    },
    "couchdb" : {
      "type" : "object",
      "required" : [ "database", "hostname", "protocol" ],
      "properties" : {
        "database" : {
          "description" : "Name of the database to use",
          "type" : "string"
        },
        "hostname" : {
          "description" : "Hostname of the running couchdb instance",
          "type" : "string"
        },
        "port" : {
          "description" : "Port number for the running couchdb instance",
          "default" : "5984",
          "type" : "integer"
        },
        "protocol" : {
          "description" : "The protocol to use for communicating with the database.",
          "enum" : [ "http", "https" ],
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "create-database" : {
          "description" : "Creates the database if it does not already exist",
          "default" : "false",
          "type" : "boolean"
        },
        "deletes" : {
          "description" : "Document deletes are published as events",
          "default" : "true",
          "type" : "boolean"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "heartbeat" : {
          "description" : "How often to send an empty message to keep socket alive in millis",
          "default" : "30000",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "password" : {
          "description" : "Password for authenticated databases",
          "type" : "string"
        },
        "since" : {
          "description" : "Start tracking changes immediately after the given update sequence. The default, null, will start monitoring from the latest sequence.",
          "type" : "string"
        },
        "style" : {
          "description" : "Specifies how many revisions are returned in the changes array. The default, main_only, will only return the current winning revision; all_docs will return all leaf revisions (including conflicts and deleted former conflicts.)",
          "default" : "main_only",
          "enum" : [ "all_docs", "main_only" ],
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "updates" : {
          "description" : "Document inserts/updates are published as events",
          "default" : "true",
          "type" : "boolean"
        },
        "username" : {
          "description" : "Username in case of authenticated databases",
          "type" : "string"
        }
      }
    },
    "cql" : {
      "type" : "object",
      "properties" : {
        "bean-ref" : {
          "description" : "beanRef is defined using bean:id",
          "type" : "string"
        },
        "hosts" : {
          "description" : "Hostname(s) cassansdra server(s). Multiple hosts can be separated by comma.",
          "type" : "string"
        },
        "keyspace" : {
          "description" : "Keyspace to use",
          "type" : "string"
        },
        "port" : {
          "description" : "Port number of cassansdra server(s)",
          "type" : "integer"
        },
        "backoff-error-threshold" : {
          "description" : "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-idle-threshold" : {
          "description" : "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-multiplier" : {
          "description" : "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
          "type" : "integer"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "cluster-name" : {
          "description" : "Cluster name",
          "type" : "string"
        },
        "consistency-level" : {
          "description" : "Consistency level to use",
          "enum" : [ "ANY", "ONE", "TWO", "THREE", "QUORUM", "ALL", "LOCAL_ONE", "LOCAL_QUORUM", "EACH_QUORUM", "SERIAL", "LOCAL_SERIAL" ],
          "type" : "string"
        },
        "cql" : {
          "description" : "CQL query to perform. Can be overridden with the message header with key CamelCqlQuery.",
          "type" : "string"
        },
        "datacenter" : {
          "description" : "Datacenter to use",
          "default" : "datacenter1",
          "type" : "string"
        },
        "delay" : {
          "description" : "Milliseconds before the next poll.",
          "default" : "500",
          "type" : "integer"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "greedy" : {
          "description" : "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
          "default" : "false",
          "type" : "boolean"
        },
        "initial-delay" : {
          "description" : "Milliseconds before the first poll starts.",
          "default" : "1000",
          "type" : "integer"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "load-balancing-policy-class" : {
          "description" : "To use a specific LoadBalancingPolicyClass",
          "type" : "string"
        },
        "password" : {
          "description" : "Password for session authentication",
          "type" : "string"
        },
        "poll-strategy" : {
          "description" : "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
          "type" : "string"
        },
        "prepare-statements" : {
          "description" : "Whether to use PreparedStatements or regular Statements",
          "default" : "true",
          "type" : "boolean"
        },
        "repeat-count" : {
          "description" : "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
          "default" : "0",
          "type" : "integer"
        },
        "result-set-conversion-strategy" : {
          "description" : "To use a custom class that implements logic for converting ResultSet into message body ALL, ONE, LIMIT_10, LIMIT_100...",
          "type" : "string"
        },
        "run-logging-level" : {
          "description" : "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
          "default" : "TRACE",
          "enum" : [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ],
          "type" : "string"
        },
        "scheduled-executor-service" : {
          "description" : "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
          "type" : "string"
        },
        "scheduler" : {
          "description" : "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
          "default" : "none",
          "type" : "string"
        },
        "scheduler-properties" : {
          "description" : "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
          "type" : "string"
        },
        "send-empty-message-when-idle" : {
          "description" : "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
          "default" : "false",
          "type" : "boolean"
        },
        "session" : {
          "description" : "To use the Session instance (you would normally not use this option)",
          "type" : "string"
        },
        "start-scheduler" : {
          "description" : "Whether the scheduler should be auto started.",
          "default" : "true",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "time-unit" : {
          "description" : "Time unit for initialDelay and delay options.",
          "default" : "MILLISECONDS",
          "enum" : [ "NANOSECONDS", "MICROSECONDS", "MILLISECONDS", "SECONDS", "MINUTES", "HOURS", "DAYS" ],
          "type" : "string"
        },
        "use-fixed-delay" : {
          "description" : "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
          "default" : "true",
          "type" : "boolean"
        },
        "username" : {
          "description" : "Username for session authentication",
          "type" : "string"
        }
      }
    },
    "cron" : {
      "type" : "object",
      "required" : [ "name", "schedule" ],
      "properties" : {
        "name" : {
          "description" : "The name of the cron trigger",
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "schedule" : {
          "description" : "A cron expression that will be used to generate events",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "crypto" : {
      "type" : "object",
      "required" : [ "cryptoOperation", "name" ],
      "properties" : {
        "crypto-operation" : {
          "description" : "Set the Crypto operation from that supplied after the crypto scheme in the endpoint uri e.g. crypto:sign sets sign as the operation.",
          "enum" : [ "sign", "verify" ],
          "type" : "string"
        },
        "name" : {
          "description" : "The logical name of this operation.",
          "type" : "string"
        },
        "algorithm" : {
          "description" : "Sets the JCE name of the Algorithm that should be used for the signer.",
          "default" : "SHA256withRSA",
          "type" : "string"
        },
        "alias" : {
          "description" : "Sets the alias used to query the KeyStore for keys and {link java.security.cert.Certificate Certificates} to be used in signing and verifying exchanges. This value can be provided at runtime via the message header org.apache.camel.component.crypto.DigitalSignatureConstants#KEYSTORE_ALIAS",
          "type" : "string"
        },
        "buffer-size" : {
          "description" : "Set the size of the buffer used to read in the Exchange payload data.",
          "default" : "2048",
          "type" : "integer"
        },
        "certificate" : {
          "description" : "Set the Certificate that should be used to verify the signature in the exchange based on its payload.",
          "type" : "string"
        },
        "certificate-name" : {
          "description" : "Sets the reference name for a PrivateKey that can be found in the registry.",
          "type" : "string"
        },
        "clear-headers" : {
          "description" : "Determines if the Signature specific headers be cleared after signing and verification. Defaults to true, and should only be made otherwise at your extreme peril as vital private information such as Keys and passwords may escape if unset.",
          "default" : "true",
          "type" : "boolean"
        },
        "key-store-parameters" : {
          "description" : "Sets the KeyStore that can contain keys and Certficates for use in signing and verifying exchanges based on the given KeyStoreParameters. A KeyStore is typically used with an alias, either one supplied in the Route definition or dynamically via the message header CamelSignatureKeyStoreAlias. If no alias is supplied and there is only a single entry in the Keystore, then this single entry will be used.",
          "type" : "string"
        },
        "keystore" : {
          "description" : "Sets the KeyStore that can contain keys and Certficates for use in signing and verifying exchanges. A KeyStore is typically used with an alias, either one supplied in the Route definition or dynamically via the message header CamelSignatureKeyStoreAlias. If no alias is supplied and there is only a single entry in the Keystore, then this single entry will be used.",
          "type" : "string"
        },
        "keystore-name" : {
          "description" : "Sets the reference name for a Keystore that can be found in the registry.",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "password" : {
          "description" : "Sets the password used to access an aliased PrivateKey in the KeyStore.",
          "type" : "string"
        },
        "private-key" : {
          "description" : "Set the PrivateKey that should be used to sign the exchange",
          "type" : "string"
        },
        "private-key-name" : {
          "description" : "Sets the reference name for a PrivateKey that can be found in the registry.",
          "type" : "string"
        },
        "provider" : {
          "description" : "Set the id of the security provider that provides the configured Signature algorithm.",
          "type" : "string"
        },
        "public-key" : {
          "description" : "Set the PublicKey that should be used to verify the signature in the exchange.",
          "type" : "string"
        },
        "public-key-name" : {
          "description" : "references that should be resolved when the context changes",
          "type" : "string"
        },
        "secure-random" : {
          "description" : "Set the SecureRandom used to initialize the Signature service",
          "type" : "string"
        },
        "secure-random-name" : {
          "description" : "Sets the reference name for a SecureRandom that can be found in the registry.",
          "type" : "string"
        },
        "signature-header-name" : {
          "description" : "Set the name of the message header that should be used to store the base64 encoded signature. This defaults to 'CamelDigitalSignature'",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "crypto-cms" : {
      "type" : "object",
      "required" : [ "cryptoOperation", "name" ],
      "properties" : {
        "crypto-operation" : {
          "description" : "Set the Crypto operation from that supplied after the crypto scheme in the endpoint uri e.g. crypto-cms:sign sets sign as the operation. Possible values: sign, verify, encrypt, or decrypt.",
          "enum" : [ "sign", "verify", "encrypt", "decrypt" ],
          "type" : "string"
        },
        "name" : {
          "description" : "The name part in the URI can be chosen by the user to distinguish between different signer/verifier/encryptor/decryptor endpoints within the camel context.",
          "type" : "string"
        },
        "content-encryption-algorithm" : {
          "description" : "Encryption algorithm, for example DESede/CBC/PKCS5Padding. Further possible values: DESede/CBC/PKCS5Padding, AES/CBC/PKCS5Padding, Camellia/CBC/PKCS5Padding, CAST5/CBC/PKCS5Padding.",
          "enum" : [ "AES/CBC/PKCS5Padding", "DESede/CBC/PKCS5Padding", "Camellia/CBC/PKCS5Padding", "CAST5/CBC/PKCS5Padding" ],
          "type" : "string"
        },
        "from-base64" : {
          "description" : "If true then the CMS message is base 64 encoded and must be decoded during the processing. Default value is false.",
          "default" : "false",
          "type" : "boolean"
        },
        "include-content" : {
          "description" : "Indicates whether the signed content should be included into the Signed Data instance. If false then a detached Signed Data instance is created in the header CamelCryptoCmsSignedData.",
          "default" : "true",
          "type" : "boolean"
        },
        "key-store" : {
          "description" : "Keystore which contains signer private keys, verifier public keys, encryptor public keys, decryptor private keys depending on the operation. Use either this parameter or the parameter 'keyStoreParameters'.",
          "type" : "string"
        },
        "key-store-parameters" : {
          "description" : "Keystore containing signer private keys, verifier public keys, encryptor public keys, decryptor private keys depending on the operation. Use either this parameter or the parameter 'keystore'.",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "originator-information-provider" : {
          "description" : "Provider for the originator info. See https://tools.ietf.org/html/rfc5652#section-6.1. The default value is null.",
          "type" : "string"
        },
        "password" : {
          "description" : "Sets the password of the private keys. It is assumed that all private keys in the keystore have the same password. If not set then it is assumed that the password of the private keys is given by the keystore password given in the KeyStoreParameters.",
          "type" : "string"
        },
        "recipient" : {
          "description" : "Recipient Info: reference to a bean which implements the interface org.apache.camel.component.crypto.cms.api.TransRecipientInfo",
          "type" : "string"
        },
        "secret-key-length" : {
          "description" : "Key length for the secret symmetric key used for the content encryption. Only used if the specified content-encryption algorithm allows keys of different sizes. If contentEncryptionAlgorithm=AES/CBC/PKCS5Padding or Camellia/CBC/PKCS5Padding then 128; if contentEncryptionAlgorithm=DESede/CBC/PKCS5Padding then 192, 128; if strong encryption is enabled then for AES/CBC/PKCS5Padding and Camellia/CBC/PKCS5Padding also the key lengths 192 and 256 are possible.",
          "type" : "integer"
        },
        "signed-data-header-base64" : {
          "description" : "Indicates whether the value in the header CamelCryptoCmsSignedData is base64 encoded. Default value is false. Only relevant for detached signatures. In the detached signature case, the header contains the Signed Data object.",
          "default" : "false",
          "type" : "boolean"
        },
        "signer" : {
          "description" : "Signer information: reference to bean(s) which implements org.apache.camel.component.crypto.cms.api.SignerInfo. Multiple values can be separated by comma",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "to-base64" : {
          "description" : "Indicates whether the Signed Data or Enveloped Data instance shall be base 64 encoded. Default value is false.",
          "default" : "false",
          "type" : "boolean"
        },
        "unprotected-attributes-generator-provider" : {
          "description" : "Provider of the generator for the unprotected attributes. The default value is null which means no unprotected attribute is added to the Enveloped Data object. See https://tools.ietf.org/html/rfc5652#section-6.1.",
          "type" : "string"
        },
        "verify-signatures-of-all-signers" : {
          "description" : "If true then the signatures of all signers contained in the Signed Data object are verified. If false then only one signature whose signer info matches with one of the specified certificates is verified. Default value is true.",
          "default" : "true",
          "type" : "boolean"
        }
      }
    },
    "cxf" : {
      "type" : "object",
      "properties" : {
        "address" : {
          "description" : "The service publish address.",
          "type" : "string"
        },
        "bean-id" : {
          "description" : "To lookup an existing configured CxfEndpoint. Must used bean: as prefix.",
          "type" : "string"
        },
        "allow-streaming" : {
          "description" : "This option controls whether the CXF component, when running in PAYLOAD mode, will DOM parse the incoming messages into DOM Elements or keep the payload as a javax.xml.transform.Source object that would allow streaming in some cases.",
          "type" : "boolean"
        },
        "binding-id" : {
          "description" : "The bindingId for the service model to use.",
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "bus" : {
          "description" : "To use a custom configured CXF Bus.",
          "type" : "string"
        },
        "continuation-timeout" : {
          "description" : "This option is used to set the CXF continuation timeout which could be used in CxfConsumer by default when the CXF server is using Jetty or Servlet transport.",
          "default" : "30000",
          "type" : "string"
        },
        "cookie-handler" : {
          "description" : "Configure a cookie handler to maintain a HTTP session",
          "type" : "string"
        },
        "cxf-binding" : {
          "description" : "To use a custom CxfBinding to control the binding between Camel Message and CXF Message.",
          "type" : "string"
        },
        "cxf-configurer" : {
          "description" : "This option could apply the implementation of org.apache.camel.component.cxf.CxfEndpointConfigurer which supports to configure the CXF endpoint in programmatic way. User can configure the CXF server and client by implementing configure{ServerClient} method of CxfEndpointConfigurer.",
          "type" : "string"
        },
        "data-format" : {
          "description" : "The data type messages supported by the CXF endpoint.",
          "default" : "POJO",
          "enum" : [ "PAYLOAD", "RAW", "MESSAGE", "CXF_MESSAGE", "POJO" ],
          "type" : "string"
        },
        "default-bus" : {
          "description" : "Will set the default bus when CXF endpoint create a bus by itself",
          "default" : "false",
          "type" : "boolean"
        },
        "default-operation-name" : {
          "description" : "This option will set the default operationName that will be used by the CxfProducer which invokes the remote service.",
          "type" : "string"
        },
        "default-operation-namespace" : {
          "description" : "This option will set the default operationNamespace that will be used by the CxfProducer which invokes the remote service.",
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "header-filter-strategy" : {
          "description" : "To use a custom HeaderFilterStrategy to filter header to and from Camel message.",
          "type" : "string"
        },
        "hostname-verifier" : {
          "description" : "The hostname verifier to be used. Use the # notation to reference a HostnameVerifier from the registry.",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "logging-feature-enabled" : {
          "description" : "This option enables CXF Logging Feature which writes inbound and outbound SOAP messages to log.",
          "default" : "false",
          "type" : "boolean"
        },
        "logging-size-limit" : {
          "description" : "To limit the total size of number of bytes the logger will output when logging feature has been enabled and -1 for no limit.",
          "default" : "49152",
          "type" : "integer"
        },
        "merge-protocol-headers" : {
          "description" : "Whether to merge protocol headers. If enabled then propagating headers between Camel and CXF becomes more consistent and similar. For more details see CAMEL-6393.",
          "default" : "false",
          "type" : "boolean"
        },
        "mtom-enabled" : {
          "description" : "To enable MTOM (attachments). This requires to use POJO or PAYLOAD data format mode.",
          "default" : "false",
          "type" : "boolean"
        },
        "password" : {
          "description" : "This option is used to set the basic authentication information of password for the CXF client.",
          "type" : "string"
        },
        "port-name" : {
          "description" : "The endpoint name this service is implementing, it maps to the wsdl:portname. In the format of ns:PORT_NAME where ns is a namespace prefix valid at this scope.",
          "type" : "string"
        },
        "properties" : {
          "description" : "To set additional CXF options using the key/value pairs from the Map. For example to turn on stacktraces in SOAP faults, properties.faultStackTraceEnabled=true",
          "type" : "string"
        },
        "published-endpoint-url" : {
          "description" : "This option can override the endpointUrl that published from the WSDL which can be accessed with service address url plus wsd",
          "type" : "string"
        },
        "service-class" : {
          "description" : "The class name of the SEI (Service Endpoint Interface) class which could have JSR181 annotation or not.",
          "type" : "string"
        },
        "service-name" : {
          "description" : "The service name this service is implementing, it maps to the wsdl:servicename.",
          "type" : "string"
        },
        "skip-fault-logging" : {
          "description" : "This option controls whether the PhaseInterceptorChain skips logging the Fault that it catches.",
          "default" : "false",
          "type" : "boolean"
        },
        "skip-payload-message-part-check" : {
          "description" : "Sets whether SOAP message validation should be disabled.",
          "default" : "false",
          "type" : "boolean"
        },
        "ssl-context-parameters" : {
          "description" : "The Camel SSL setting reference. Use the # notation to reference the SSL Context.",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "username" : {
          "description" : "This option is used to set the basic authentication information of username for the CXF client.",
          "type" : "string"
        },
        "wrapped" : {
          "description" : "Which kind of operation that CXF endpoint producer will invoke",
          "default" : "false",
          "type" : "boolean"
        },
        "wrapped-style" : {
          "description" : "The WSDL style that describes how parameters are represented in the SOAP body. If the value is false, CXF will chose the document-literal unwrapped style, If the value is true, CXF will chose the document-literal wrapped style",
          "type" : "boolean"
        },
        "wsdl-url" : {
          "description" : "The location of the WSDL. Can be on the classpath, file system, or be hosted remotely.",
          "type" : "string"
        }
      }
    },
    "cxfrs" : {
      "type" : "object",
      "properties" : {
        "address" : {
          "description" : "The service publish address.",
          "type" : "string"
        },
        "bean-id" : {
          "description" : "To lookup an existing configured CxfRsEndpoint. Must used bean: as prefix.",
          "type" : "string"
        },
        "binding" : {
          "description" : "To use a custom CxfBinding to control the binding between Camel Message and CXF Message.",
          "type" : "string"
        },
        "binding-style" : {
          "description" : "Sets how requests and responses will be mapped to/from Camel. Two values are possible: SimpleConsumer: This binding style processes request parameters, multiparts, etc. and maps them to IN headers, IN attachments and to the message body. It aims to eliminate low-level processing of org.apache.cxf.message.MessageContentsList. It also also adds more flexibility and simplicity to the response mapping. Only available for consumers. Default: The default style. For consumers this passes on a MessageContentsList to the route, requiring low-level processing in the route. This is the traditional binding style, which simply dumps the org.apache.cxf.message.MessageContentsList coming in from the CXF stack onto the IN message body. The user is then responsible for processing it according to the contract defined by the JAX-RS method signature. Custom: allows you to specify a custom binding through the binding option.",
          "default" : "Default",
          "enum" : [ "SimpleConsumer", "Default", "Custom" ],
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "bus" : {
          "description" : "To use a custom configured CXF Bus.",
          "type" : "string"
        },
        "continuation-timeout" : {
          "description" : "This option is used to set the CXF continuation timeout which could be used in CxfConsumer by default when the CXF server is using Jetty or Servlet transport.",
          "default" : "30000",
          "type" : "string"
        },
        "cookie-handler" : {
          "description" : "Configure a cookie handler to maintain a HTTP session",
          "type" : "string"
        },
        "cxf-rs-configurer" : {
          "description" : "This option could apply the implementation of org.apache.camel.component.cxf.jaxrs.CxfRsEndpointConfigurer which supports to configure the CXF endpoint in programmatic way. User can configure the CXF server and client by implementing configure{Server/Client} method of CxfEndpointConfigurer.",
          "type" : "string"
        },
        "default-bus" : {
          "description" : "Will set the default bus when CXF endpoint create a bus by itself",
          "default" : "false",
          "type" : "boolean"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "features" : {
          "description" : "Set the feature list to the CxfRs endpoint.",
          "type" : "string"
        },
        "header-filter-strategy" : {
          "description" : "To use a custom HeaderFilterStrategy to filter header to and from Camel message.",
          "type" : "string"
        },
        "hostname-verifier" : {
          "description" : "The hostname verifier to be used. Use the # notation to reference a HostnameVerifier from the registry.",
          "type" : "string"
        },
        "http-client-api" : {
          "description" : "If it is true, the CxfRsProducer will use the HttpClientAPI to invoke the service. If it is false, the CxfRsProducer will use the ProxyClientAPI to invoke the service",
          "default" : "true",
          "type" : "boolean"
        },
        "ignore-delete-method-message-body" : {
          "description" : "This option is used to tell CxfRsProducer to ignore the message body of the DELETE method when using HTTP API.",
          "default" : "false",
          "type" : "boolean"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "logging-feature-enabled" : {
          "description" : "This option enables CXF Logging Feature which writes inbound and outbound REST messages to log.",
          "default" : "false",
          "type" : "boolean"
        },
        "logging-size-limit" : {
          "description" : "To limit the total size of number of bytes the logger will output when logging feature has been enabled.",
          "type" : "integer"
        },
        "max-client-cache-size" : {
          "description" : "This option allows you to configure the maximum size of the cache. The implementation caches CXF clients or ClientFactoryBean in CxfProvider and CxfRsProvider.",
          "default" : "10",
          "type" : "integer"
        },
        "model-ref" : {
          "description" : "This option is used to specify the model file which is useful for the resource class without annotation. When using this option, then the service class can be omitted, to emulate document-only endpoints",
          "type" : "string"
        },
        "perform-invocation" : {
          "description" : "When the option is true, Camel will perform the invocation of the resource class instance and put the response object into the exchange for further processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "propagate-contexts" : {
          "description" : "When the option is true, JAXRS UriInfo, HttpHeaders, Request and SecurityContext contexts will be available to custom CXFRS processors as typed Camel exchange properties. These contexts can be used to analyze the current requests using JAX-RS API.",
          "default" : "false",
          "type" : "boolean"
        },
        "providers" : {
          "description" : "Set custom JAX-RS provider(s) list to the CxfRs endpoint. You can specify a string with a list of providers to lookup in the registy separated by comma.",
          "type" : "string"
        },
        "published-endpoint-url" : {
          "description" : "This option can override the endpointUrl that published from the WADL which can be accessed with resource address url plus _wadl",
          "type" : "string"
        },
        "resource-classes" : {
          "description" : "The resource classes which you want to export as REST service. Multiple classes can be separated by comma.",
          "type" : "string"
        },
        "schema-locations" : {
          "description" : "Sets the locations of the schema(s) which can be used to validate the incoming XML or JAXB-driven JSON.",
          "type" : "string"
        },
        "service-beans" : {
          "description" : "The service beans (the bean ids to lookup in the registry) which you want to export as REST service. Multiple beans can be separated by comma",
          "type" : "string"
        },
        "skip-fault-logging" : {
          "description" : "This option controls whether the PhaseInterceptorChain skips logging the Fault that it catches.",
          "default" : "false",
          "type" : "boolean"
        },
        "ssl-context-parameters" : {
          "description" : "The Camel SSL setting reference. Use the # notation to reference the SSL Context.",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "throw-exception-on-failure" : {
          "description" : "This option tells the CxfRsProducer to inspect return codes and will generate an Exception if the return code is larger than 207.",
          "default" : "true",
          "type" : "boolean"
        }
      }
    },
    "dataformat" : {
      "type" : "object",
      "required" : [ "name", "operation" ],
      "properties" : {
        "name" : {
          "description" : "Name of data format",
          "type" : "string"
        },
        "operation" : {
          "description" : "Operation to use either marshal or unmarshal",
          "enum" : [ "marshal", "unmarshal" ],
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "dataset" : {
      "type" : "object",
      "required" : [ "name" ],
      "properties" : {
        "name" : {
          "description" : "Name of DataSet to lookup in the registry",
          "type" : "string"
        },
        "assert-period" : {
          "description" : "Sets a grace period after which the mock endpoint will re-assert to ensure the preliminary assertion is still valid. This is used for example to assert that exactly a number of messages arrives. For example if expectedMessageCount(int) was set to 5, then the assertion is satisfied when 5 or more message arrives. To ensure that exactly 5 messages arrives, then you would need to wait a little period to ensure no further message arrives. This is what you can use this method for. By default this period is disabled.",
          "default" : "0",
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "consume-delay" : {
          "description" : "Allows a delay to be specified which causes a delay when a message is consumed by the producer (to simulate slow processing)",
          "default" : "0",
          "type" : "string"
        },
        "copy-on-exchange" : {
          "description" : "Sets whether to make a deep copy of the incoming Exchange when received at this mock endpoint. Is by default true.",
          "default" : "true",
          "type" : "boolean"
        },
        "data-set-index" : {
          "description" : "Controls the behaviour of the CamelDataSetIndex header. For Consumers: - off = the header will not be set - strict/lenient = the header will be set For Producers: - off = the header value will not be verified, and will not be set if it is not present = strict = the header value must be present and will be verified = lenient = the header value will be verified if it is present, and will be set if it is not present",
          "default" : "lenient",
          "enum" : [ "strict", "lenient", "off" ],
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "expected-count" : {
          "description" : "Specifies the expected number of message exchanges that should be received by this endpoint. Beware: If you want to expect that 0 messages, then take extra care, as 0 matches when the tests starts, so you need to set a assert period time to let the test run for a while to make sure there are still no messages arrived; for that use setAssertPeriod(long). An alternative is to use NotifyBuilder, and use the notifier to know when Camel is done routing some messages, before you call the assertIsSatisfied() method on the mocks. This allows you to not use a fixed assert period, to speedup testing times. If you want to assert that exactly n'th message arrives to this mock endpoint, then see also the setAssertPeriod(long) method for further details.",
          "default" : "-1",
          "type" : "integer"
        },
        "fail-fast" : {
          "description" : "Sets whether assertIsSatisfied() should fail fast at the first detected failed expectation while it may otherwise wait for all expected messages to arrive before performing expectations verifications. Is by default true. Set to false to use behavior as in Camel 2.x.",
          "default" : "false",
          "type" : "boolean"
        },
        "initial-delay" : {
          "description" : "Time period in millis to wait before starting sending messages.",
          "default" : "1000",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "min-rate" : {
          "description" : "Wait until the DataSet contains at least this number of messages",
          "default" : "0",
          "type" : "integer"
        },
        "preload-size" : {
          "description" : "Sets how many messages should be preloaded (sent) before the route completes its initialization",
          "default" : "0",
          "type" : "integer"
        },
        "produce-delay" : {
          "description" : "Allows a delay to be specified which causes a delay when a message is sent by the consumer (to simulate slow processing)",
          "default" : "3",
          "type" : "string"
        },
        "report-group" : {
          "description" : "A number that is used to turn on throughput logging based on groups of the size.",
          "type" : "integer"
        },
        "result-minimum-wait-time" : {
          "description" : "Sets the minimum expected amount of time (in millis) the assertIsSatisfied() will wait on a latch until it is satisfied",
          "default" : "0",
          "type" : "string"
        },
        "result-wait-time" : {
          "description" : "Sets the maximum amount of time (in millis) the assertIsSatisfied() will wait on a latch until it is satisfied",
          "default" : "0",
          "type" : "string"
        },
        "retain-first" : {
          "description" : "Specifies to only retain the first n'th number of received Exchanges. This is used when testing with big data, to reduce memory consumption by not storing copies of every Exchange this mock endpoint receives. Important: When using this limitation, then the getReceivedCounter() will still return the actual number of received Exchanges. For example if we have received 5000 Exchanges, and have configured to only retain the first 10 Exchanges, then the getReceivedCounter() will still return 5000 but there is only the first 10 Exchanges in the getExchanges() and getReceivedExchanges() methods. When using this method, then some of the other expectation methods is not supported, for example the expectedBodiesReceived(Object...) sets a expectation on the first number of bodies received. You can configure both setRetainFirst(int) and setRetainLast(int) methods, to limit both the first and last received.",
          "default" : "-1",
          "type" : "integer"
        },
        "retain-last" : {
          "description" : "Specifies to only retain the last n'th number of received Exchanges. This is used when testing with big data, to reduce memory consumption by not storing copies of every Exchange this mock endpoint receives. Important: When using this limitation, then the getReceivedCounter() will still return the actual number of received Exchanges. For example if we have received 5000 Exchanges, and have configured to only retain the last 20 Exchanges, then the getReceivedCounter() will still return 5000 but there is only the last 20 Exchanges in the getExchanges() and getReceivedExchanges() methods. When using this method, then some of the other expectation methods is not supported, for example the expectedBodiesReceived(Object...) sets a expectation on the first number of bodies received. You can configure both setRetainFirst(int) and setRetainLast(int) methods, to limit both the first and last received.",
          "default" : "-1",
          "type" : "integer"
        },
        "sleep-for-empty-test" : {
          "description" : "Allows a sleep to be specified to wait to check that this endpoint really is empty when expectedMessageCount(int) is called with zero",
          "default" : "0",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "dataset-test" : {
      "type" : "object",
      "required" : [ "name" ],
      "properties" : {
        "name" : {
          "description" : "Name of endpoint to lookup in the registry to use for polling messages used for testing",
          "type" : "string"
        },
        "any-order" : {
          "description" : "Whether the expected messages should arrive in the same order or can be in any order.",
          "default" : "false",
          "type" : "boolean"
        },
        "assert-period" : {
          "description" : "Sets a grace period after which the mock endpoint will re-assert to ensure the preliminary assertion is still valid. This is used for example to assert that exactly a number of messages arrives. For example if expectedMessageCount(int) was set to 5, then the assertion is satisfied when 5 or more message arrives. To ensure that exactly 5 messages arrives, then you would need to wait a little period to ensure no further message arrives. This is what you can use this method for. By default this period is disabled.",
          "default" : "0",
          "type" : "string"
        },
        "copy-on-exchange" : {
          "description" : "Sets whether to make a deep copy of the incoming Exchange when received at this mock endpoint. Is by default true.",
          "default" : "true",
          "type" : "boolean"
        },
        "delimiter" : {
          "description" : "The split delimiter to use when split is enabled. By default the delimiter is new line based. The delimiter can be a regular expression.",
          "type" : "string"
        },
        "expected-count" : {
          "description" : "Specifies the expected number of message exchanges that should be received by this endpoint. Beware: If you want to expect that 0 messages, then take extra care, as 0 matches when the tests starts, so you need to set a assert period time to let the test run for a while to make sure there are still no messages arrived; for that use setAssertPeriod(long). An alternative is to use NotifyBuilder, and use the notifier to know when Camel is done routing some messages, before you call the assertIsSatisfied() method on the mocks. This allows you to not use a fixed assert period, to speedup testing times. If you want to assert that exactly n'th message arrives to this mock endpoint, then see also the setAssertPeriod(long) method for further details.",
          "default" : "-1",
          "type" : "integer"
        },
        "fail-fast" : {
          "description" : "Sets whether assertIsSatisfied() should fail fast at the first detected failed expectation while it may otherwise wait for all expected messages to arrive before performing expectations verifications. Is by default true. Set to false to use behavior as in Camel 2.x.",
          "default" : "false",
          "type" : "boolean"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "report-group" : {
          "description" : "A number that is used to turn on throughput logging based on groups of the size.",
          "type" : "integer"
        },
        "result-minimum-wait-time" : {
          "description" : "Sets the minimum expected amount of time (in millis) the assertIsSatisfied() will wait on a latch until it is satisfied",
          "default" : "0",
          "type" : "string"
        },
        "result-wait-time" : {
          "description" : "Sets the maximum amount of time (in millis) the assertIsSatisfied() will wait on a latch until it is satisfied",
          "default" : "0",
          "type" : "string"
        },
        "retain-first" : {
          "description" : "Specifies to only retain the first n'th number of received Exchanges. This is used when testing with big data, to reduce memory consumption by not storing copies of every Exchange this mock endpoint receives. Important: When using this limitation, then the getReceivedCounter() will still return the actual number of received Exchanges. For example if we have received 5000 Exchanges, and have configured to only retain the first 10 Exchanges, then the getReceivedCounter() will still return 5000 but there is only the first 10 Exchanges in the getExchanges() and getReceivedExchanges() methods. When using this method, then some of the other expectation methods is not supported, for example the expectedBodiesReceived(Object...) sets a expectation on the first number of bodies received. You can configure both setRetainFirst(int) and setRetainLast(int) methods, to limit both the first and last received.",
          "default" : "-1",
          "type" : "integer"
        },
        "retain-last" : {
          "description" : "Specifies to only retain the last n'th number of received Exchanges. This is used when testing with big data, to reduce memory consumption by not storing copies of every Exchange this mock endpoint receives. Important: When using this limitation, then the getReceivedCounter() will still return the actual number of received Exchanges. For example if we have received 5000 Exchanges, and have configured to only retain the last 20 Exchanges, then the getReceivedCounter() will still return 5000 but there is only the last 20 Exchanges in the getExchanges() and getReceivedExchanges() methods. When using this method, then some of the other expectation methods is not supported, for example the expectedBodiesReceived(Object...) sets a expectation on the first number of bodies received. You can configure both setRetainFirst(int) and setRetainLast(int) methods, to limit both the first and last received.",
          "default" : "-1",
          "type" : "integer"
        },
        "sleep-for-empty-test" : {
          "description" : "Allows a sleep to be specified to wait to check that this endpoint really is empty when expectedMessageCount(int) is called with zero",
          "default" : "0",
          "type" : "string"
        },
        "split" : {
          "description" : "If enabled the messages loaded from the test endpoint will be split using new line delimiters so each line is an expected message. For example to use a file endpoint to load a file where each line is an expected message.",
          "default" : "false",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "timeout" : {
          "description" : "The timeout to use when polling for message bodies from the URI",
          "default" : "2000",
          "type" : "string"
        }
      }
    },
    "debezium-mongodb" : {
      "type" : "object",
      "required" : [ "name", "mongodbName", "mongodbPassword" ],
      "properties" : {
        "name" : {
          "description" : "Unique name for the connector. Attempting to register again with the same name will fail.",
          "type" : "string"
        },
        "additional-properties" : {
          "description" : "Additional properties for debezium components in case they can't be set directly on the camel configurations (e.g: setting Kafka Connect properties needed by Debezium engine, for example setting KafkaOffsetBackingStore), the properties have to be prefixed with additionalProperties.. E.g: additionalProperties.transactional.id=12345&additionalProperties.schema.registry.url=http://localhost:8811/avro",
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "collection-exclude-list" : {
          "description" : "A comma-separated list of regular expressions that match the collection names for which changes are to be excluded",
          "type" : "string"
        },
        "collection-include-list" : {
          "description" : "A comma-separated list of regular expressions that match the collection names for which changes are to be captured",
          "type" : "string"
        },
        "connect-backoff-initial-delay-ms" : {
          "description" : "The initial delay when trying to reconnect to a primary after a connection cannot be made or when no primary is available. Defaults to 1 second (1000 ms).",
          "default" : "1s",
          "type" : "string"
        },
        "connect-backoff-max-delay-ms" : {
          "description" : "The maximum delay when trying to reconnect to a primary after a connection cannot be made or when no primary is available. Defaults to 120 second (120,000 ms).",
          "default" : "2m",
          "type" : "string"
        },
        "connect-max-attempts" : {
          "description" : "Maximum number of failed connection attempts to a replica set primary before an exception occurs and task is aborted. Defaults to 16, which with the defaults for 'connect.backoff.initial.delay.ms' and 'connect.backoff.max.delay.ms' results in just over 20 minutes of attempts before failing.",
          "default" : "16",
          "type" : "integer"
        },
        "converters" : {
          "description" : "Optional list of custom converters that would be used instead of default ones. The converters are defined using '.type' config option and configured using options '.'",
          "type" : "string"
        },
        "database-exclude-list" : {
          "description" : "A comma-separated list of regular expressions that match the database names for which changes are to be excluded",
          "type" : "string"
        },
        "database-history-file-filename" : {
          "description" : "The path to the file that will be used to record the database history",
          "type" : "string"
        },
        "database-include-list" : {
          "description" : "A comma-separated list of regular expressions that match the database names for which changes are to be captured",
          "type" : "string"
        },
        "event-processing-failure-handling-mode" : {
          "description" : "Specify how failures during processing of events (i.e. when encountering a corrupted event) should be handled, including:'fail' (the default) an exception indicating the problematic event and its position is raised, causing the connector to be stopped; 'warn' the problematic event and its position will be logged and the event will be skipped;'ignore' the problematic event will be skipped.",
          "default" : "fail",
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "field-exclude-list" : {
          "description" : "A comma-separated list of the fully-qualified names of fields that should be excluded from change event message values",
          "type" : "string"
        },
        "field-renames" : {
          "description" : "Description is not available here, please check Debezium website for corresponding key 'field.renames' description.",
          "type" : "string"
        },
        "heartbeat-interval-ms" : {
          "description" : "Length of an interval in milli-seconds in in which the connector periodically sends heartbeat messages to a heartbeat topic. Use 0 to disable heartbeat messages. Disabled by default.",
          "default" : "0ms",
          "type" : "string"
        },
        "heartbeat-topics-prefix" : {
          "description" : "The prefix that is used to name heartbeat topics.Defaults to __debezium-heartbeat.",
          "default" : "__debezium-heartbeat",
          "type" : "string"
        },
        "initial-sync-max-threads" : {
          "description" : "Maximum number of threads used to perform an initial sync of the collections in a replica set. Defaults to 1.",
          "default" : "1",
          "type" : "integer"
        },
        "internal-key-converter" : {
          "description" : "The Converter class that should be used to serialize and deserialize key data for offsets. The default is JSON converter.",
          "default" : "org.apache.kafka.connect.json.JsonConverter",
          "type" : "string"
        },
        "internal-value-converter" : {
          "description" : "The Converter class that should be used to serialize and deserialize value data for offsets. The default is JSON converter.",
          "default" : "org.apache.kafka.connect.json.JsonConverter",
          "type" : "string"
        },
        "max-batch-size" : {
          "description" : "Maximum size of each batch of source records. Defaults to 2048.",
          "default" : "2048",
          "type" : "integer"
        },
        "max-queue-size" : {
          "description" : "Maximum size of the queue for change events read from the database log but not yet recorded or forwarded. Defaults to 8192, and should always be larger than the maximum batch size.",
          "default" : "8192",
          "type" : "integer"
        },
        "mongodb-authsource" : {
          "description" : "Database containing user credentials.",
          "default" : "admin",
          "type" : "string"
        },
        "mongodb-connect-timeout-ms" : {
          "description" : "The connection timeout in milliseconds",
          "default" : "10s",
          "type" : "string"
        },
        "mongodb-hosts" : {
          "description" : "The hostname and port pairs (in the form 'host' or 'host:port') of the MongoDB server(s) in the replica set.",
          "type" : "string"
        },
        "mongodb-members-auto-discover" : {
          "description" : "Specifies whether the addresses in 'hosts' are seeds that should be used to discover all members of the cluster or replica set ('true'), or whether the address(es) in 'hosts' should be used as is ('false'). The default is 'true'.",
          "default" : "true",
          "type" : "boolean"
        },
        "mongodb-name" : {
          "description" : "Unique name that identifies the MongoDB replica set or cluster and all recorded offsets, andthat is used as a prefix for all schemas and topics. Each distinct MongoDB installation should have a separate namespace and monitored by at most one Debezium connector.",
          "type" : "string"
        },
        "mongodb-password" : {
          "description" : "Password to be used when connecting to MongoDB, if necessary.",
          "type" : "string"
        },
        "mongodb-poll-interval-ms" : {
          "description" : "Frequency in milliseconds to look for new, removed, or changed replica sets. Defaults to 30000 milliseconds.",
          "default" : "30s",
          "type" : "string"
        },
        "mongodb-server-selection-timeout-ms" : {
          "description" : "The server selection timeout in milliseconds",
          "default" : "30s",
          "type" : "string"
        },
        "mongodb-socket-timeout-ms" : {
          "description" : "The socket timeout in milliseconds",
          "default" : "0ms",
          "type" : "string"
        },
        "mongodb-ssl-enabled" : {
          "description" : "Should connector use SSL to connect to MongoDB instances",
          "default" : "false",
          "type" : "boolean"
        },
        "mongodb-ssl-invalid-hostname-allowed" : {
          "description" : "Whether invalid host names are allowed when using SSL. If true the connection will not prevent man-in-the-middle attacks",
          "default" : "false",
          "type" : "boolean"
        },
        "mongodb-user" : {
          "description" : "Database user for connecting to MongoDB, if necessary.",
          "type" : "string"
        },
        "offset-commit-policy" : {
          "description" : "The name of the Java class of the commit policy. It defines when offsets commit has to be triggered based on the number of events processed and the time elapsed since the last commit. This class must implement the interface 'OffsetCommitPolicy'. The default is a periodic commit policy based upon time intervals.",
          "default" : "io.debezium.embedded.spi.OffsetCommitPolicy.PeriodicCommitOffsetPolicy",
          "type" : "string"
        },
        "offset-commit-timeout-ms" : {
          "description" : "Maximum number of milliseconds to wait for records to flush and partition offset data to be committed to offset storage before cancelling the process and restoring the offset data to be committed in a future attempt. The default is 5 seconds.",
          "default" : "5s",
          "type" : "string"
        },
        "offset-flush-interval-ms" : {
          "description" : "Interval at which to try committing offsets. The default is 1 minute.",
          "default" : "60s",
          "type" : "string"
        },
        "offset-storage" : {
          "description" : "The name of the Java class that is responsible for persistence of connector offsets.",
          "default" : "org.apache.kafka.connect.storage.FileOffsetBackingStore",
          "type" : "string"
        },
        "offset-storage-file-name" : {
          "description" : "Path to file where offsets are to be stored. Required when offset.storage is set to the FileOffsetBackingStore.",
          "type" : "string"
        },
        "offset-storage-partitions" : {
          "description" : "The number of partitions used when creating the offset storage topic. Required when offset.storage is set to the 'KafkaOffsetBackingStore'.",
          "type" : "integer"
        },
        "offset-storage-replication-factor" : {
          "description" : "Replication factor used when creating the offset storage topic. Required when offset.storage is set to the KafkaOffsetBackingStore",
          "type" : "integer"
        },
        "offset-storage-topic" : {
          "description" : "The name of the Kafka topic where offsets are to be stored. Required when offset.storage is set to the KafkaOffsetBackingStore.",
          "type" : "string"
        },
        "poll-interval-ms" : {
          "description" : "Frequency in milliseconds to wait for new change events to appear after receiving no events. Defaults to 500ms.",
          "default" : "500ms",
          "type" : "string"
        },
        "provide-transaction-metadata" : {
          "description" : "Enables transaction metadata extraction together with event counting",
          "default" : "false",
          "type" : "boolean"
        },
        "query-fetch-size" : {
          "description" : "The maximum number of records that should be loaded into memory while streaming. A value of 0 uses the default JDBC fetch size.",
          "default" : "0",
          "type" : "integer"
        },
        "retriable-restart-connector-wait-ms" : {
          "description" : "Time to wait before restarting connector after retriable exception occurs. Defaults to 10000ms.",
          "default" : "10s",
          "type" : "string"
        },
        "sanitize-field-names" : {
          "description" : "Whether field names will be sanitized to Avro naming conventions",
          "default" : "false",
          "type" : "boolean"
        },
        "skipped-operations" : {
          "description" : "The comma-separated list of operations to skip during streaming, defined as: 'i' for inserts; 'u' for updates; 'd' for deletes. By default, no operations will be skipped.",
          "type" : "string"
        },
        "snapshot-delay-ms" : {
          "description" : "The number of milliseconds to delay before a snapshot will begin.",
          "default" : "0ms",
          "type" : "string"
        },
        "snapshot-fetch-size" : {
          "description" : "The maximum number of records that should be loaded into memory while performing a snapshot",
          "type" : "integer"
        },
        "snapshot-mode" : {
          "description" : "The criteria for running a snapshot upon startup of the connector. Options include: 'initial' (the default) to specify the connector should always perform an initial sync when required; 'never' to specify the connector should never perform an initial sync",
          "default" : "initial",
          "type" : "string"
        },
        "source-struct-version" : {
          "description" : "A version of the format of the publicly visible source part in the message",
          "default" : "v2",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "tombstones-on-delete" : {
          "description" : "Whether delete operations should be represented by a delete event and a subsquenttombstone event (true) or only by a delete event (false). Emitting the tombstone event (the default behavior) allows Kafka to completely delete all events pertaining to the given key once the source record got deleted.",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "debezium-mysql" : {
      "type" : "object",
      "required" : [ "name", "databasePassword", "databaseServerName" ],
      "properties" : {
        "name" : {
          "description" : "Unique name for the connector. Attempting to register again with the same name will fail.",
          "type" : "string"
        },
        "additional-properties" : {
          "description" : "Additional properties for debezium components in case they can't be set directly on the camel configurations (e.g: setting Kafka Connect properties needed by Debezium engine, for example setting KafkaOffsetBackingStore), the properties have to be prefixed with additionalProperties.. E.g: additionalProperties.transactional.id=12345&additionalProperties.schema.registry.url=http://localhost:8811/avro",
          "type" : "string"
        },
        "bigint-unsigned-handling-mode" : {
          "description" : "Specify how BIGINT UNSIGNED columns should be represented in change events, including:'precise' uses java.math.BigDecimal to represent values, which are encoded in the change events using a binary representation and Kafka Connect's 'org.apache.kafka.connect.data.Decimal' type; 'long' (the default) represents values using Java's 'long', which may not offer the precision but will be far easier to use in consumers.",
          "default" : "long",
          "type" : "string"
        },
        "binary-handling-mode" : {
          "description" : "Specify how binary (blob, binary, etc.) columns should be represented in change events, including:'bytes' represents binary data as byte array (default)'base64' represents binary data as base64-encoded string'hex' represents binary data as hex-encoded (base16) string",
          "default" : "bytes",
          "type" : "string"
        },
        "binlog-buffer-size" : {
          "description" : "The size of a look-ahead buffer used by the binlog reader to decide whether the transaction in progress is going to be committed or rolled back. Use 0 to disable look-ahead buffering. Defaults to 0 (i.e. buffering is disabled).",
          "default" : "0",
          "type" : "integer"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "column-blacklist" : {
          "description" : "Regular expressions matching columns to exclude from change events (deprecated, use column.exclude.list instead)",
          "type" : "string"
        },
        "column-exclude-list" : {
          "description" : "Regular expressions matching columns to exclude from change events",
          "type" : "string"
        },
        "column-include-list" : {
          "description" : "Regular expressions matching columns to include in change events",
          "type" : "string"
        },
        "connect-keep-alive" : {
          "description" : "Whether a separate thread should be used to ensure the connection is kept alive.",
          "default" : "true",
          "type" : "boolean"
        },
        "connect-keep-alive-interval-ms" : {
          "description" : "Interval in milliseconds to wait for connection checking if keep alive thread is used.",
          "default" : "1m",
          "type" : "string"
        },
        "connect-timeout-ms" : {
          "description" : "Maximum time in milliseconds to wait after trying to connect to the database before timing out.",
          "default" : "30s",
          "type" : "string"
        },
        "database-exclude-list" : {
          "description" : "A comma-separated list of regular expressions that match database names to be excluded from monitoring",
          "type" : "string"
        },
        "database-history" : {
          "description" : "The name of the DatabaseHistory class that should be used to store and recover database schema changes. The configuration properties for the history are prefixed with the 'database.history.' string.",
          "default" : "io.debezium.relational.history.FileDatabaseHistory",
          "type" : "string"
        },
        "database-history-file-filename" : {
          "description" : "The path to the file that will be used to record the database history",
          "type" : "string"
        },
        "database-history-kafka-bootstrap-servers" : {
          "description" : "A list of host/port pairs that the connector will use for establishing the initial connection to the Kafka cluster for retrieving database schema history previously stored by the connector. This should point to the same Kafka cluster used by the Kafka Connect process.",
          "type" : "string"
        },
        "database-history-kafka-recovery-attempts" : {
          "description" : "The number of attempts in a row that no data are returned from Kafka before recover completes. The maximum amount of time to wait after receiving no data is (recovery.attempts) x (recovery.poll.interval.ms).",
          "default" : "100",
          "type" : "integer"
        },
        "database-history-kafka-recovery-poll-interval-ms" : {
          "description" : "The number of milliseconds to wait while polling for persisted data during recovery.",
          "default" : "100ms",
          "type" : "string"
        },
        "database-history-kafka-topic" : {
          "description" : "The name of the topic for the database schema history",
          "type" : "string"
        },
        "database-history-skip-unparseable-ddl" : {
          "description" : "Controls the action Debezium will take when it meets a DDL statement in binlog, that it cannot parse.By default the connector will stop operating but by changing the setting it can ignore the statements which it cannot parse. If skipping is enabled then Debezium can miss metadata changes.",
          "default" : "false",
          "type" : "boolean"
        },
        "database-history-store-only-monitored-tables-ddl" : {
          "description" : "Controls what DDL will Debezium store in database history.By default (false) Debezium will store all incoming DDL statements. If set to truethen only DDL that manipulates a monitored table will be stored.",
          "default" : "false",
          "type" : "boolean"
        },
        "database-hostname" : {
          "description" : "Resolvable hostname or IP address of the MySQL database server.",
          "type" : "string"
        },
        "database-include-list" : {
          "description" : "The databases for which changes are to be captured",
          "type" : "string"
        },
        "database-initial-statements" : {
          "description" : "A semicolon separated list of SQL statements to be executed when a JDBC connection (not binlog reading connection) to the database is established. Note that the connector may establish JDBC connections at its own discretion, so this should typically be used for configuration of session parameters only,but not for executing DML statements. Use doubled semicolon (';;') to use a semicolon as a character and not as a delimiter.",
          "type" : "string"
        },
        "database-jdbc-driver" : {
          "description" : "JDBC Driver class name used to connect to the MySQL database server.",
          "default" : "class com.mysql.cj.jdbc.Driver",
          "type" : "string"
        },
        "database-password" : {
          "description" : "Password of the MySQL database user to be used when connecting to the database.",
          "type" : "string"
        },
        "database-port" : {
          "description" : "Port of the MySQL database server.",
          "default" : "3306",
          "type" : "integer"
        },
        "database-server-id" : {
          "description" : "A numeric ID of this database client, which must be unique across all currently-running database processes in the cluster. This connector joins the MySQL database cluster as another server (with this unique ID) so it can read the binlog. By default, a random number is generated between 5400 and 6400.",
          "type" : "integer"
        },
        "database-server-id-offset" : {
          "description" : "Only relevant if parallel snapshotting is configured. During parallel snapshotting, multiple (4) connections open to the database client, and they each need their own unique connection ID. This offset is used to generate those IDs from the base configured cluster ID.",
          "default" : "10000",
          "type" : "integer"
        },
        "database-server-name" : {
          "description" : "Unique name that identifies the database server and all recorded offsets, and that is used as a prefix for all schemas and topics. Each distinct installation should have a separate namespace and be monitored by at most one Debezium connector.",
          "type" : "string"
        },
        "database-ssl-keystore" : {
          "description" : "Location of the Java keystore file containing an application process's own certificate and private key.",
          "type" : "string"
        },
        "database-ssl-keystore-password" : {
          "description" : "Password to access the private key from the keystore file specified by 'ssl.keystore' configuration property or the 'javax.net.ssl.keyStore' system or JVM property. This password is used to unlock the keystore file (store password), and to decrypt the private key stored in the keystore (key password).",
          "type" : "string"
        },
        "database-ssl-mode" : {
          "description" : "Whether to use an encrypted connection to MySQL. Options include'disabled' (the default) to use an unencrypted connection; 'preferred' to establish a secure (encrypted) connection if the server supports secure connections, but fall back to an unencrypted connection otherwise; 'required' to use a secure (encrypted) connection, and fail if one cannot be established; 'verify_ca' like 'required' but additionally verify the server TLS certificate against the configured Certificate Authority (CA) certificates, or fail if no valid matching CA certificates are found; or'verify_identity' like 'verify_ca' but additionally verify that the server certificate matches the host to which the connection is attempted.",
          "default" : "disabled",
          "type" : "string"
        },
        "database-ssl-truststore" : {
          "description" : "Location of the Java truststore file containing the collection of CA certificates trusted by this application process (trust store).",
          "type" : "string"
        },
        "database-ssl-truststore-password" : {
          "description" : "Password to unlock the keystore file (store password) specified by 'ssl.trustore' configuration property or the 'javax.net.ssl.trustStore' system or JVM property.",
          "type" : "string"
        },
        "database-user" : {
          "description" : "Name of the MySQL database user to be used when connecting to the database.",
          "type" : "string"
        },
        "decimal-handling-mode" : {
          "description" : "Specify how DECIMAL and NUMERIC columns should be represented in change events, including:'precise' (the default) uses java.math.BigDecimal to represent values, which are encoded in the change events using a binary representation and Kafka Connect's 'org.apache.kafka.connect.data.Decimal' type; 'string' uses string to represent values; 'double' represents values using Java's 'double', which may not offer the precision but will be far easier to use in consumers.",
          "default" : "precise",
          "type" : "string"
        },
        "enable-time-adjuster" : {
          "description" : "MySQL allows user to insert year value as either 2-digit or 4-digit. In case of two digit the value is automatically mapped into 1970 - 2069.false - delegates the implicit conversion to the databasetrue - (the default) Debezium makes the conversion",
          "default" : "true",
          "type" : "boolean"
        },
        "event-deserialization-failure-handling-mode" : {
          "description" : "Specify how failures during deserialization of binlog events (i.e. when encountering a corrupted event) should be handled, including:'fail' (the default) an exception indicating the problematic event and its binlog position is raised, causing the connector to be stopped; 'warn' the problematic event and its binlog position will be logged and the event will be skipped;'ignore' the problematic event will be skipped.",
          "default" : "fail",
          "type" : "string"
        },
        "event-processing-failure-handling-mode" : {
          "description" : "Specify how failures during processing of events (i.e. when encountering a corrupted event) should be handled, including:'fail' (the default) an exception indicating the problematic event and its position is raised, causing the connector to be stopped; 'warn' the problematic event and its position will be logged and the event will be skipped;'ignore' the problematic event will be skipped.",
          "default" : "fail",
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "gtid-new-channel-position" : {
          "description" : "If set to 'latest', when connector sees new GTID, it will start consuming gtid channel from the server latest executed gtid position. If 'earliest' (the default) connector starts reading channel from first available (not purged) gtid position on the server.",
          "default" : "earliest",
          "type" : "string"
        },
        "gtid-source-excludes" : {
          "description" : "The source UUIDs used to exclude GTID ranges when determine the starting position in the MySQL server's binlog.",
          "type" : "string"
        },
        "gtid-source-filter-dml-events" : {
          "description" : "If set to true, we will only produce DML events into Kafka for transactions that were written on mysql servers with UUIDs matching the filters defined by the gtid.source.includes or gtid.source.excludes configuration options, if they are specified.",
          "default" : "true",
          "type" : "boolean"
        },
        "gtid-source-includes" : {
          "description" : "The source UUIDs used to include GTID ranges when determine the starting position in the MySQL server's binlog.",
          "type" : "string"
        },
        "heartbeat-interval-ms" : {
          "description" : "Length of an interval in milli-seconds in in which the connector periodically sends heartbeat messages to a heartbeat topic. Use 0 to disable heartbeat messages. Disabled by default.",
          "default" : "0ms",
          "type" : "string"
        },
        "heartbeat-topics-prefix" : {
          "description" : "The prefix that is used to name heartbeat topics.Defaults to __debezium-heartbeat.",
          "default" : "__debezium-heartbeat",
          "type" : "string"
        },
        "include-query" : {
          "description" : "Whether the connector should include the original SQL query that generated the change event. Note: This option requires MySQL be configured with the binlog_rows_query_log_events option set to ON. Query will not be present for events generated from snapshot. WARNING: Enabling this option may expose tables or fields explicitly blacklisted or masked by including the original SQL statement in the change event. For this reason the default value is 'false'.",
          "default" : "false",
          "type" : "boolean"
        },
        "include-schema-changes" : {
          "description" : "Whether the connector should publish changes in the database schema to a Kafka topic with the same name as the database server ID. Each schema change will be recorded using a key that contains the database name and whose value include logical description of the new schema and optionally the DDL statement(s).The default is 'true'. This is independent of how the connector internally records database history.",
          "default" : "true",
          "type" : "boolean"
        },
        "inconsistent-schema-handling-mode" : {
          "description" : "Specify how binlog events that belong to a table missing from internal schema representation (i.e. internal representation is not consistent with database) should be handled, including:'fail' (the default) an exception indicating the problematic event and its binlog position is raised, causing the connector to be stopped; 'warn' the problematic event and its binlog position will be logged and the event will be skipped;'skip' the problematic event will be skipped.",
          "default" : "fail",
          "type" : "string"
        },
        "internal-key-converter" : {
          "description" : "The Converter class that should be used to serialize and deserialize key data for offsets. The default is JSON converter.",
          "default" : "org.apache.kafka.connect.json.JsonConverter",
          "type" : "string"
        },
        "internal-value-converter" : {
          "description" : "The Converter class that should be used to serialize and deserialize value data for offsets. The default is JSON converter.",
          "default" : "org.apache.kafka.connect.json.JsonConverter",
          "type" : "string"
        },
        "max-batch-size" : {
          "description" : "Maximum size of each batch of source records. Defaults to 2048.",
          "default" : "2048",
          "type" : "integer"
        },
        "max-queue-size" : {
          "description" : "Maximum size of the queue for change events read from the database log but not yet recorded or forwarded. Defaults to 8192, and should always be larger than the maximum batch size.",
          "default" : "8192",
          "type" : "integer"
        },
        "message-key-columns" : {
          "description" : "A semicolon-separated list of expressions that match fully-qualified tables and column(s) to be used as message key. Each expression must match the pattern ':',where the table names could be defined as (DB_NAME.TABLE_NAME) or (SCHEMA_NAME.TABLE_NAME), depending on the specific connector,and the key columns are a comma-separated list of columns representing the custom key. For any table without an explicit key configuration the table's primary key column(s) will be used as message key.Example: dbserver1.inventory.orderlines:orderId,orderLineId;dbserver1.inventory.orders:id",
          "type" : "string"
        },
        "offset-commit-policy" : {
          "description" : "The name of the Java class of the commit policy. It defines when offsets commit has to be triggered based on the number of events processed and the time elapsed since the last commit. This class must implement the interface 'OffsetCommitPolicy'. The default is a periodic commit policy based upon time intervals.",
          "default" : "io.debezium.embedded.spi.OffsetCommitPolicy.PeriodicCommitOffsetPolicy",
          "type" : "string"
        },
        "offset-commit-timeout-ms" : {
          "description" : "Maximum number of milliseconds to wait for records to flush and partition offset data to be committed to offset storage before cancelling the process and restoring the offset data to be committed in a future attempt. The default is 5 seconds.",
          "default" : "5s",
          "type" : "string"
        },
        "offset-flush-interval-ms" : {
          "description" : "Interval at which to try committing offsets. The default is 1 minute.",
          "default" : "60s",
          "type" : "string"
        },
        "offset-storage" : {
          "description" : "The name of the Java class that is responsible for persistence of connector offsets.",
          "default" : "org.apache.kafka.connect.storage.FileOffsetBackingStore",
          "type" : "string"
        },
        "offset-storage-file-name" : {
          "description" : "Path to file where offsets are to be stored. Required when offset.storage is set to the FileOffsetBackingStore.",
          "type" : "string"
        },
        "offset-storage-partitions" : {
          "description" : "The number of partitions used when creating the offset storage topic. Required when offset.storage is set to the 'KafkaOffsetBackingStore'.",
          "type" : "integer"
        },
        "offset-storage-replication-factor" : {
          "description" : "Replication factor used when creating the offset storage topic. Required when offset.storage is set to the KafkaOffsetBackingStore",
          "type" : "integer"
        },
        "offset-storage-topic" : {
          "description" : "The name of the Kafka topic where offsets are to be stored. Required when offset.storage is set to the KafkaOffsetBackingStore.",
          "type" : "string"
        },
        "poll-interval-ms" : {
          "description" : "Frequency in milliseconds to wait for new change events to appear after receiving no events. Defaults to 500ms.",
          "default" : "500ms",
          "type" : "string"
        },
        "skipped-operations" : {
          "description" : "The comma-separated list of operations to skip during streaming, defined as: 'i' for inserts; 'u' for updates; 'd' for deletes. By default, no operations will be skipped.",
          "type" : "string"
        },
        "snapshot-delay-ms" : {
          "description" : "The number of milliseconds to delay before a snapshot will begin.",
          "default" : "0ms",
          "type" : "string"
        },
        "snapshot-fetch-size" : {
          "description" : "The maximum number of records that should be loaded into memory while performing a snapshot",
          "type" : "integer"
        },
        "snapshot-locking-mode" : {
          "description" : "Controls how long the connector holds onto the global read lock while it is performing a snapshot. The default is 'minimal', which means the connector holds the global read lock (and thus prevents any updates) for just the initial portion of the snapshot while the database schemas and other metadata are being read. The remaining work in a snapshot involves selecting all rows from each table, and this can be done using the snapshot process' REPEATABLE READ transaction even when the lock is no longer held and other operations are updating the database. However, in some cases it may be desirable to block all writes for the entire duration of the snapshot; in such cases set this property to 'extended'. Using a value of 'none' will prevent the connector from acquiring any table locks during the snapshot process. This mode can only be used in combination with snapshot.mode values of 'schema_only' or 'schema_only_recovery' and is only safe to use if no schema changes are happening while the snapshot is taken.",
          "default" : "minimal",
          "type" : "string"
        },
        "snapshot-mode" : {
          "description" : "The criteria for running a snapshot upon startup of the connector. Options include: 'when_needed' to specify that the connector run a snapshot upon startup whenever it deems it necessary; 'schema_only' to only take a snapshot of the schema (table structures) but no actual data; 'initial' (the default) to specify the connector can run a snapshot only when no offsets are available for the logical server name; 'initial_only' same as 'initial' except the connector should stop after completing the snapshot and before it would normally read the binlog; and'never' to specify the connector should never run a snapshot and that upon first startup the connector should read from the beginning of the binlog. The 'never' mode should be used with care, and only when the binlog is known to contain all history.",
          "default" : "initial",
          "type" : "string"
        },
        "snapshot-new-tables" : {
          "description" : "BETA FEATURE: On connector restart, the connector will check if there have been any new tables added to the configuration, and snapshot them. There is presently only two options:'off': Default behavior. Do not snapshot new tables.'parallel': The snapshot of the new tables will occur in parallel to the continued binlog reading of the old tables. When the snapshot completes, an independent binlog reader will begin reading the events for the new tables until it catches up to present time. At this point, both old and new binlog readers will be momentarily halted and new binlog reader will start that will read the binlog for all configured tables. The parallel binlog reader will have a configured server id of 10000 the primary binlog reader's server id.",
          "default" : "off",
          "type" : "string"
        },
        "snapshot-select-statement-overrides" : {
          "description" : "This property contains a comma-separated list of fully-qualified tables (DB_NAME.TABLE_NAME) or (SCHEMA_NAME.TABLE_NAME), depending on thespecific connectors . Select statements for the individual tables are specified in further configuration properties, one for each table, identified by the id 'snapshot.select.statement.overrides.DB_NAME.TABLE_NAME' or 'snapshot.select.statement.overrides.SCHEMA_NAME.TABLE_NAME', respectively. The value of those properties is the select statement to use when retrieving data from the specific table during snapshotting. A possible use case for large append-only tables is setting a specific point where to start (resume) snapshotting, in case a previous snapshotting was interrupted.",
          "type" : "string"
        },
        "source-struct-version" : {
          "description" : "A version of the format of the publicly visible source part in the message",
          "default" : "v2",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "table-blacklist" : {
          "description" : "A comma-separated list of regular expressions that match the fully-qualified names of tables to be excluded from monitoring (deprecated, use table.exclude.list instead)",
          "type" : "string"
        },
        "table-exclude-list" : {
          "description" : "A comma-separated list of regular expressions that match the fully-qualified names of tables to be excluded from monitoring",
          "type" : "string"
        },
        "table-ignore-builtin" : {
          "description" : "Flag specifying whether built-in tables should be ignored.",
          "default" : "true",
          "type" : "boolean"
        },
        "table-include-list" : {
          "description" : "The tables for which changes are to be captured",
          "type" : "string"
        },
        "table-whitelist" : {
          "description" : "The tables for which changes are to be captured (deprecated, use table.include.list instead)",
          "type" : "string"
        },
        "time-precision-mode" : {
          "description" : "Time, date and timestamps can be represented with different kinds of precisions, including:'adaptive_time_microseconds': the precision of date and timestamp values is based the database column's precision; but time fields always use microseconds precision;'connect': always represents time, date and timestamp values using Kafka Connect's built-in representations for Time, Date, and Timestamp, which uses millisecond precision regardless of the database columns' precision.",
          "default" : "adaptive_time_microseconds",
          "type" : "string"
        },
        "tombstones-on-delete" : {
          "description" : "Whether delete operations should be represented by a delete event and a subsquenttombstone event (true) or only by a delete event (false). Emitting the tombstone event (the default behavior) allows Kafka to completely delete all events pertaining to the given key once the source record got deleted.",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "debezium-postgres" : {
      "type" : "object",
      "required" : [ "name", "databasePassword", "databaseServerName" ],
      "properties" : {
        "name" : {
          "description" : "Unique name for the connector. Attempting to register again with the same name will fail.",
          "type" : "string"
        },
        "additional-properties" : {
          "description" : "Additional properties for debezium components in case they can't be set directly on the camel configurations (e.g: setting Kafka Connect properties needed by Debezium engine, for example setting KafkaOffsetBackingStore), the properties have to be prefixed with additionalProperties.. E.g: additionalProperties.transactional.id=12345&additionalProperties.schema.registry.url=http://localhost:8811/avro",
          "type" : "string"
        },
        "binary-handling-mode" : {
          "description" : "Specify how binary (blob, binary, etc.) columns should be represented in change events, including:'bytes' represents binary data as byte array (default)'base64' represents binary data as base64-encoded string'hex' represents binary data as hex-encoded (base16) string",
          "default" : "bytes",
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "column-blacklist" : {
          "description" : "Regular expressions matching columns to exclude from change events (deprecated, use column.exclude.list instead)",
          "type" : "string"
        },
        "column-exclude-list" : {
          "description" : "Regular expressions matching columns to exclude from change events",
          "type" : "string"
        },
        "column-include-list" : {
          "description" : "Regular expressions matching columns to include in change events",
          "type" : "string"
        },
        "column-propagate-source-type" : {
          "description" : "A comma-separated list of regular expressions matching fully-qualified names of columns that adds the columns original type and original length as parameters to the corresponding field schemas in the emitted change records.",
          "type" : "string"
        },
        "column-whitelist" : {
          "description" : "Regular expressions matching columns to include in change events (deprecated, use column.include.list instead)",
          "type" : "string"
        },
        "converters" : {
          "description" : "Optional list of custom converters that would be used instead of default ones. The converters are defined using '.type' config option and configured using options '.'",
          "type" : "string"
        },
        "database-dbname" : {
          "description" : "The name of the database the connector should be monitoring",
          "type" : "string"
        },
        "database-history-file-filename" : {
          "description" : "The path to the file that will be used to record the database history",
          "type" : "string"
        },
        "database-hostname" : {
          "description" : "Resolvable hostname or IP address of the Postgres database server.",
          "type" : "string"
        },
        "database-initial-statements" : {
          "description" : "A semicolon separated list of SQL statements to be executed when a JDBC connection to the database is established. Note that the connector may establish JDBC connections at its own discretion, so this should typically be used for configurationof session parameters only, but not for executing DML statements. Use doubled semicolon (';;') to use a semicolon as a character and not as a delimiter.",
          "type" : "string"
        },
        "database-password" : {
          "description" : "Password of the Postgres database user to be used when connecting to the database.",
          "type" : "string"
        },
        "database-port" : {
          "description" : "Port of the Postgres database server.",
          "default" : "5432",
          "type" : "integer"
        },
        "database-server-name" : {
          "description" : "Unique name that identifies the database server and all recorded offsets, and that is used as a prefix for all schemas and topics. Each distinct installation should have a separate namespace and be monitored by at most one Debezium connector.",
          "type" : "string"
        },
        "database-sslcert" : {
          "description" : "File containing the SSL Certificate for the client. See the Postgres SSL docs for further information",
          "type" : "string"
        },
        "database-sslfactory" : {
          "description" : "A name of class to that creates SSL Sockets. Use org.postgresql.ssl.NonValidatingFactory to disable SSL validation in development environments",
          "type" : "string"
        },
        "database-sslkey" : {
          "description" : "File containing the SSL private key for the client. See the Postgres SSL docs for further information",
          "type" : "string"
        },
        "database-sslmode" : {
          "description" : "Whether to use an encrypted connection to Postgres. Options include'disable' (the default) to use an unencrypted connection; 'require' to use a secure (encrypted) connection, and fail if one cannot be established; 'verify-ca' like 'required' but additionally verify the server TLS certificate against the configured Certificate Authority (CA) certificates, or fail if no valid matching CA certificates are found; or'verify-full' like 'verify-ca' but additionally verify that the server certificate matches the host to which the connection is attempted.",
          "default" : "disable",
          "type" : "string"
        },
        "database-sslpassword" : {
          "description" : "Password to access the client private key from the file specified by 'database.sslkey'. See the Postgres SSL docs for further information",
          "type" : "string"
        },
        "database-sslrootcert" : {
          "description" : "File containing the root certificate(s) against which the server is validated. See the Postgres JDBC SSL docs for further information",
          "type" : "string"
        },
        "database-tcpkeepalive" : {
          "description" : "Enable or disable TCP keep-alive probe to avoid dropping TCP connection",
          "default" : "true",
          "type" : "boolean"
        },
        "database-user" : {
          "description" : "Name of the Postgres database user to be used when connecting to the database.",
          "type" : "string"
        },
        "datatype-propagate-source-type" : {
          "description" : "A comma-separated list of regular expressions matching the database-specific data type names that adds the data type's original type and original length as parameters to the corresponding field schemas in the emitted change records.",
          "type" : "string"
        },
        "decimal-handling-mode" : {
          "description" : "Specify how DECIMAL and NUMERIC columns should be represented in change events, including:'precise' (the default) uses java.math.BigDecimal to represent values, which are encoded in the change events using a binary representation and Kafka Connect's 'org.apache.kafka.connect.data.Decimal' type; 'string' uses string to represent values; 'double' represents values using Java's 'double', which may not offer the precision but will be far easier to use in consumers.",
          "default" : "precise",
          "type" : "string"
        },
        "event-processing-failure-handling-mode" : {
          "description" : "Specify how failures during processing of events (i.e. when encountering a corrupted event) should be handled, including:'fail' (the default) an exception indicating the problematic event and its position is raised, causing the connector to be stopped; 'warn' the problematic event and its position will be logged and the event will be skipped;'ignore' the problematic event will be skipped.",
          "default" : "fail",
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "heartbeat-action-query" : {
          "description" : "The query executed with every heartbeat.",
          "type" : "string"
        },
        "heartbeat-interval-ms" : {
          "description" : "Length of an interval in milli-seconds in in which the connector periodically sends heartbeat messages to a heartbeat topic. Use 0 to disable heartbeat messages. Disabled by default.",
          "default" : "0ms",
          "type" : "string"
        },
        "heartbeat-topics-prefix" : {
          "description" : "The prefix that is used to name heartbeat topics.Defaults to __debezium-heartbeat.",
          "default" : "__debezium-heartbeat",
          "type" : "string"
        },
        "hstore-handling-mode" : {
          "description" : "Specify how HSTORE columns should be represented in change events, including:'json' represents values as string-ified JSON (default)'map' represents values as a key/value map",
          "default" : "json",
          "type" : "string"
        },
        "include-unknown-datatypes" : {
          "description" : "Specify whether the fields of data type not supported by Debezium should be processed:'false' (the default) omits the fields; 'true' converts the field into an implementation dependent binary representation.",
          "default" : "false",
          "type" : "boolean"
        },
        "internal-key-converter" : {
          "description" : "The Converter class that should be used to serialize and deserialize key data for offsets. The default is JSON converter.",
          "default" : "org.apache.kafka.connect.json.JsonConverter",
          "type" : "string"
        },
        "internal-value-converter" : {
          "description" : "The Converter class that should be used to serialize and deserialize value data for offsets. The default is JSON converter.",
          "default" : "org.apache.kafka.connect.json.JsonConverter",
          "type" : "string"
        },
        "interval-handling-mode" : {
          "description" : "Specify how INTERVAL columns should be represented in change events, including:'string' represents values as an exact ISO formatted string'numeric' (default) represents values using the inexact conversion into microseconds",
          "default" : "numeric",
          "type" : "string"
        },
        "max-batch-size" : {
          "description" : "Maximum size of each batch of source records. Defaults to 2048.",
          "default" : "2048",
          "type" : "integer"
        },
        "max-queue-size" : {
          "description" : "Maximum size of the queue for change events read from the database log but not yet recorded or forwarded. Defaults to 8192, and should always be larger than the maximum batch size.",
          "default" : "8192",
          "type" : "integer"
        },
        "message-key-columns" : {
          "description" : "A semicolon-separated list of expressions that match fully-qualified tables and column(s) to be used as message key. Each expression must match the pattern ':',where the table names could be defined as (DB_NAME.TABLE_NAME) or (SCHEMA_NAME.TABLE_NAME), depending on the specific connector,and the key columns are a comma-separated list of columns representing the custom key. For any table without an explicit key configuration the table's primary key column(s) will be used as message key.Example: dbserver1.inventory.orderlines:orderId,orderLineId;dbserver1.inventory.orders:id",
          "type" : "string"
        },
        "offset-commit-policy" : {
          "description" : "The name of the Java class of the commit policy. It defines when offsets commit has to be triggered based on the number of events processed and the time elapsed since the last commit. This class must implement the interface 'OffsetCommitPolicy'. The default is a periodic commit policy based upon time intervals.",
          "default" : "io.debezium.embedded.spi.OffsetCommitPolicy.PeriodicCommitOffsetPolicy",
          "type" : "string"
        },
        "offset-commit-timeout-ms" : {
          "description" : "Maximum number of milliseconds to wait for records to flush and partition offset data to be committed to offset storage before cancelling the process and restoring the offset data to be committed in a future attempt. The default is 5 seconds.",
          "default" : "5s",
          "type" : "string"
        },
        "offset-flush-interval-ms" : {
          "description" : "Interval at which to try committing offsets. The default is 1 minute.",
          "default" : "60s",
          "type" : "string"
        },
        "offset-storage" : {
          "description" : "The name of the Java class that is responsible for persistence of connector offsets.",
          "default" : "org.apache.kafka.connect.storage.FileOffsetBackingStore",
          "type" : "string"
        },
        "offset-storage-file-name" : {
          "description" : "Path to file where offsets are to be stored. Required when offset.storage is set to the FileOffsetBackingStore.",
          "type" : "string"
        },
        "offset-storage-partitions" : {
          "description" : "The number of partitions used when creating the offset storage topic. Required when offset.storage is set to the 'KafkaOffsetBackingStore'.",
          "type" : "integer"
        },
        "offset-storage-replication-factor" : {
          "description" : "Replication factor used when creating the offset storage topic. Required when offset.storage is set to the KafkaOffsetBackingStore",
          "type" : "integer"
        },
        "offset-storage-topic" : {
          "description" : "The name of the Kafka topic where offsets are to be stored. Required when offset.storage is set to the KafkaOffsetBackingStore.",
          "type" : "string"
        },
        "plugin-name" : {
          "description" : "The name of the Postgres logical decoding plugin installed on the server. Supported values are 'decoderbufs' and 'wal2json'. Defaults to 'decoderbufs'.",
          "default" : "decoderbufs",
          "type" : "string"
        },
        "poll-interval-ms" : {
          "description" : "Frequency in milliseconds to wait for new change events to appear after receiving no events. Defaults to 500ms.",
          "default" : "500ms",
          "type" : "string"
        },
        "provide-transaction-metadata" : {
          "description" : "Enables transaction metadata extraction together with event counting",
          "default" : "false",
          "type" : "boolean"
        },
        "publication-autocreate-mode" : {
          "description" : "Applies only when streaming changes using pgoutput.Determine how creation of a publication should work, the default is all_tables.DISABLED - The connector will not attempt to create a publication at all. The expectation is that the user has created the publication up-front. If the publication isn't found to exist upon startup, the connector will throw an exception and stop.ALL_TABLES - If no publication exists, the connector will create a new publication for all tables. Note this requires that the configured user has access. If the publication already exists, it will be used. i.e CREATE PUBLICATION FOR ALL TABLES;FILTERED - If no publication exists, the connector will create a new publication for all those tables matchingthe current filter configuration (see table/database include/exclude list properties). If the publication already exists, it will be used. i.e CREATE PUBLICATION FOR TABLE",
          "default" : "all_tables",
          "type" : "string"
        },
        "publication-name" : {
          "description" : "The name of the Postgres 10 publication used for streaming changes from a plugin.Defaults to 'dbz_publication'",
          "default" : "dbz_publication",
          "type" : "string"
        },
        "query-fetch-size" : {
          "description" : "The maximum number of records that should be loaded into memory while streaming. A value of 0 uses the default JDBC fetch size.",
          "default" : "0",
          "type" : "integer"
        },
        "retriable-restart-connector-wait-ms" : {
          "description" : "Time to wait before restarting connector after retriable exception occurs. Defaults to 10000ms.",
          "default" : "10s",
          "type" : "string"
        },
        "sanitize-field-names" : {
          "description" : "Whether field names will be sanitized to Avro naming conventions",
          "default" : "false",
          "type" : "boolean"
        },
        "schema-blacklist" : {
          "description" : "The schemas for which events must not be captured (deprecated, use schema.exclude.list instead)",
          "type" : "string"
        },
        "schema-exclude-list" : {
          "description" : "The schemas for which events must not be captured",
          "type" : "string"
        },
        "schema-include-list" : {
          "description" : "The schemas for which events should be captured",
          "type" : "string"
        },
        "schema-refresh-mode" : {
          "description" : "Specify the conditions that trigger a refresh of the in-memory schema for a table. 'columns_diff' (the default) is the safest mode, ensuring the in-memory schema stays in-sync with the database table's schema at all times. 'columns_diff_exclude_unchanged_toast' instructs the connector to refresh the in-memory schema cache if there is a discrepancy between it and the schema derived from the incoming message, unless unchanged TOASTable data fully accounts for the discrepancy. This setting can improve connector performance significantly if there are frequently-updated tables that have TOASTed data that are rarely part of these updates. However, it is possible for the in-memory schema to become outdated if TOASTable columns are dropped from the table.",
          "default" : "columns_diff",
          "type" : "string"
        },
        "schema-whitelist" : {
          "description" : "The schemas for which events should be captured (deprecated, use schema.include.list instead)",
          "type" : "string"
        },
        "skipped-operations" : {
          "description" : "The comma-separated list of operations to skip during streaming, defined as: 'i' for inserts; 'u' for updates; 'd' for deletes. By default, no operations will be skipped.",
          "type" : "string"
        },
        "slot-drop-on-stop" : {
          "description" : "Whether or not to drop the logical replication slot when the connector finishes orderlyBy default the replication is kept so that on restart progress can resume from the last recorded location",
          "default" : "false",
          "type" : "boolean"
        },
        "slot-max-retries" : {
          "description" : "How many times to retry connecting to a replication slot when an attempt fails.",
          "default" : "6",
          "type" : "integer"
        },
        "slot-name" : {
          "description" : "The name of the Postgres logical decoding slot created for streaming changes from a plugin.Defaults to 'debezium",
          "default" : "debezium",
          "type" : "string"
        },
        "slot-retry-delay-ms" : {
          "description" : "The number of milli-seconds to wait between retry attempts when the connector fails to connect to a replication slot.",
          "default" : "10s",
          "type" : "string"
        },
        "slot-stream-params" : {
          "description" : "Any optional parameters used by logical decoding plugin. Semi-colon separated. E.g. 'add-tables=public.table,public.table2;include-lsn=true'",
          "type" : "string"
        },
        "snapshot-custom-class" : {
          "description" : "When 'snapshot.mode' is set as custom, this setting must be set to specify a fully qualified class name to load (via the default class loader).This class must implement the 'Snapshotter' interface and is called on each app boot to determine whether to do a snapshot and how to build queries.",
          "type" : "string"
        },
        "snapshot-delay-ms" : {
          "description" : "The number of milliseconds to delay before a snapshot will begin.",
          "default" : "0ms",
          "type" : "string"
        },
        "snapshot-fetch-size" : {
          "description" : "The maximum number of records that should be loaded into memory while performing a snapshot",
          "type" : "integer"
        },
        "snapshot-lock-timeout-ms" : {
          "description" : "The maximum number of millis to wait for table locks at the beginning of a snapshot. If locks cannot be acquired in this time frame, the snapshot will be aborted. Defaults to 10 seconds",
          "default" : "10s",
          "type" : "string"
        },
        "snapshot-mode" : {
          "description" : "The criteria for running a snapshot upon startup of the connector. Options include: 'always' to specify that the connector run a snapshot each time it starts up; 'initial' (the default) to specify the connector can run a snapshot only when no offsets are available for the logical server name; 'initial_only' same as 'initial' except the connector should stop after completing the snapshot and before it would normally start emitting changes;'never' to specify the connector should never run a snapshot and that upon first startup the connector should read from the last position (LSN) recorded by the server; and'exported' to specify the connector should run a snapshot based on the position when the replication slot was created; 'custom' to specify a custom class with 'snapshot.custom_class' which will be loaded and used to determine the snapshot, see docs for more details.",
          "default" : "initial",
          "type" : "string"
        },
        "snapshot-select-statement-overrides" : {
          "description" : "This property contains a comma-separated list of fully-qualified tables (DB_NAME.TABLE_NAME) or (SCHEMA_NAME.TABLE_NAME), depending on thespecific connectors . Select statements for the individual tables are specified in further configuration properties, one for each table, identified by the id 'snapshot.select.statement.overrides.DB_NAME.TABLE_NAME' or 'snapshot.select.statement.overrides.SCHEMA_NAME.TABLE_NAME', respectively. The value of those properties is the select statement to use when retrieving data from the specific table during snapshotting. A possible use case for large append-only tables is setting a specific point where to start (resume) snapshotting, in case a previous snapshotting was interrupted.",
          "type" : "string"
        },
        "source-struct-version" : {
          "description" : "A version of the format of the publicly visible source part in the message",
          "default" : "v2",
          "type" : "string"
        },
        "status-update-interval-ms" : {
          "description" : "Frequency in milliseconds for sending replication connection status updates to the server. Defaults to 10 seconds (10000 ms).",
          "default" : "10s",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "table-blacklist" : {
          "description" : "A comma-separated list of regular expressions that match the fully-qualified names of tables to be excluded from monitoring (deprecated, use table.exclude.list instead)",
          "type" : "string"
        },
        "table-exclude-list" : {
          "description" : "A comma-separated list of regular expressions that match the fully-qualified names of tables to be excluded from monitoring",
          "type" : "string"
        },
        "table-ignore-builtin" : {
          "description" : "Flag specifying whether built-in tables should be ignored.",
          "default" : "true",
          "type" : "boolean"
        },
        "table-include-list" : {
          "description" : "The tables for which changes are to be captured",
          "type" : "string"
        },
        "table-whitelist" : {
          "description" : "The tables for which changes are to be captured (deprecated, use table.include.list instead)",
          "type" : "string"
        },
        "time-precision-mode" : {
          "description" : "Time, date, and timestamps can be represented with different kinds of precisions, including:'adaptive' (the default) bases the precision of time, date, and timestamp values on the database column's precision; 'adaptive_time_microseconds' like 'adaptive' mode, but TIME fields always use microseconds precision;'connect' always represents time, date, and timestamp values using Kafka Connect's built-in representations for Time, Date, and Timestamp, which uses millisecond precision regardless of the database columns' precision .",
          "default" : "adaptive",
          "type" : "string"
        },
        "toasted-value-placeholder" : {
          "description" : "Specify the constant that will be provided by Debezium to indicate that the original value is a toasted value not provided by the database. If starts with 'hex:' prefix it is expected that the rest of the string repesents hexadecimally encoded octets.",
          "default" : "__debezium_unavailable_value",
          "type" : "string"
        },
        "tombstones-on-delete" : {
          "description" : "Whether delete operations should be represented by a delete event and a subsquenttombstone event (true) or only by a delete event (false). Emitting the tombstone event (the default behavior) allows Kafka to completely delete all events pertaining to the given key once the source record got deleted.",
          "default" : "false",
          "type" : "boolean"
        },
        "xmin-fetch-interval-ms" : {
          "description" : "Specify how often (in ms) the xmin will be fetched from the replication slot. This xmin value is exposed by the slot which gives a lower bound of where a new replication slot could start from. The lower the value, the more likely this value is to be the current 'true' value, but the bigger the performance cost. The bigger the value, the less likely this value is to be the current 'true' value, but the lower the performance penalty. The default is set to 0 ms, which disables tracking xmin.",
          "default" : "0ms",
          "type" : "string"
        }
      }
    },
    "debezium-sqlserver" : {
      "type" : "object",
      "required" : [ "name", "databasePassword", "databaseServerName" ],
      "properties" : {
        "name" : {
          "description" : "Unique name for the connector. Attempting to register again with the same name will fail.",
          "type" : "string"
        },
        "additional-properties" : {
          "description" : "Additional properties for debezium components in case they can't be set directly on the camel configurations (e.g: setting Kafka Connect properties needed by Debezium engine, for example setting KafkaOffsetBackingStore), the properties have to be prefixed with additionalProperties.. E.g: additionalProperties.transactional.id=12345&additionalProperties.schema.registry.url=http://localhost:8811/avro",
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "column-blacklist" : {
          "description" : "Regular expressions matching columns to exclude from change events (deprecated, use column.exclude.list instead)",
          "type" : "string"
        },
        "column-exclude-list" : {
          "description" : "Regular expressions matching columns to exclude from change events",
          "type" : "string"
        },
        "column-include-list" : {
          "description" : "Regular expressions matching columns to include in change events",
          "type" : "string"
        },
        "column-propagate-source-type" : {
          "description" : "A comma-separated list of regular expressions matching fully-qualified names of columns that adds the columns original type and original length as parameters to the corresponding field schemas in the emitted change records.",
          "type" : "string"
        },
        "column-whitelist" : {
          "description" : "Regular expressions matching columns to include in change events (deprecated, use column.include.list instead)",
          "type" : "string"
        },
        "converters" : {
          "description" : "Optional list of custom converters that would be used instead of default ones. The converters are defined using '.type' config option and configured using options '.'",
          "type" : "string"
        },
        "database-dbname" : {
          "description" : "The name of the database the connector should be monitoring. When working with a multi-tenant set-up, must be set to the CDB name.",
          "type" : "string"
        },
        "database-history" : {
          "description" : "The name of the DatabaseHistory class that should be used to store and recover database schema changes. The configuration properties for the history are prefixed with the 'database.history.' string.",
          "default" : "io.debezium.relational.history.FileDatabaseHistory",
          "type" : "string"
        },
        "database-history-file-filename" : {
          "description" : "The path to the file that will be used to record the database history",
          "type" : "string"
        },
        "database-history-kafka-bootstrap-servers" : {
          "description" : "A list of host/port pairs that the connector will use for establishing the initial connection to the Kafka cluster for retrieving database schema history previously stored by the connector. This should point to the same Kafka cluster used by the Kafka Connect process.",
          "type" : "string"
        },
        "database-history-kafka-recovery-attempts" : {
          "description" : "The number of attempts in a row that no data are returned from Kafka before recover completes. The maximum amount of time to wait after receiving no data is (recovery.attempts) x (recovery.poll.interval.ms).",
          "default" : "100",
          "type" : "integer"
        },
        "database-history-kafka-recovery-poll-interval-ms" : {
          "description" : "The number of milliseconds to wait while polling for persisted data during recovery.",
          "default" : "100ms",
          "type" : "string"
        },
        "database-history-kafka-topic" : {
          "description" : "The name of the topic for the database schema history",
          "type" : "string"
        },
        "database-hostname" : {
          "description" : "Resolvable hostname or IP address of the SQL Server database server.",
          "type" : "string"
        },
        "database-instance" : {
          "description" : "The SQL Server instance name",
          "type" : "string"
        },
        "database-password" : {
          "description" : "Password of the SQL Server database user to be used when connecting to the database.",
          "type" : "string"
        },
        "database-port" : {
          "description" : "Port of the SQL Server database server.",
          "default" : "1433",
          "type" : "integer"
        },
        "database-server-name" : {
          "description" : "Unique name that identifies the database server and all recorded offsets, and that is used as a prefix for all schemas and topics. Each distinct installation should have a separate namespace and be monitored by at most one Debezium connector.",
          "type" : "string"
        },
        "database-server-timezone" : {
          "description" : "The timezone of the server used to correctly shift the commit transaction timestamp on the client sideOptions include: Any valid Java ZoneId",
          "type" : "string"
        },
        "database-user" : {
          "description" : "Name of the SQL Server database user to be used when connecting to the database.",
          "type" : "string"
        },
        "datatype-propagate-source-type" : {
          "description" : "A comma-separated list of regular expressions matching the database-specific data type names that adds the data type's original type and original length as parameters to the corresponding field schemas in the emitted change records.",
          "type" : "string"
        },
        "decimal-handling-mode" : {
          "description" : "Specify how DECIMAL and NUMERIC columns should be represented in change events, including:'precise' (the default) uses java.math.BigDecimal to represent values, which are encoded in the change events using a binary representation and Kafka Connect's 'org.apache.kafka.connect.data.Decimal' type; 'string' uses string to represent values; 'double' represents values using Java's 'double', which may not offer the precision but will be far easier to use in consumers.",
          "default" : "precise",
          "type" : "string"
        },
        "event-processing-failure-handling-mode" : {
          "description" : "Specify how failures during processing of events (i.e. when encountering a corrupted event) should be handled, including:'fail' (the default) an exception indicating the problematic event and its position is raised, causing the connector to be stopped; 'warn' the problematic event and its position will be logged and the event will be skipped;'ignore' the problematic event will be skipped.",
          "default" : "fail",
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "heartbeat-interval-ms" : {
          "description" : "Length of an interval in milli-seconds in in which the connector periodically sends heartbeat messages to a heartbeat topic. Use 0 to disable heartbeat messages. Disabled by default.",
          "default" : "0ms",
          "type" : "string"
        },
        "heartbeat-topics-prefix" : {
          "description" : "The prefix that is used to name heartbeat topics.Defaults to __debezium-heartbeat.",
          "default" : "__debezium-heartbeat",
          "type" : "string"
        },
        "include-schema-changes" : {
          "description" : "Whether the connector should publish changes in the database schema to a Kafka topic with the same name as the database server ID. Each schema change will be recorded using a key that contains the database name and whose value include logical description of the new schema and optionally the DDL statement(s).The default is 'true'. This is independent of how the connector internally records database history.",
          "default" : "true",
          "type" : "boolean"
        },
        "internal-key-converter" : {
          "description" : "The Converter class that should be used to serialize and deserialize key data for offsets. The default is JSON converter.",
          "default" : "org.apache.kafka.connect.json.JsonConverter",
          "type" : "string"
        },
        "internal-value-converter" : {
          "description" : "The Converter class that should be used to serialize and deserialize value data for offsets. The default is JSON converter.",
          "default" : "org.apache.kafka.connect.json.JsonConverter",
          "type" : "string"
        },
        "max-batch-size" : {
          "description" : "Maximum size of each batch of source records. Defaults to 2048.",
          "default" : "2048",
          "type" : "integer"
        },
        "max-queue-size" : {
          "description" : "Maximum size of the queue for change events read from the database log but not yet recorded or forwarded. Defaults to 8192, and should always be larger than the maximum batch size.",
          "default" : "8192",
          "type" : "integer"
        },
        "message-key-columns" : {
          "description" : "A semicolon-separated list of expressions that match fully-qualified tables and column(s) to be used as message key. Each expression must match the pattern ':',where the table names could be defined as (DB_NAME.TABLE_NAME) or (SCHEMA_NAME.TABLE_NAME), depending on the specific connector,and the key columns are a comma-separated list of columns representing the custom key. For any table without an explicit key configuration the table's primary key column(s) will be used as message key.Example: dbserver1.inventory.orderlines:orderId,orderLineId;dbserver1.inventory.orders:id",
          "type" : "string"
        },
        "offset-commit-policy" : {
          "description" : "The name of the Java class of the commit policy. It defines when offsets commit has to be triggered based on the number of events processed and the time elapsed since the last commit. This class must implement the interface 'OffsetCommitPolicy'. The default is a periodic commit policy based upon time intervals.",
          "default" : "io.debezium.embedded.spi.OffsetCommitPolicy.PeriodicCommitOffsetPolicy",
          "type" : "string"
        },
        "offset-commit-timeout-ms" : {
          "description" : "Maximum number of milliseconds to wait for records to flush and partition offset data to be committed to offset storage before cancelling the process and restoring the offset data to be committed in a future attempt. The default is 5 seconds.",
          "default" : "5s",
          "type" : "string"
        },
        "offset-flush-interval-ms" : {
          "description" : "Interval at which to try committing offsets. The default is 1 minute.",
          "default" : "60s",
          "type" : "string"
        },
        "offset-storage" : {
          "description" : "The name of the Java class that is responsible for persistence of connector offsets.",
          "default" : "org.apache.kafka.connect.storage.FileOffsetBackingStore",
          "type" : "string"
        },
        "offset-storage-file-name" : {
          "description" : "Path to file where offsets are to be stored. Required when offset.storage is set to the FileOffsetBackingStore.",
          "type" : "string"
        },
        "offset-storage-partitions" : {
          "description" : "The number of partitions used when creating the offset storage topic. Required when offset.storage is set to the 'KafkaOffsetBackingStore'.",
          "type" : "integer"
        },
        "offset-storage-replication-factor" : {
          "description" : "Replication factor used when creating the offset storage topic. Required when offset.storage is set to the KafkaOffsetBackingStore",
          "type" : "integer"
        },
        "offset-storage-topic" : {
          "description" : "The name of the Kafka topic where offsets are to be stored. Required when offset.storage is set to the KafkaOffsetBackingStore.",
          "type" : "string"
        },
        "poll-interval-ms" : {
          "description" : "Frequency in milliseconds to wait for new change events to appear after receiving no events. Defaults to 500ms.",
          "default" : "500ms",
          "type" : "string"
        },
        "provide-transaction-metadata" : {
          "description" : "Enables transaction metadata extraction together with event counting",
          "default" : "false",
          "type" : "boolean"
        },
        "query-fetch-size" : {
          "description" : "The maximum number of records that should be loaded into memory while streaming. A value of 0 uses the default JDBC fetch size.",
          "default" : "0",
          "type" : "integer"
        },
        "retriable-restart-connector-wait-ms" : {
          "description" : "Time to wait before restarting connector after retriable exception occurs. Defaults to 10000ms.",
          "default" : "10s",
          "type" : "string"
        },
        "sanitize-field-names" : {
          "description" : "Whether field names will be sanitized to Avro naming conventions",
          "default" : "false",
          "type" : "boolean"
        },
        "skipped-operations" : {
          "description" : "The comma-separated list of operations to skip during streaming, defined as: 'i' for inserts; 'u' for updates; 'd' for deletes. By default, no operations will be skipped.",
          "type" : "string"
        },
        "snapshot-delay-ms" : {
          "description" : "The number of milliseconds to delay before a snapshot will begin.",
          "default" : "0ms",
          "type" : "string"
        },
        "snapshot-fetch-size" : {
          "description" : "The maximum number of records that should be loaded into memory while performing a snapshot",
          "type" : "integer"
        },
        "snapshot-isolation-mode" : {
          "description" : "Controls which transaction isolation level is used and how long the connector locks the monitored tables. The default is 'repeatable_read', which means that repeatable read isolation level is used. In addition, exclusive locks are taken only during schema snapshot. Using a value of 'exclusive' ensures that the connector holds the exclusive lock (and thus prevents any reads and updates) for all monitored tables during the entire snapshot duration. When 'snapshot' is specified, connector runs the initial snapshot in SNAPSHOT isolation level, which guarantees snapshot consistency. In addition, neither table nor row-level locks are held. When 'read_committed' is specified, connector runs the initial snapshot in READ COMMITTED isolation level. No long-running locks are taken, so that initial snapshot does not prevent other transactions from updating table rows. Snapshot consistency is not guaranteed.In 'read_uncommitted' mode neither table nor row-level locks are acquired, but connector does not guarantee snapshot consistency.",
          "default" : "repeatable_read",
          "type" : "string"
        },
        "snapshot-lock-timeout-ms" : {
          "description" : "The maximum number of millis to wait for table locks at the beginning of a snapshot. If locks cannot be acquired in this time frame, the snapshot will be aborted. Defaults to 10 seconds",
          "default" : "10s",
          "type" : "string"
        },
        "snapshot-mode" : {
          "description" : "The criteria for running a snapshot upon startup of the connector. Options include: 'initial' (the default) to specify the connector should run a snapshot only when no offsets are available for the logical server name; 'schema_only' to specify the connector should run a snapshot of the schema when no offsets are available for the logical server name.",
          "default" : "initial",
          "type" : "string"
        },
        "snapshot-select-statement-overrides" : {
          "description" : "This property contains a comma-separated list of fully-qualified tables (DB_NAME.TABLE_NAME) or (SCHEMA_NAME.TABLE_NAME), depending on thespecific connectors . Select statements for the individual tables are specified in further configuration properties, one for each table, identified by the id 'snapshot.select.statement.overrides.DB_NAME.TABLE_NAME' or 'snapshot.select.statement.overrides.SCHEMA_NAME.TABLE_NAME', respectively. The value of those properties is the select statement to use when retrieving data from the specific table during snapshotting. A possible use case for large append-only tables is setting a specific point where to start (resume) snapshotting, in case a previous snapshotting was interrupted.",
          "type" : "string"
        },
        "source-struct-version" : {
          "description" : "A version of the format of the publicly visible source part in the message",
          "default" : "v2",
          "type" : "string"
        },
        "source-timestamp-mode" : {
          "description" : "Configures the criteria of the attached timestamp within the source record (ts_ms).Options include:'commit', (default) the source timestamp is set to the instant where the record was committed in the database'processing', the source timestamp is set to the instant where the record was processed by Debezium.",
          "default" : "commit",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "table-blacklist" : {
          "description" : "A comma-separated list of regular expressions that match the fully-qualified names of tables to be excluded from monitoring (deprecated, use table.exclude.list instead)",
          "type" : "string"
        },
        "table-exclude-list" : {
          "description" : "A comma-separated list of regular expressions that match the fully-qualified names of tables to be excluded from monitoring",
          "type" : "string"
        },
        "table-ignore-builtin" : {
          "description" : "Flag specifying whether built-in tables should be ignored.",
          "default" : "true",
          "type" : "boolean"
        },
        "table-include-list" : {
          "description" : "The tables for which changes are to be captured",
          "type" : "string"
        },
        "table-whitelist" : {
          "description" : "The tables for which changes are to be captured (deprecated, use table.include.list instead)",
          "type" : "string"
        },
        "time-precision-mode" : {
          "description" : "Time, date, and timestamps can be represented with different kinds of precisions, including:'adaptive' (the default) bases the precision of time, date, and timestamp values on the database column's precision; 'adaptive_time_microseconds' like 'adaptive' mode, but TIME fields always use microseconds precision;'connect' always represents time, date, and timestamp values using Kafka Connect's built-in representations for Time, Date, and Timestamp, which uses millisecond precision regardless of the database columns' precision .",
          "default" : "adaptive",
          "type" : "string"
        },
        "tombstones-on-delete" : {
          "description" : "Whether delete operations should be represented by a delete event and a subsquenttombstone event (true) or only by a delete event (false). Emitting the tombstone event (the default behavior) allows Kafka to completely delete all events pertaining to the given key once the source record got deleted.",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "digitalocean" : {
      "type" : "object",
      "properties" : {
        "operation" : {
          "description" : "The operation to perform to the given resource.",
          "enum" : [ "create", "update", "delete", "list", "ownList", "get", "listBackups", "listActions", "listNeighbors", "listSnapshots", "listKernels", "listAllNeighbors", "enableBackups", "disableBackups", "reboot", "powerCycle", "shutdown", "powerOn", "powerOff", "restore", "resetPassword", "resize", "rebuild", "rename", "changeKernel", "enableIpv6", "enablePrivateNetworking", "takeSnapshot", "transfer", "convert", "attach", "detach", "assign", "unassign", "tag", "untag" ],
          "type" : "string"
        },
        "digital-ocean-client" : {
          "description" : "To use a existing configured DigitalOceanClient as client",
          "type" : "string"
        },
        "http-proxy-host" : {
          "description" : "Set a proxy host if needed",
          "type" : "string"
        },
        "http-proxy-password" : {
          "description" : "Set a proxy password if needed",
          "type" : "string"
        },
        "http-proxy-port" : {
          "description" : "Set a proxy port if needed",
          "type" : "integer"
        },
        "http-proxy-user" : {
          "description" : "Set a proxy host if needed",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "o-auth-token" : {
          "description" : "DigitalOcean OAuth Token",
          "type" : "string"
        },
        "page" : {
          "description" : "Use for pagination. Force the page number.",
          "default" : "1",
          "type" : "integer"
        },
        "per-page" : {
          "description" : "Use for pagination. Set the number of item per request. The maximum number of results per page is 200.",
          "default" : "25",
          "type" : "integer"
        },
        "resource" : {
          "description" : "The DigitalOcean resource type on which perform the operation.",
          "enum" : [ "account", "actions", "blockStorages", "droplets", "mages", "snapshots", "keys", "regions", "sizes", "floatingIPs", "tags" ],
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        }
      },
      "required" : [ "resource" ]
    },
    "direct" : {
      "type" : "object",
      "required" : [ "name" ],
      "properties" : {
        "name" : {
          "description" : "Name of direct endpoint",
          "type" : "string"
        },
        "block" : {
          "description" : "If sending a message to a direct endpoint which has no active consumer, then we can tell the producer to block and wait for the consumer to become active.",
          "default" : "true",
          "type" : "boolean"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "fail-if-no-consumers" : {
          "description" : "Whether the producer should fail by throwing an exception, when sending to a DIRECT endpoint with no active consumers.",
          "default" : "true",
          "type" : "boolean"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "timeout" : {
          "description" : "The timeout value to use if block is enabled.",
          "default" : "30000",
          "type" : "integer"
        }
      }
    },
    "direct-vm" : {
      "type" : "object",
      "required" : [ "name" ],
      "properties" : {
        "name" : {
          "description" : "Name of direct-vm endpoint",
          "type" : "string"
        },
        "block" : {
          "description" : "If sending a message to a direct endpoint which has no active consumer, then we can tell the producer to block and wait for the consumer to become active.",
          "default" : "true",
          "type" : "boolean"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "fail-if-no-consumers" : {
          "description" : "Whether the producer should fail by throwing an exception, when sending to a Direct-VM endpoint with no active consumers.",
          "default" : "false",
          "type" : "boolean"
        },
        "header-filter-strategy" : {
          "description" : "Sets a HeaderFilterStrategy that will only be applied on producer endpoints (on both directions: request and response). Default value: none.",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "propagate-properties" : {
          "description" : "Whether to propagate or not properties from the producer side to the consumer side, and vice versa. Default value: true.",
          "default" : "true",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "timeout" : {
          "description" : "The timeout value to use if block is enabled.",
          "default" : "30000",
          "type" : "string"
        }
      }
    },
    "disruptor" : {
      "type" : "object",
      "required" : [ "name" ],
      "properties" : {
        "name" : {
          "description" : "Name of queue",
          "type" : "string"
        },
        "block-when-full" : {
          "description" : "Whether a thread that sends messages to a full Disruptor will block until the ringbuffer's capacity is no longer exhausted. By default, the calling thread will block and wait until the message can be accepted. By disabling this option, an exception will be thrown stating that the queue is full.",
          "default" : "false",
          "type" : "boolean"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "concurrent-consumers" : {
          "description" : "Number of concurrent threads processing exchanges.",
          "default" : "1",
          "type" : "integer"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "multiple-consumers" : {
          "description" : "Specifies whether multiple consumers are allowed. If enabled, you can use Disruptor for Publish-Subscribe messaging. That is, you can send a message to the queue and have each consumer receive a copy of the message. When enabled, this option should be specified on every consumer endpoint.",
          "default" : "false",
          "type" : "boolean"
        },
        "producer-type" : {
          "description" : "Defines the producers allowed on the Disruptor. The options allowed are: Multi to allow multiple producers and Single to enable certain optimizations only allowed when one concurrent producer (on one thread or otherwise synchronized) is active.",
          "default" : "Multi",
          "enum" : [ "Single", "Multi" ],
          "type" : "string"
        },
        "size" : {
          "description" : "The maximum capacity of the Disruptors ringbuffer Will be effectively increased to the nearest power of two. Notice: Mind if you use this option, then its the first endpoint being created with the queue name, that determines the size. To make sure all endpoints use same size, then configure the size option on all of them, or the first endpoint being created.",
          "default" : "1024",
          "type" : "integer"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "timeout" : {
          "description" : "Timeout (in milliseconds) before a producer will stop waiting for an asynchronous task to complete. You can disable timeout by using 0 or a negative value.",
          "default" : "30000",
          "type" : "string"
        },
        "wait-for-task-to-complete" : {
          "description" : "Option to specify whether the caller should wait for the async task to complete or not before continuing. The following three options are supported: Always, Never or IfReplyExpected. The first two values are self-explanatory. The last value, IfReplyExpected, will only wait if the message is Request Reply based.",
          "default" : "IfReplyExpected",
          "enum" : [ "Never", "IfReplyExpected", "Always" ],
          "type" : "string"
        },
        "wait-strategy" : {
          "description" : "Defines the strategy used by consumer threads to wait on new exchanges to be published. The options allowed are:Blocking, Sleeping, BusySpin and Yielding.",
          "default" : "Blocking",
          "enum" : [ "Blocking", "Sleeping", "BusySpin", "Yielding" ],
          "type" : "string"
        }
      }
    },
    "disruptor-vm" : {
      "type" : "object",
      "$ref" : "#/definitions/disruptor"
    },
    "djl" : {
      "type" : "object",
      "required" : [ "application" ],
      "properties" : {
        "application" : {
          "description" : "Application name",
          "type" : "string"
        },
        "artifact-id" : {
          "description" : "Model Artifact",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "model" : {
          "description" : "Model",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "translator" : {
          "description" : "Translator",
          "type" : "string"
        }
      }
    },
    "dns" : {
      "type" : "object",
      "required" : [ "dnsType" ],
      "properties" : {
        "dns-type" : {
          "description" : "The type of the lookup.",
          "enum" : [ "dig", "ip", "lookup", "wikipedia" ],
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "docker" : {
      "type" : "object",
      "required" : [ "operation", "host" ],
      "properties" : {
        "operation" : {
          "description" : "Which operation to use",
          "enum" : [ "events", "stats", "auth", "info", "ping", "version", "imagebuild", "imagecreate", "imageinspect", "imagelist", "imagepull", "imagepushimageremove", "imagesearch", "imagetag", "containerattach", "containercommit", "containercopyfile", "containercreate", "containerdiffinspectcontainer", "containerkill", "containerlist", "containerlog", "containerpause", "containerrestart", "containerremove", "containerstartcontainerstop", "containertop", "containerunpause", "containerwait", "execcreate", "execstart" ],
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "cert-path" : {
          "description" : "Location containing the SSL certificate chain",
          "type" : "string"
        },
        "cmd-exec-factory" : {
          "description" : "The fully qualified class name of the DockerCmdExecFactory implementation to use",
          "default" : "com.github.dockerjava.netty.NettyDockerCmdExecFactory",
          "type" : "string"
        },
        "email" : {
          "description" : "Email address associated with the user",
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "follow-redirect-filter" : {
          "description" : "Whether to follow redirect filter",
          "default" : "false",
          "type" : "boolean"
        },
        "host" : {
          "description" : "Docker host",
          "default" : "localhost",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "logging-filter" : {
          "description" : "Whether to use logging filter",
          "default" : "false",
          "type" : "boolean"
        },
        "max-per-route-connections" : {
          "description" : "Maximum route connections",
          "default" : "100",
          "type" : "integer"
        },
        "max-total-connections" : {
          "description" : "Maximum total connections",
          "default" : "100",
          "type" : "integer"
        },
        "parameters" : {
          "description" : "Additional configuration parameters as key/value pairs",
          "type" : "string"
        },
        "password" : {
          "description" : "Password to authenticate with",
          "type" : "string"
        },
        "port" : {
          "description" : "Docker port",
          "default" : "2375",
          "type" : "integer"
        },
        "request-timeout" : {
          "description" : "Request timeout for response (in seconds)",
          "type" : "integer"
        },
        "secure" : {
          "description" : "Use HTTPS communication",
          "default" : "false",
          "type" : "boolean"
        },
        "server-address" : {
          "description" : "Server address for docker registry.",
          "default" : "https://index.docker.io/v1/",
          "type" : "string"
        },
        "socket" : {
          "description" : "Socket connection mode",
          "default" : "true",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "tls-verify" : {
          "description" : "Check TLS",
          "default" : "false",
          "type" : "boolean"
        },
        "username" : {
          "description" : "User name to authenticate with",
          "type" : "string"
        }
      }
    },
    "dozer" : {
      "type" : "object",
      "required" : [ "name", "targetModel" ],
      "properties" : {
        "name" : {
          "description" : "A human readable name of the mapping.",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "mapping-configuration" : {
          "description" : "The name of a DozerBeanMapperConfiguration bean in the Camel registry which should be used for configuring the Dozer mapping. This is an alternative to the mappingFile option that can be used for fine-grained control over how Dozer is configured. Remember to use a # prefix in the value to indicate that the bean is in the Camel registry (e.g. #myDozerConfig).",
          "type" : "string"
        },
        "mapping-file" : {
          "description" : "The location of a Dozer configuration file. The file is loaded from the classpath by default, but you can use file:, classpath:, or http: to load the configuration from a specific location.",
          "default" : "dozerBeanMapping.xml",
          "type" : "string"
        },
        "marshal-id" : {
          "description" : "The id of a dataFormat defined within the Camel Context to use for marshalling the mapping output to a non-Java type.",
          "type" : "string"
        },
        "source-model" : {
          "description" : "Fully-qualified class name for the source type used in the mapping. If specified, the input to the mapping is converted to the specified type before being mapped with Dozer.",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "target-model" : {
          "description" : "Fully-qualified class name for the target type used in the mapping.",
          "type" : "string"
        },
        "unmarshal-id" : {
          "description" : "The id of a dataFormat defined within the Camel Context to use for unmarshalling the mapping input from a non-Java type.",
          "type" : "string"
        }
      }
    },
    "drill" : {
      "type" : "object",
      "required" : [ "host" ],
      "properties" : {
        "host" : {
          "description" : "Host name or IP address",
          "type" : "string"
        },
        "cluster-id" : {
          "description" : "Cluster ID https://drill.apache.org/docs/using-the-jdbc-driver/#determining-the-cluster-id",
          "type" : "string"
        },
        "directory" : {
          "description" : "Drill directory",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "mode" : {
          "description" : "Connection mode: zk: Zookeeper drillbit: Drillbit direct connection https://drill.apache.org/docs/using-the-jdbc-driver/",
          "default" : "ZK",
          "enum" : [ "ZK", "DRILLBIT" ],
          "type" : "string"
        },
        "port" : {
          "description" : "Port number",
          "default" : "2181",
          "type" : "integer"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "dropbox" : {
      "type" : "object",
      "required" : [ "operation", "accessToken" ],
      "properties" : {
        "operation" : {
          "description" : "The specific action (typically is a CRUD action) to perform on Dropbox remote folder.",
          "enum" : [ "put", "del", "search", "get", "move" ],
          "type" : "string"
        },
        "access-token" : {
          "description" : "The access token to make API requests for a specific Dropbox user",
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "client" : {
          "description" : "To use an existing DbxClient instance as DropBox client.",
          "type" : "string"
        },
        "client-identifier" : {
          "description" : "Name of the app registered to make API requests",
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "local-path" : {
          "description" : "Optional folder or file to upload on Dropbox from the local filesystem. If this option has not been configured then the message body is used as the content to upload.",
          "type" : "string"
        },
        "new-remote-path" : {
          "description" : "Destination file or folder",
          "type" : "string"
        },
        "query" : {
          "description" : "A space-separated list of sub-strings to search for. A file matches only if it contains all the sub-strings. If this option is not set, all files will be matched.",
          "type" : "string"
        },
        "remote-path" : {
          "description" : "Original file or folder to move",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "upload-mode" : {
          "description" : "Which mode to upload. in case of add the new file will be renamed if a file with the same name already exists on dropbox. in case of force if a file with the same name already exists on dropbox, this will be overwritten.",
          "enum" : [ "add", "force" ],
          "type" : "string"
        }
      }
    },
    "ehcache" : {
      "type" : "object",
      "required" : [ "cacheName" ],
      "properties" : {
        "cache-name" : {
          "description" : "the cache name",
          "type" : "string"
        },
        "action" : {
          "description" : "To configure the default cache action. If an action is set in the message header, then the operation from the header takes precedence.",
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "cache-manager" : {
          "description" : "The cache manager",
          "type" : "string"
        },
        "cache-manager-configuration" : {
          "description" : "The cache manager configuration",
          "type" : "string"
        },
        "configuration" : {
          "description" : "The default cache configuration to be used to create caches.",
          "type" : "string"
        },
        "configuration-uri" : {
          "description" : "URI pointing to the Ehcache XML configuration file's location",
          "type" : "string"
        },
        "configurations" : {
          "description" : "A map of cache configuration to be used to create caches.",
          "type" : "string"
        },
        "create-cache-if-not-exist" : {
          "description" : "Configure if a cache need to be created if it does exist or can't be pre-configured.",
          "default" : "true",
          "type" : "boolean"
        },
        "event-firing" : {
          "description" : "Set the delivery mode (synchronous, asynchronous)",
          "default" : "ASYNCHRONOUS",
          "enum" : [ "ASYNCHRONOUS", "SYNCHRONOUS" ],
          "type" : "string"
        },
        "event-ordering" : {
          "description" : "Set the delivery mode (ordered, unordered)",
          "default" : "ORDERED",
          "enum" : [ "UNORDERED", "ORDERED" ],
          "type" : "string"
        },
        "event-types" : {
          "description" : "Set the type of events to listen for (EVICTED,EXPIRED,REMOVED,CREATED,UPDATED). You can specify multiple entries separated by comma.",
          "enum" : [ "EVICTED", "EXPIRED", "REMOVED", "CREATED", "UPDATED" ],
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "key" : {
          "description" : "To configure the default action key. If a key is set in the message header, then the key from the header takes precedence.",
          "type" : "string"
        },
        "key-type" : {
          "description" : "The cache key type, default java.lang.Object",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "value-type" : {
          "description" : "The cache value type, default java.lang.Object",
          "type" : "string"
        }
      }
    },
    "elasticsearch-rest" : {
      "type" : "object",
      "required" : [ "clusterName", "hostAddresses" ],
      "properties" : {
        "cluster-name" : {
          "description" : "Name of the cluster",
          "type" : "string"
        },
        "connection-timeout" : {
          "description" : "The time in ms to wait before connection will timeout.",
          "default" : "30000",
          "type" : "integer"
        },
        "disconnect" : {
          "description" : "Disconnect after it finish calling the producer",
          "default" : "false",
          "type" : "boolean"
        },
        "enable-ssl" : {
          "description" : "Enable SSL",
          "default" : "false",
          "type" : "boolean"
        },
        "enable-sniffer" : {
          "description" : "Enable automatically discover nodes from a running Elasticsearch cluster",
          "default" : "false",
          "type" : "boolean"
        },
        "from" : {
          "description" : "Starting index of the response.",
          "type" : "integer"
        },
        "host-addresses" : {
          "description" : "Comma separated list with ip:port formatted remote transport addresses to use.",
          "type" : "string"
        },
        "index-name" : {
          "description" : "The name of the index to act against",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "max-retry-timeout" : {
          "description" : "The time in ms before retry",
          "default" : "30000",
          "type" : "integer"
        },
        "operation" : {
          "description" : "What operation to perform",
          "enum" : [ "Index", "Update", "Bulk", "BulkIndex", "GetById", "MultiGet", "MultiSearch", "Delete", "DeleteIndex", "Search", "Exists", "Ping" ],
          "type" : "string"
        },
        "scroll-keep-alive-ms" : {
          "description" : "Time in ms during which elasticsearch will keep search context alive",
          "default" : "60000",
          "type" : "integer"
        },
        "size" : {
          "description" : "Size of the response.",
          "type" : "integer"
        },
        "sniff-after-failure-delay" : {
          "description" : "The delay of a sniff execution scheduled after a failure (in milliseconds)",
          "default" : "60000",
          "type" : "integer"
        },
        "sniffer-interval" : {
          "description" : "The interval between consecutive ordinary sniff executions in milliseconds. Will be honoured when sniffOnFailure is disabled or when there are no failures between consecutive sniff executions",
          "default" : "300000",
          "type" : "integer"
        },
        "socket-timeout" : {
          "description" : "The timeout in ms to wait before the socket will timeout.",
          "default" : "30000",
          "type" : "integer"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "use-scroll" : {
          "description" : "Enable scroll usage",
          "default" : "false",
          "type" : "boolean"
        },
        "wait-for-active-shards" : {
          "description" : "Index creation waits for the write consistency number of shards to be available",
          "default" : "1",
          "type" : "integer"
        }
      }
    },
    "elsql" : {
      "type" : "object",
      "required" : [ "elsqlName" ],
      "properties" : {
        "elsql-name" : {
          "description" : "The name of the elsql to use (is NAMED in the elsql file)",
          "type" : "string"
        },
        "resource-uri" : {
          "description" : "The resource file which contains the elsql SQL statements to use. You can specify multiple resources separated by comma. The resources are loaded on the classpath by default, you can prefix with file: to load from file system. Notice you can set this option on the component and then you do not have to configure this on the endpoint.",
          "type" : "string"
        },
        "allow-named-parameters" : {
          "description" : "Whether to allow using named parameters in the queries.",
          "default" : "true",
          "type" : "boolean"
        },
        "always-populate-statement" : {
          "description" : "If enabled then the populateStatement method from org.apache.camel.component.sql.SqlPrepareStatementStrategy is always invoked, also if there is no expected parameters to be prepared. When this is false then the populateStatement is only invoked if there is 1 or more expected parameters to be set; for example this avoids reading the message body/headers for SQL queries with no parameters.",
          "default" : "false",
          "type" : "boolean"
        },
        "backoff-error-threshold" : {
          "description" : "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-idle-threshold" : {
          "description" : "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-multiplier" : {
          "description" : "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
          "type" : "integer"
        },
        "batch" : {
          "description" : "Enables or disables batch mode",
          "default" : "false",
          "type" : "boolean"
        },
        "break-batch-on-consume-fail" : {
          "description" : "Sets whether to break batch if onConsume failed.",
          "default" : "false",
          "type" : "boolean"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "data-source" : {
          "description" : "Sets the DataSource to use to communicate with the database.",
          "type" : "string"
        },
        "data-source-ref" : {
          "description" : "Sets the reference to a DataSource to lookup from the registry, to use for communicating with the database.",
          "type" : "string"
        },
        "database-vendor" : {
          "description" : "To use a vendor specific com.opengamma.elsql.ElSqlConfig",
          "enum" : [ "Default", "Postgres", "HSql", "MySql", "Oracle", "SqlServer2008", "Veritca" ],
          "type" : "string"
        },
        "delay" : {
          "description" : "Milliseconds before the next poll.",
          "default" : "500",
          "type" : "integer"
        },
        "el-sql-config" : {
          "description" : "To use a specific configured ElSqlConfig. It may be better to use the databaseVendor option instead.",
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "expected-update-count" : {
          "description" : "Sets an expected update count to validate when using onConsume.",
          "default" : "-1",
          "type" : "integer"
        },
        "greedy" : {
          "description" : "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
          "default" : "false",
          "type" : "boolean"
        },
        "initial-delay" : {
          "description" : "Milliseconds before the first poll starts.",
          "default" : "1000",
          "type" : "integer"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "max-messages-per-poll" : {
          "description" : "Sets the maximum number of messages to poll",
          "type" : "integer"
        },
        "noop" : {
          "description" : "If set, will ignore the results of the SQL query and use the existing IN message as the OUT message for the continuation of processing",
          "default" : "false",
          "type" : "boolean"
        },
        "on-consume" : {
          "description" : "After processing each row then this query can be executed, if the Exchange was processed successfully, for example to mark the row as processed. The query can have parameter.",
          "type" : "string"
        },
        "on-consume-batch-complete" : {
          "description" : "After processing the entire batch, this query can be executed to bulk update rows etc. The query cannot have parameters.",
          "type" : "string"
        },
        "on-consume-failed" : {
          "description" : "After processing each row then this query can be executed, if the Exchange failed, for example to mark the row as failed. The query can have parameter.",
          "type" : "string"
        },
        "output-class" : {
          "description" : "Specify the full package and class name to use as conversion when outputType=SelectOne.",
          "type" : "string"
        },
        "output-header" : {
          "description" : "Store the query result in a header instead of the message body. By default, outputHeader == null and the query result is stored in the message body, any existing content in the message body is discarded. If outputHeader is set, the value is used as the name of the header to store the query result and the original message body is preserved.",
          "type" : "string"
        },
        "output-type" : {
          "description" : "Make the output of consumer or producer to SelectList as List of Map, or SelectOne as single Java object in the following way: a) If the query has only single column, then that JDBC Column object is returned. (such as SELECT COUNT( ) FROM PROJECT will return a Long object. b) If the query has more than one column, then it will return a Map of that result. c) If the outputClass is set, then it will convert the query result into an Java bean object by calling all the setters that match the column names. It will assume your class has a default constructor to create instance with. d) If the query resulted in more than one rows, it throws an non-unique result exception. StreamList streams the result of the query using an Iterator. This can be used with the Splitter EIP in streaming mode to process the ResultSet in streaming fashion.",
          "default" : "SelectList",
          "enum" : [ "SelectOne", "SelectList", "StreamList" ],
          "type" : "string"
        },
        "parameters-count" : {
          "description" : "If set greater than zero, then Camel will use this count value of parameters to replace instead of querying via JDBC metadata API. This is useful if the JDBC vendor could not return correct parameters count, then user may override instead.",
          "type" : "integer"
        },
        "placeholder" : {
          "description" : "Specifies a character that will be replaced to in SQL query. Notice, that it is simple String.replaceAll() operation and no SQL parsing is involved (quoted strings will also change).",
          "default" : "#",
          "type" : "string"
        },
        "poll-strategy" : {
          "description" : "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
          "type" : "string"
        },
        "prepare-statement-strategy" : {
          "description" : "Allows to plugin to use a custom org.apache.camel.component.sql.SqlPrepareStatementStrategy to control preparation of the query and prepared statement.",
          "type" : "string"
        },
        "processing-strategy" : {
          "description" : "Allows to plugin to use a custom org.apache.camel.component.sql.SqlProcessingStrategy to execute queries when the consumer has processed the rows/batch.",
          "type" : "string"
        },
        "repeat-count" : {
          "description" : "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
          "default" : "0",
          "type" : "integer"
        },
        "route-empty-result-set" : {
          "description" : "Sets whether empty resultset should be allowed to be sent to the next hop. Defaults to false. So the empty resultset will be filtered out.",
          "default" : "false",
          "type" : "boolean"
        },
        "run-logging-level" : {
          "description" : "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
          "default" : "TRACE",
          "enum" : [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ],
          "type" : "string"
        },
        "scheduled-executor-service" : {
          "description" : "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
          "type" : "string"
        },
        "scheduler" : {
          "description" : "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
          "default" : "none",
          "type" : "string"
        },
        "scheduler-properties" : {
          "description" : "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
          "type" : "string"
        },
        "send-empty-message-when-idle" : {
          "description" : "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
          "default" : "false",
          "type" : "boolean"
        },
        "separator" : {
          "description" : "The separator to use when parameter values is taken from message body (if the body is a String type), to be inserted at # placeholders. Notice if you use named parameters, then a Map type is used instead. The default value is comma",
          "default" : ",",
          "type" : "string"
        },
        "start-scheduler" : {
          "description" : "Whether the scheduler should be auto started.",
          "default" : "true",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "template-options" : {
          "description" : "Configures the Spring JdbcTemplate with the key/values from the Map",
          "type" : "string"
        },
        "time-unit" : {
          "description" : "Time unit for initialDelay and delay options.",
          "default" : "MILLISECONDS",
          "enum" : [ "NANOSECONDS", "MICROSECONDS", "MILLISECONDS", "SECONDS", "MINUTES", "HOURS", "DAYS" ],
          "type" : "string"
        },
        "transacted" : {
          "description" : "Enables or disables transaction. If enabled then if processing an exchange failed then the consumer breaks out processing any further exchanges to cause a rollback eager.",
          "default" : "false",
          "type" : "boolean"
        },
        "use-fixed-delay" : {
          "description" : "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
          "default" : "true",
          "type" : "boolean"
        },
        "use-iterator" : {
          "description" : "Sets how resultset should be delivered to route. Indicates delivery as either a list or individual object. defaults to true.",
          "default" : "true",
          "type" : "boolean"
        },
        "use-message-body-for-sql" : {
          "description" : "Whether to use the message body as the SQL and then headers for parameters. If this option is enabled then the SQL in the uri is not used. Note that query parameters in the message body are represented by a question mark instead of a # symbol.",
          "default" : "false",
          "type" : "boolean"
        },
        "use-placeholder" : {
          "description" : "Sets whether to use placeholder and replace all placeholder characters with sign in the SQL queries.",
          "default" : "true",
          "type" : "boolean"
        }
      }
    },
    "etcd-keys" : {
      "type" : "object",
      "properties" : {
        "path" : {
          "description" : "The path the endpoint refers to",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "password" : {
          "description" : "The password to use for basic authentication.",
          "type" : "string"
        },
        "recursive" : {
          "description" : "To apply an action recursively.",
          "default" : "false",
          "type" : "boolean"
        },
        "service-path" : {
          "description" : "The path to look for for service discovery",
          "default" : "/services/",
          "type" : "string"
        },
        "ssl-context-parameters" : {
          "description" : "To configure security using SSLContextParameters.",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "time-to-live" : {
          "description" : "To set the lifespan of a key in milliseconds.",
          "type" : "integer"
        },
        "timeout" : {
          "description" : "To set the maximum time an action could take to complete.",
          "type" : "string"
        },
        "uris" : {
          "description" : "To set the URIs the client connects.",
          "default" : "http://localhost:2379,http://localhost:4001",
          "type" : "string"
        },
        "user-name" : {
          "description" : "The user name to use for basic authentication.",
          "type" : "string"
        }
      }
    },
    "etcd-stats" : {
      "type" : "object",
      "properties" : {
        "path" : {
          "description" : "The path the endpoint refers to",
          "type" : "string"
        },
        "backoff-error-threshold" : {
          "description" : "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-idle-threshold" : {
          "description" : "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-multiplier" : {
          "description" : "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
          "type" : "integer"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "delay" : {
          "description" : "Milliseconds before the next poll.",
          "default" : "500",
          "type" : "integer"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "from-index" : {
          "description" : "The index to watch from",
          "default" : "0",
          "type" : "integer"
        },
        "greedy" : {
          "description" : "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
          "default" : "false",
          "type" : "boolean"
        },
        "initial-delay" : {
          "description" : "Milliseconds before the first poll starts.",
          "default" : "1000",
          "type" : "integer"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "password" : {
          "description" : "The password to use for basic authentication.",
          "type" : "string"
        },
        "poll-strategy" : {
          "description" : "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
          "type" : "string"
        },
        "recursive" : {
          "description" : "To apply an action recursively.",
          "default" : "false",
          "type" : "boolean"
        },
        "repeat-count" : {
          "description" : "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
          "default" : "0",
          "type" : "integer"
        },
        "run-logging-level" : {
          "description" : "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
          "default" : "TRACE",
          "enum" : [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ],
          "type" : "string"
        },
        "scheduled-executor-service" : {
          "description" : "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
          "type" : "string"
        },
        "scheduler" : {
          "description" : "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
          "default" : "none",
          "type" : "string"
        },
        "scheduler-properties" : {
          "description" : "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
          "type" : "string"
        },
        "send-empty-exchange-on-timeout" : {
          "description" : "To send an empty message in case of timeout watching for a key.",
          "default" : "false",
          "type" : "boolean"
        },
        "send-empty-message-when-idle" : {
          "description" : "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
          "default" : "false",
          "type" : "boolean"
        },
        "service-path" : {
          "description" : "The path to look for for service discovery",
          "default" : "/services/",
          "type" : "string"
        },
        "ssl-context-parameters" : {
          "description" : "To configure security using SSLContextParameters.",
          "type" : "string"
        },
        "start-scheduler" : {
          "description" : "Whether the scheduler should be auto started.",
          "default" : "true",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "time-to-live" : {
          "description" : "To set the lifespan of a key in milliseconds.",
          "type" : "integer"
        },
        "time-unit" : {
          "description" : "Time unit for initialDelay and delay options.",
          "default" : "MILLISECONDS",
          "enum" : [ "NANOSECONDS", "MICROSECONDS", "MILLISECONDS", "SECONDS", "MINUTES", "HOURS", "DAYS" ],
          "type" : "string"
        },
        "timeout" : {
          "description" : "To set the maximum time an action could take to complete.",
          "type" : "string"
        },
        "uris" : {
          "description" : "To set the URIs the client connects.",
          "default" : "http://localhost:2379,http://localhost:4001",
          "type" : "string"
        },
        "use-fixed-delay" : {
          "description" : "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
          "default" : "true",
          "type" : "boolean"
        },
        "user-name" : {
          "description" : "The user name to use for basic authentication.",
          "type" : "string"
        }
      }
    },
    "etcd-watch" : {
      "type" : "object",
      "properties" : {
        "path" : {
          "description" : "The path the endpoint refers to",
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "from-index" : {
          "description" : "The index to watch from",
          "default" : "0",
          "type" : "integer"
        },
        "password" : {
          "description" : "The password to use for basic authentication.",
          "type" : "string"
        },
        "recursive" : {
          "description" : "To apply an action recursively.",
          "default" : "false",
          "type" : "boolean"
        },
        "send-empty-exchange-on-timeout" : {
          "description" : "To send an empty message in case of timeout watching for a key.",
          "default" : "false",
          "type" : "boolean"
        },
        "service-path" : {
          "description" : "The path to look for for service discovery",
          "default" : "/services/",
          "type" : "string"
        },
        "ssl-context-parameters" : {
          "description" : "To configure security using SSLContextParameters.",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "timeout" : {
          "description" : "To set the maximum time an action could take to complete.",
          "type" : "string"
        },
        "uris" : {
          "description" : "To set the URIs the client connects.",
          "default" : "http://localhost:2379,http://localhost:4001",
          "type" : "string"
        },
        "user-name" : {
          "description" : "The user name to use for basic authentication.",
          "type" : "string"
        }
      }
    },
    "exec" : {
      "type" : "object",
      "required" : [ "executable" ],
      "properties" : {
        "executable" : {
          "description" : "Sets the executable to be executed. The executable must not be empty or null.",
          "type" : "string"
        },
        "args" : {
          "description" : "The arguments may be one or many whitespace-separated tokens.",
          "type" : "string"
        },
        "binding" : {
          "description" : "A reference to a org.apache.commons.exec.ExecBinding in the Registry.",
          "type" : "string"
        },
        "command-executor" : {
          "description" : "A reference to a org.apache.commons.exec.ExecCommandExecutor in the Registry that customizes the command execution. The default command executor utilizes the commons-exec library, which adds a shutdown hook for every executed command.",
          "type" : "string"
        },
        "command-log-level" : {
          "description" : "Logging level to be used for commands during execution. The default value is DEBUG. Possible values are TRACE, DEBUG, INFO, WARN, ERROR or OFF. (Values of ExecCommandLogLevelType enum)",
          "default" : "DEBUG",
          "enum" : [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ],
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "out-file" : {
          "description" : "The name of a file, created by the executable, that should be considered as its output. If no outFile is set, the standard output (stdout) of the executable will be used instead.",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "timeout" : {
          "description" : "The timeout, in milliseconds, after which the executable should be terminated. If execution has not completed within the timeout, the component will send a termination request.",
          "type" : "string"
        },
        "use-stderr-on-empty-stdout" : {
          "description" : "A boolean indicating that when stdout is empty, this component will populate the Camel Message Body with stderr. This behavior is disabled (false) by default.",
          "default" : "false",
          "type" : "boolean"
        },
        "working-dir" : {
          "description" : "The directory in which the command should be executed. If null, the working directory of the current process will be used.",
          "type" : "string"
        }
      }
    },
    "facebook" : {
      "type" : "object",
      "required" : [ "methodName" ],
      "properties" : {
        "method-name" : {
          "description" : "What operation to perform",
          "type" : "string"
        },
        "achievement-url" : {
          "description" : "The unique URL of the achievement",
          "type" : "string"
        },
        "album-id" : {
          "description" : "The album ID",
          "type" : "string"
        },
        "album-update" : {
          "description" : "The facebook Album to be created or updated",
          "type" : "string"
        },
        "app-id" : {
          "description" : "The ID of the Facebook Application",
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "center" : {
          "description" : "Location latitude and longitude",
          "type" : "string"
        },
        "checkin-id" : {
          "description" : "The checkin ID",
          "type" : "string"
        },
        "checkin-update" : {
          "description" : "The checkin to be created. Deprecated, instead create a Post with an attached location",
          "type" : "string"
        },
        "client-url" : {
          "description" : "Facebook4J API client URL",
          "type" : "string"
        },
        "client-version" : {
          "description" : "Facebook4J client API version",
          "type" : "string"
        },
        "comment-id" : {
          "description" : "The comment ID",
          "type" : "string"
        },
        "comment-update" : {
          "description" : "The facebook Comment to be created or updated",
          "type" : "string"
        },
        "debug-enabled" : {
          "description" : "Enables deubg output. Effective only with the embedded logger",
          "default" : "false",
          "type" : "boolean"
        },
        "description" : {
          "description" : "The description text",
          "type" : "string"
        },
        "distance" : {
          "description" : "Distance in meters",
          "type" : "integer"
        },
        "domain-id" : {
          "description" : "The domain ID",
          "type" : "string"
        },
        "domain-name" : {
          "description" : "The domain name",
          "type" : "string"
        },
        "domain-names" : {
          "description" : "The domain names",
          "type" : "string"
        },
        "event-id" : {
          "description" : "The event ID",
          "type" : "string"
        },
        "event-update" : {
          "description" : "The event to be created or updated",
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "friend-id" : {
          "description" : "The friend ID",
          "type" : "string"
        },
        "friend-user-id" : {
          "description" : "The friend user ID",
          "type" : "string"
        },
        "friendlist-id" : {
          "description" : "The friend list ID",
          "type" : "string"
        },
        "friendlist-name" : {
          "description" : "The friend list Name",
          "type" : "string"
        },
        "group-id" : {
          "description" : "The group ID",
          "type" : "string"
        },
        "gzip-enabled" : {
          "description" : "Use Facebook GZIP encoding",
          "default" : "true",
          "type" : "boolean"
        },
        "http-connection-timeout" : {
          "description" : "Http connection timeout in milliseconds",
          "default" : "20000",
          "type" : "integer"
        },
        "http-default-max-per-route" : {
          "description" : "HTTP maximum connections per route",
          "default" : "2",
          "type" : "integer"
        },
        "http-max-total-connections" : {
          "description" : "HTTP maximum total connections",
          "default" : "20",
          "type" : "integer"
        },
        "http-proxy-host" : {
          "description" : "HTTP proxy server host name",
          "type" : "string"
        },
        "http-proxy-password" : {
          "description" : "HTTP proxy server password",
          "type" : "string"
        },
        "http-proxy-port" : {
          "description" : "HTTP proxy server port",
          "type" : "integer"
        },
        "http-proxy-user" : {
          "description" : "HTTP proxy server user name",
          "type" : "string"
        },
        "http-read-timeout" : {
          "description" : "Http read timeout in milliseconds",
          "default" : "120000",
          "type" : "integer"
        },
        "http-retry-count" : {
          "description" : "Number of HTTP retries",
          "default" : "0",
          "type" : "integer"
        },
        "http-retry-interval-seconds" : {
          "description" : "HTTP retry interval in seconds",
          "default" : "5",
          "type" : "integer"
        },
        "http-streaming-read-timeout" : {
          "description" : "HTTP streaming read timeout in milliseconds",
          "default" : "40000",
          "type" : "integer"
        },
        "ids" : {
          "description" : "The ids of users",
          "type" : "string"
        },
        "in-body" : {
          "description" : "Sets the name of a parameter to be passed in the exchange In Body",
          "type" : "string"
        },
        "include-read" : {
          "description" : "Enables notifications that the user has already read in addition to unread ones",
          "type" : "boolean"
        },
        "is-hidden" : {
          "description" : "Whether hidden",
          "type" : "boolean"
        },
        "json-store-enabled" : {
          "description" : "If set to true, raw JSON forms will be stored in DataObjectFactory",
          "default" : "false",
          "type" : "boolean"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "link" : {
          "description" : "Link URL",
          "type" : "string"
        },
        "link-id" : {
          "description" : "Link ID",
          "type" : "string"
        },
        "locale" : {
          "description" : "Desired FQL locale",
          "type" : "string"
        },
        "mbean-enabled" : {
          "description" : "If set to true, Facebook4J mbean will be registerd",
          "default" : "false",
          "type" : "boolean"
        },
        "message" : {
          "description" : "The message text",
          "type" : "string"
        },
        "message-id" : {
          "description" : "The message ID",
          "type" : "string"
        },
        "metric" : {
          "description" : "The metric name",
          "type" : "string"
        },
        "milestone-id" : {
          "description" : "The milestone id",
          "type" : "string"
        },
        "name" : {
          "description" : "Test user name, must be of the form 'first last'",
          "type" : "string"
        },
        "note-id" : {
          "description" : "The note ID",
          "type" : "string"
        },
        "notification-id" : {
          "description" : "The notification ID",
          "type" : "string"
        },
        "o-auth-access-token" : {
          "description" : "The user access token",
          "type" : "string"
        },
        "o-auth-access-token-url" : {
          "description" : "OAuth access token URL",
          "default" : "https://graph.facebook.com/oauth/access_token",
          "type" : "string"
        },
        "o-auth-app-id" : {
          "description" : "The application Id",
          "type" : "string"
        },
        "o-auth-app-secret" : {
          "description" : "The application Secret",
          "type" : "string"
        },
        "o-auth-authorization-url" : {
          "description" : "OAuth authorization URL",
          "default" : "https://www.facebook.com/dialog/oauth",
          "type" : "string"
        },
        "o-auth-permissions" : {
          "description" : "Default OAuth permissions. Comma separated permission names. See https://developers.facebook.com/docs/reference/login/#permissions for the detail",
          "type" : "string"
        },
        "object-id" : {
          "description" : "The insight object ID",
          "type" : "string"
        },
        "offer-id" : {
          "description" : "The offer id",
          "type" : "string"
        },
        "option-description" : {
          "description" : "The question's answer option description",
          "type" : "string"
        },
        "page-id" : {
          "description" : "The page id",
          "type" : "string"
        },
        "permission-name" : {
          "description" : "The permission name",
          "type" : "string"
        },
        "permissions" : {
          "description" : "Test user permissions in the format perm1,perm2,...",
          "type" : "string"
        },
        "photo-id" : {
          "description" : "The photo ID",
          "type" : "string"
        },
        "picture-id" : {
          "description" : "The picture id",
          "type" : "integer"
        },
        "picture-id2" : {
          "description" : "The picture2 id",
          "type" : "integer"
        },
        "picture-size" : {
          "description" : "The picture size",
          "enum" : [ "square", "small", "normal", "large", "thumbnail", "album" ],
          "type" : "string"
        },
        "place-id" : {
          "description" : "The place ID",
          "type" : "string"
        },
        "post-id" : {
          "description" : "The post ID",
          "type" : "string"
        },
        "post-update" : {
          "description" : "The post to create or update",
          "type" : "string"
        },
        "pretty-debug-enabled" : {
          "description" : "Prettify JSON debug output if set to true",
          "default" : "false",
          "type" : "boolean"
        },
        "queries" : {
          "description" : "FQL queries",
          "type" : "string"
        },
        "query" : {
          "description" : "FQL query or search terms for search endpoints",
          "type" : "string"
        },
        "question-id" : {
          "description" : "The question id",
          "type" : "string"
        },
        "reading" : {
          "description" : "Optional reading parameters. See Reading Options(#reading)",
          "type" : "string"
        },
        "reading-options" : {
          "description" : "To configure Reading using key/value pairs from the Map.",
          "type" : "string"
        },
        "rest-base-url" : {
          "description" : "API base URL",
          "default" : "https://graph.facebook.com/",
          "type" : "string"
        },
        "score-value" : {
          "description" : "The numeric score with value",
          "type" : "integer"
        },
        "size" : {
          "description" : "The picture size, one of large, normal, small or square",
          "enum" : [ "square", "small", "normal", "large", "thumbnail", "album" ],
          "type" : "string"
        },
        "source" : {
          "description" : "The media content from either a java.io.File or java.io.Inputstream",
          "type" : "string"
        },
        "subject" : {
          "description" : "The note of the subject",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "tab-id" : {
          "description" : "The tab id",
          "type" : "string"
        },
        "tag-update" : {
          "description" : "Photo tag information",
          "type" : "string"
        },
        "test-user1" : {
          "description" : "Test user 1",
          "type" : "string"
        },
        "test-user2" : {
          "description" : "Test user 2",
          "type" : "string"
        },
        "test-user-id" : {
          "description" : "The ID of the test user",
          "type" : "string"
        },
        "title" : {
          "description" : "The title text",
          "type" : "string"
        },
        "to-user-id" : {
          "description" : "The ID of the user to tag",
          "type" : "string"
        },
        "to-user-ids" : {
          "description" : "The IDs of the users to tag",
          "type" : "string"
        },
        "use-ssl" : {
          "description" : "Use SSL",
          "default" : "true",
          "type" : "boolean"
        },
        "user-id" : {
          "description" : "The Facebook user ID",
          "type" : "string"
        },
        "user-id1" : {
          "description" : "The ID of a user 1",
          "type" : "string"
        },
        "user-id2" : {
          "description" : "The ID of a user 2",
          "type" : "string"
        },
        "user-ids" : {
          "description" : "The IDs of users to invite to event",
          "type" : "string"
        },
        "user-locale" : {
          "description" : "The test user locale",
          "type" : "string"
        },
        "video-base-url" : {
          "description" : "Video API base URL",
          "default" : "https://graph-video.facebook.com/",
          "type" : "string"
        },
        "video-id" : {
          "description" : "The video ID",
          "type" : "string"
        }
      }
    },
    "fhir" : {
      "type" : "object",
      "required" : [ "apiName", "methodName" ],
      "properties" : {
        "api-name" : {
          "description" : "What kind of operation to perform",
          "enum" : [ "CAPABILITIES", "CREATE", "DELETE", "HISTORY", "LOAD_PAGE", "META", "OPERATION", "PATCH", "READ", "SEARCH", "TRANSACTION", "UPDATE", "VALIDATE" ],
          "type" : "string"
        },
        "method-name" : {
          "description" : "What sub operation to use for the selected operation",
          "type" : "string"
        },
        "access-token" : {
          "description" : "OAuth access token",
          "type" : "string"
        },
        "backoff-error-threshold" : {
          "description" : "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-idle-threshold" : {
          "description" : "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-multiplier" : {
          "description" : "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
          "type" : "integer"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "client" : {
          "description" : "To use the custom client",
          "type" : "string"
        },
        "client-factory" : {
          "description" : "To use the custom client factory",
          "type" : "string"
        },
        "compress" : {
          "description" : "Compresses outgoing (POST/PUT) contents to the GZIP format",
          "default" : "false",
          "type" : "boolean"
        },
        "connection-timeout" : {
          "description" : "How long to try and establish the initial TCP connection (in ms)",
          "default" : "10000",
          "type" : "integer"
        },
        "defer-model-scanning" : {
          "description" : "When this option is set, model classes will not be scanned for children until the child list for the given type is actually accessed.",
          "default" : "false",
          "type" : "boolean"
        },
        "delay" : {
          "description" : "Milliseconds before the next poll.",
          "default" : "500",
          "type" : "integer"
        },
        "encoding" : {
          "description" : "Encoding to use for all request",
          "enum" : [ "JSON", "XML" ],
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "fhir-context" : {
          "description" : "FhirContext is an expensive object to create. To avoid creating multiple instances, it can be set directly.",
          "type" : "string"
        },
        "fhir-version" : {
          "description" : "The FHIR Version to use",
          "default" : "R4",
          "enum" : [ "DSTU2", "DSTU2_HL7ORG", "DSTU2_1", "DSTU3", "R4", "R5" ],
          "type" : "string"
        },
        "force-conformance-check" : {
          "description" : "Force conformance check",
          "default" : "false",
          "type" : "boolean"
        },
        "greedy" : {
          "description" : "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
          "default" : "false",
          "type" : "boolean"
        },
        "in-body" : {
          "description" : "Sets the name of a parameter to be passed in the exchange In Body",
          "type" : "string"
        },
        "initial-delay" : {
          "description" : "Milliseconds before the first poll starts.",
          "default" : "1000",
          "type" : "integer"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "log" : {
          "description" : "Will log every requests and responses",
          "default" : "false",
          "type" : "boolean"
        },
        "password" : {
          "description" : "Username to use for basic authentication",
          "type" : "string"
        },
        "poll-strategy" : {
          "description" : "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
          "type" : "string"
        },
        "pretty-print" : {
          "description" : "Pretty print all request",
          "default" : "false",
          "type" : "boolean"
        },
        "proxy-host" : {
          "description" : "The proxy host",
          "type" : "string"
        },
        "proxy-password" : {
          "description" : "The proxy password",
          "type" : "string"
        },
        "proxy-port" : {
          "description" : "The proxy port",
          "type" : "integer"
        },
        "proxy-user" : {
          "description" : "The proxy username",
          "type" : "string"
        },
        "repeat-count" : {
          "description" : "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
          "default" : "0",
          "type" : "integer"
        },
        "run-logging-level" : {
          "description" : "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
          "default" : "TRACE",
          "enum" : [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ],
          "type" : "string"
        },
        "scheduled-executor-service" : {
          "description" : "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
          "type" : "string"
        },
        "scheduler" : {
          "description" : "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
          "default" : "none",
          "type" : "string"
        },
        "scheduler-properties" : {
          "description" : "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
          "type" : "string"
        },
        "send-empty-message-when-idle" : {
          "description" : "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
          "default" : "false",
          "type" : "boolean"
        },
        "server-url" : {
          "description" : "The FHIR server base URL",
          "type" : "string"
        },
        "session-cookie" : {
          "description" : "HTTP session cookie to add to every request",
          "type" : "string"
        },
        "socket-timeout" : {
          "description" : "How long to block for individual read/write operations (in ms)",
          "default" : "10000",
          "type" : "integer"
        },
        "start-scheduler" : {
          "description" : "Whether the scheduler should be auto started.",
          "default" : "true",
          "type" : "boolean"
        },
        "summary" : {
          "description" : "Request that the server modify the response using the _summary param",
          "enum" : [ "COUNT", "TEXT", "DATA", "TRUE", "FALSE" ],
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "time-unit" : {
          "description" : "Time unit for initialDelay and delay options.",
          "default" : "MILLISECONDS",
          "enum" : [ "NANOSECONDS", "MICROSECONDS", "MILLISECONDS", "SECONDS", "MINUTES", "HOURS", "DAYS" ],
          "type" : "string"
        },
        "use-fixed-delay" : {
          "description" : "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
          "default" : "true",
          "type" : "boolean"
        },
        "username" : {
          "description" : "Username to use for basic authentication",
          "type" : "string"
        },
        "validation-mode" : {
          "description" : "When should Camel validate the FHIR Server's conformance statement",
          "default" : "ONCE",
          "enum" : [ "NEVER", "ONCE" ],
          "type" : "string"
        }
      }
    },
    "file" : {
      "type" : "object",
      "required" : [ "directoryName" ],
      "properties" : {
        "directory-name" : {
          "description" : "The starting directory",
          "type" : "string"
        },
        "allow-null-body" : {
          "description" : "Used to specify if a null body is allowed during file writing. If set to true then an empty file will be created, when set to false, and attempting to send a null body to the file component, a GenericFileWriteException of 'Cannot write null body to file.' will be thrown. If the fileExist option is set to 'Override', then the file will be truncated, and if set to append the file will remain unchanged.",
          "default" : "false",
          "type" : "boolean"
        },
        "ant-exclude" : {
          "description" : "Ant style filter exclusion. If both antInclude and antExclude are used, antExclude takes precedence over antInclude. Multiple exclusions may be specified in comma-delimited format.",
          "type" : "string"
        },
        "ant-filter-case-sensitive" : {
          "description" : "Sets case sensitive flag on ant filter.",
          "default" : "true",
          "type" : "boolean"
        },
        "ant-include" : {
          "description" : "Ant style filter inclusion. Multiple inclusions may be specified in comma-delimited format.",
          "type" : "string"
        },
        "append-chars" : {
          "description" : "Used to append characters (text) after writing files. This can for example be used to add new lines or other separators when writing and appending to existing files. To specify new-line (slash-n or slash-r) or tab (slash-t) characters then escape with an extra slash, eg slash-slash-n.",
          "type" : "string"
        },
        "auto-create" : {
          "description" : "Automatically create missing directories in the file's pathname. For the file consumer, that means creating the starting directory. For the file producer, it means the directory the files should be written to.",
          "default" : "true",
          "type" : "boolean"
        },
        "backoff-error-threshold" : {
          "description" : "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-idle-threshold" : {
          "description" : "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-multiplier" : {
          "description" : "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
          "type" : "integer"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "buffer-size" : {
          "description" : "Buffer size in bytes used for writing files (or in case of FTP for downloading and uploading files).",
          "default" : "131072",
          "type" : "integer"
        },
        "charset" : {
          "description" : "This option is used to specify the encoding of the file. You can use this on the consumer, to specify the encodings of the files, which allow Camel to know the charset it should load the file content in case the file content is being accessed. Likewise when writing a file, you can use this option to specify which charset to write the file as well. Do mind that when writing the file Camel may have to read the message content into memory to be able to convert the data into the configured charset, so do not use this if you have big messages.",
          "type" : "string"
        },
        "chmod" : {
          "description" : "Specify the file permissions which is sent by the producer, the chmod value must be between 000 and 777; If there is a leading digit like in 0755 we will ignore it.",
          "type" : "string"
        },
        "chmod-directory" : {
          "description" : "Specify the directory permissions used when the producer creates missing directories, the chmod value must be between 000 and 777; If there is a leading digit like in 0755 we will ignore it.",
          "type" : "string"
        },
        "copy-and-delete-on-rename-fail" : {
          "description" : "Whether to fallback and do a copy and delete file, in case the file could not be renamed directly. This option is not available for the FTP component.",
          "default" : "true",
          "type" : "boolean"
        },
        "delay" : {
          "description" : "Milliseconds before the next poll.",
          "default" : "500",
          "type" : "integer"
        },
        "delete" : {
          "description" : "If true, the file will be deleted after it is processed successfully.",
          "default" : "false",
          "type" : "boolean"
        },
        "directory-must-exist" : {
          "description" : "Similar to the startingDirectoryMustExist option but this applies during polling (after starting the consumer).",
          "default" : "false",
          "type" : "boolean"
        },
        "done-file-name" : {
          "description" : "Producer: If provided, then Camel will write a 2nd done file when the original file has been written. The done file will be empty. This option configures what file name to use. Either you can specify a fixed name. Or you can use dynamic placeholders. The done file will always be written in the same folder as the original file. Consumer: If provided, Camel will only consume files if a done file exists. This option configures what file name to use. Either you can specify a fixed name. Or you can use dynamic placeholders.The done file is always expected in the same folder as the original file. Only ${file.name} and ${file.name.next} is supported as dynamic placeholders.",
          "type" : "string"
        },
        "eager-delete-target-file" : {
          "description" : "Whether or not to eagerly delete any existing target file. This option only applies when you use fileExists=Override and the tempFileName option as well. You can use this to disable (set it to false) deleting the target file before the temp file is written. For example you may write big files and want the target file to exists during the temp file is being written. This ensure the target file is only deleted until the very last moment, just before the temp file is being renamed to the target filename. This option is also used to control whether to delete any existing files when fileExist=Move is enabled, and an existing file exists. If this option copyAndDeleteOnRenameFails false, then an exception will be thrown if an existing file existed, if its true, then the existing file is deleted before the move operation.",
          "default" : "true",
          "type" : "boolean"
        },
        "eager-max-messages-per-poll" : {
          "description" : "Allows for controlling whether the limit from maxMessagesPerPoll is eager or not. If eager then the limit is during the scanning of files. Where as false would scan all files, and then perform sorting. Setting this option to false allows for sorting all files first, and then limit the poll. Mind that this requires a higher memory usage as all file details are in memory to perform the sorting.",
          "default" : "true",
          "type" : "boolean"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "exclude" : {
          "description" : "Is used to exclude files, if filename matches the regex pattern (matching is case in-senstive). Notice if you use symbols such as plus sign and others you would need to configure this using the RAW() syntax if configuring this as an endpoint uri. See more details at configuring endpoint uris",
          "type" : "string"
        },
        "exclusive-read-lock-strategy" : {
          "description" : "Pluggable read-lock as a org.apache.camel.component.file.GenericFileExclusiveReadLockStrategy implementation.",
          "type" : "string"
        },
        "extended-attributes" : {
          "description" : "To define which file attributes of interest. Like posix:permissions,posix:owner,basic:lastAccessTime, it supports basic wildcard like posix:, basic:lastAccessTime",
          "type" : "string"
        },
        "file-exist" : {
          "description" : "What to do if a file already exists with the same name. Override, which is the default, replaces the existing file. - Append - adds content to the existing file. - Fail - throws a GenericFileOperationException, indicating that there is already an existing file. - Ignore - silently ignores the problem and does not override the existing file, but assumes everything is okay. - Move - option requires to use the moveExisting option to be configured as well. The option eagerDeleteTargetFile can be used to control what to do if an moving the file, and there exists already an existing file, otherwise causing the move operation to fail. The Move option will move any existing files, before writing the target file. - TryRename is only applicable if tempFileName option is in use. This allows to try renaming the file from the temporary name to the actual name, without doing any exists check. This check may be faster on some file systems and especially FTP servers.",
          "default" : "Override",
          "enum" : [ "Override", "Append", "Fail", "Ignore", "Move", "TryRename" ],
          "type" : "string"
        },
        "file-name" : {
          "description" : "Use Expression such as File Language to dynamically set the filename. For consumers, it's used as a filename filter. For producers, it's used to evaluate the filename to write. If an expression is set, it take precedence over the CamelFileName header. (Note: The header itself can also be an Expression). The expression options support both String and Expression types. If the expression is a String type, it is always evaluated using the File Language. If the expression is an Expression type, the specified Expression type is used - this allows you, for instance, to use OGNL expressions. For the consumer, you can use it to filter filenames, so you can for instance consume today's file using the File Language syntax: mydata-${date:now:yyyyMMdd}.txt. The producers support the CamelOverruleFileName header which takes precedence over any existing CamelFileName header; the CamelOverruleFileName is a header that is used only once, and makes it easier as this avoids to temporary store CamelFileName and have to restore it afterwards.",
          "type" : "string"
        },
        "filter" : {
          "description" : "Pluggable filter as a org.apache.camel.component.file.GenericFileFilter class. Will skip files if filter returns false in its accept() method.",
          "type" : "string"
        },
        "filter-directory" : {
          "description" : "Filters the directory based on Simple language. For example to filter on current date, you can use a simple date pattern such as ${date:now:yyyMMdd}",
          "type" : "string"
        },
        "filter-file" : {
          "description" : "Filters the file based on Simple language. For example to filter on file size, you can use ${file:size} 5000",
          "type" : "string"
        },
        "flatten" : {
          "description" : "Flatten is used to flatten the file name path to strip any leading paths, so it's just the file name. This allows you to consume recursively into sub-directories, but when you eg write the files to another directory they will be written in a single directory. Setting this to true on the producer enforces that any file name in CamelFileName header will be stripped for any leading paths.",
          "default" : "false",
          "type" : "boolean"
        },
        "force-writes" : {
          "description" : "Whether to force syncing writes to the file system. You can turn this off if you do not want this level of guarantee, for example if writing to logs / audit logs etc; this would yield better performance.",
          "default" : "true",
          "type" : "boolean"
        },
        "greedy" : {
          "description" : "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
          "default" : "false",
          "type" : "boolean"
        },
        "idempotent" : {
          "description" : "Option to use the Idempotent Consumer EIP pattern to let Camel skip already processed files. Will by default use a memory based LRUCache that holds 1000 entries. If noop=true then idempotent will be enabled as well to avoid consuming the same files over and over again.",
          "default" : "false",
          "type" : "boolean"
        },
        "idempotent-key" : {
          "description" : "To use a custom idempotent key. By default the absolute path of the file is used. You can use the File Language, for example to use the file name and file size, you can do: idempotentKey=${file:name}-${file:size}",
          "type" : "string"
        },
        "idempotent-repository" : {
          "description" : "A pluggable repository org.apache.camel.spi.IdempotentRepository which by default use MemoryMessageIdRepository if none is specified and idempotent is true.",
          "type" : "string"
        },
        "in-progress-repository" : {
          "description" : "A pluggable in-progress repository org.apache.camel.spi.IdempotentRepository. The in-progress repository is used to account the current in progress files being consumed. By default a memory based repository is used.",
          "type" : "string"
        },
        "include" : {
          "description" : "Is used to include files, if filename matches the regex pattern (matching is case in-sensitive). Notice if you use symbols such as plus sign and others you would need to configure this using the RAW() syntax if configuring this as an endpoint uri. See more details at configuring endpoint uris",
          "type" : "string"
        },
        "initial-delay" : {
          "description" : "Milliseconds before the first poll starts.",
          "default" : "1000",
          "type" : "integer"
        },
        "jail-starting-directory" : {
          "description" : "Used for jailing (restricting) writing files to the starting directory (and sub) only. This is enabled by default to not allow Camel to write files to outside directories (to be more secured out of the box). You can turn this off to allow writing files to directories outside the starting directory, such as parent or root folders.",
          "default" : "true",
          "type" : "boolean"
        },
        "keep-last-modified" : {
          "description" : "Will keep the last modified timestamp from the source file (if any). Will use the Exchange.FILE_LAST_MODIFIED header to located the timestamp. This header can contain either a java.util.Date or long with the timestamp. If the timestamp exists and the option is enabled it will set this timestamp on the written file. Note: This option only applies to the file producer. You cannot use this option with any of the ftp producers.",
          "default" : "false",
          "type" : "boolean"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "local-work-directory" : {
          "description" : "When consuming, a local work directory can be used to store the remote file content directly in local files, to avoid loading the content into memory. This is beneficial, if you consume a very big remote file and thus can conserve memory.",
          "type" : "string"
        },
        "max-depth" : {
          "description" : "The maximum depth to traverse when recursively processing a directory.",
          "default" : "2147483647",
          "type" : "integer"
        },
        "max-messages-per-poll" : {
          "description" : "To define a maximum messages to gather per poll. By default no maximum is set. Can be used to set a limit of e.g. 1000 to avoid when starting up the server that there are thousands of files. Set a value of 0 or negative to disabled it. Notice: If this option is in use then the File and FTP components will limit before any sorting. For example if you have 100000 files and use maxMessagesPerPoll=500, then only the first 500 files will be picked up, and then sorted. You can use the eagerMaxMessagesPerPoll option and set this to false to allow to scan all files first and then sort afterwards.",
          "type" : "integer"
        },
        "min-depth" : {
          "description" : "The minimum depth to start processing when recursively processing a directory. Using minDepth=1 means the base directory. Using minDepth=2 means the first sub directory.",
          "type" : "integer"
        },
        "move" : {
          "description" : "Expression (such as Simple Language) used to dynamically set the filename when moving it after processing. To move files into a .done subdirectory just enter .done.",
          "type" : "string"
        },
        "move-existing" : {
          "description" : "Expression (such as File Language) used to compute file name to use when fileExist=Move is configured. To move files into a backup subdirectory just enter backup. This option only supports the following File Language tokens: file:name, file:name.ext, file:name.noext, file:onlyname, file:onlyname.noext, file:ext, and file:parent. Notice the file:parent is not supported by the FTP component, as the FTP component can only move any existing files to a relative directory based on current dir as base.",
          "type" : "string"
        },
        "move-existing-file-strategy" : {
          "description" : "Strategy (Custom Strategy) used to move file with special naming token to use when fileExist=Move is configured. By default, there is an implementation used if no custom strategy is provided",
          "type" : "string"
        },
        "move-failed" : {
          "description" : "Sets the move failure expression based on Simple language. For example, to move files into a .error subdirectory use: .error. Note: When moving the files to the fail location Camel will handle the error and will not pick up the file again.",
          "type" : "string"
        },
        "noop" : {
          "description" : "If true, the file is not moved or deleted in any way. This option is good for readonly data, or for ETL type requirements. If noop=true, Camel will set idempotent=true as well, to avoid consuming the same files over and over again.",
          "default" : "false",
          "type" : "boolean"
        },
        "on-completion-exception-handler" : {
          "description" : "To use a custom org.apache.camel.spi.ExceptionHandler to handle any thrown exceptions that happens during the file on completion process where the consumer does either a commit or rollback. The default implementation will log any exception at WARN level and ignore.",
          "type" : "string"
        },
        "poll-strategy" : {
          "description" : "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
          "type" : "string"
        },
        "pre-move" : {
          "description" : "Expression (such as File Language) used to dynamically set the filename when moving it before processing. For example to move in-progress files into the order directory set this value to order.",
          "type" : "string"
        },
        "pre-sort" : {
          "description" : "When pre-sort is enabled then the consumer will sort the file and directory names during polling, that was retrieved from the file system. You may want to do this in case you need to operate on the files in a sorted order. The pre-sort is executed before the consumer starts to filter, and accept files to process by Camel. This option is default=false meaning disabled.",
          "default" : "false",
          "type" : "boolean"
        },
        "probe-content-type" : {
          "description" : "Whether to enable probing of the content type. If enable then the consumer uses Files#probeContentType(java.nio.file.Path) to determine the content-type of the file, and store that as a header with key Exchange#FILE_CONTENT_TYPE on the Message.",
          "default" : "false",
          "type" : "boolean"
        },
        "process-strategy" : {
          "description" : "A pluggable org.apache.camel.component.file.GenericFileProcessStrategy allowing you to implement your own readLock option or similar. Can also be used when special conditions must be met before a file can be consumed, such as a special ready file exists. If this option is set then the readLock option does not apply.",
          "type" : "string"
        },
        "read-lock" : {
          "description" : "Used by consumer, to only poll the files if it has exclusive read-lock on the file (i.e. the file is not in-progress or being written). Camel will wait until the file lock is granted. This option provides the build in strategies: - none - No read lock is in use - markerFile - Camel creates a marker file (fileName.camelLock) and then holds a lock on it. This option is not available for the FTP component - changed - Changed is using file length/modification timestamp to detect whether the file is currently being copied or not. Will at least use 1 sec to determine this, so this option cannot consume files as fast as the others, but can be more reliable as the JDK IO API cannot always determine whether a file is currently being used by another process. The option readLockCheckInterval can be used to set the check frequency. - fileLock - is for using java.nio.channels.FileLock. This option is not avail for Windows OS and the FTP component. This approach should be avoided when accessing a remote file system via a mount/share unless that file system supports distributed file locks. - rename - rename is for using a try to rename the file as a test if we can get exclusive read-lock. - idempotent - (only for file component) idempotent is for using a idempotentRepository as the read-lock. This allows to use read locks that supports clustering if the idempotent repository implementation supports that. - idempotent-changed - (only for file component) idempotent-changed is for using a idempotentRepository and changed as the combined read-lock. This allows to use read locks that supports clustering if the idempotent repository implementation supports that. - idempotent-rename - (only for file component) idempotent-rename is for using a idempotentRepository and rename as the combined read-lock. This allows to use read locks that supports clustering if the idempotent repository implementation supports that.Notice: The various read locks is not all suited to work in clustered mode, where concurrent consumers on different nodes is competing for the same files on a shared file system. The markerFile using a close to atomic operation to create the empty marker file, but its not guaranteed to work in a cluster. The fileLock may work better but then the file system need to support distributed file locks, and so on. Using the idempotent read lock can support clustering if the idempotent repository supports clustering, such as Hazelcast Component or Infinispan.",
          "default" : "none",
          "enum" : [ "none", "markerFile", "fileLock", "rename", "changed", "idempotent", "idempotent-changed", "idempotent-rename" ],
          "type" : "string"
        },
        "read-lock-check-interval" : {
          "description" : "Interval in millis for the read-lock, if supported by the read lock. This interval is used for sleeping between attempts to acquire the read lock. For example when using the changed read lock, you can set a higher interval period to cater for slow writes. The default of 1 sec. may be too fast if the producer is very slow writing the file. Notice: For FTP the default readLockCheckInterval is 5000. The readLockTimeout value must be higher than readLockCheckInterval, but a rule of thumb is to have a timeout that is at least 2 or more times higher than the readLockCheckInterval. This is needed to ensure that amble time is allowed for the read lock process to try to grab the lock before the timeout was hit.",
          "default" : "1000",
          "type" : "integer"
        },
        "read-lock-delete-orphan-lock-files" : {
          "description" : "Whether or not read lock with marker files should upon startup delete any orphan read lock files, which may have been left on the file system, if Camel was not properly shutdown (such as a JVM crash). If turning this option to false then any orphaned lock file will cause Camel to not attempt to pickup that file, this could also be due another node is concurrently reading files from the same shared directory.",
          "default" : "true",
          "type" : "boolean"
        },
        "read-lock-idempotent-release-async" : {
          "description" : "Whether the delayed release task should be synchronous or asynchronous. See more details at the readLockIdempotentReleaseDelay option.",
          "default" : "false",
          "type" : "boolean"
        },
        "read-lock-idempotent-release-async-pool-size" : {
          "description" : "The number of threads in the scheduled thread pool when using asynchronous release tasks. Using a default of 1 core threads should be sufficient in almost all use-cases, only set this to a higher value if either updating the idempotent repository is slow, or there are a lot of files to process. This option is not in-use if you use a shared thread pool by configuring the readLockIdempotentReleaseExecutorService option. See more details at the readLockIdempotentReleaseDelay option.",
          "type" : "integer"
        },
        "read-lock-idempotent-release-delay" : {
          "description" : "Whether to delay the release task for a period of millis. This can be used to delay the release tasks to expand the window when a file is regarded as read-locked, in an active/active cluster scenario with a shared idempotent repository, to ensure other nodes cannot potentially scan and acquire the same file, due to race-conditions. By expanding the time-window of the release tasks helps prevents these situations. Note delaying is only needed if you have configured readLockRemoveOnCommit to true.",
          "type" : "integer"
        },
        "read-lock-idempotent-release-executor-service" : {
          "description" : "To use a custom and shared thread pool for asynchronous release tasks. See more details at the readLockIdempotentReleaseDelay option.",
          "type" : "string"
        },
        "read-lock-logging-level" : {
          "description" : "Logging level used when a read lock could not be acquired. By default a DEBUG is logged. You can change this level, for example to OFF to not have any logging. This option is only applicable for readLock of types: changed, fileLock, idempotent, idempotent-changed, idempotent-rename, rename.",
          "default" : "DEBUG",
          "enum" : [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ],
          "type" : "string"
        },
        "read-lock-marker-file" : {
          "description" : "Whether to use marker file with the changed, rename, or exclusive read lock types. By default a marker file is used as well to guard against other processes picking up the same files. This behavior can be turned off by setting this option to false. For example if you do not want to write marker files to the file systems by the Camel application.",
          "default" : "true",
          "type" : "boolean"
        },
        "read-lock-min-age" : {
          "description" : "This option is applied only for readLock=changed. It allows to specify a minimum age the file must be before attempting to acquire the read lock. For example use readLockMinAge=300s to require the file is at last 5 minutes old. This can speedup the changed read lock as it will only attempt to acquire files which are at least that given age.",
          "default" : "0",
          "type" : "integer"
        },
        "read-lock-min-length" : {
          "description" : "This option is applied only for readLock=changed. It allows you to configure a minimum file length. By default Camel expects the file to contain data, and thus the default value is 1. You can set this option to zero, to allow consuming zero-length files.",
          "default" : "1",
          "type" : "integer"
        },
        "read-lock-remove-on-commit" : {
          "description" : "This option is applied only for readLock=idempotent. It allows to specify whether to remove the file name entry from the idempotent repository when processing the file is succeeded and a commit happens. By default the file is not removed which ensures that any race-condition do not occur so another active node may attempt to grab the file. Instead the idempotent repository may support eviction strategies that you can configure to evict the file name entry after X minutes - this ensures no problems with race conditions. See more details at the readLockIdempotentReleaseDelay option.",
          "default" : "false",
          "type" : "boolean"
        },
        "read-lock-remove-on-rollback" : {
          "description" : "This option is applied only for readLock=idempotent. It allows to specify whether to remove the file name entry from the idempotent repository when processing the file failed and a rollback happens. If this option is false, then the file name entry is confirmed (as if the file did a commit).",
          "default" : "true",
          "type" : "boolean"
        },
        "read-lock-timeout" : {
          "description" : "Optional timeout in millis for the read-lock, if supported by the read-lock. If the read-lock could not be granted and the timeout triggered, then Camel will skip the file. At next poll Camel, will try the file again, and this time maybe the read-lock could be granted. Use a value of 0 or lower to indicate forever. Currently fileLock, changed and rename support the timeout. Notice: For FTP the default readLockTimeout value is 20000 instead of 10000. The readLockTimeout value must be higher than readLockCheckInterval, but a rule of thumb is to have a timeout that is at least 2 or more times higher than the readLockCheckInterval. This is needed to ensure that amble time is allowed for the read lock process to try to grab the lock before the timeout was hit.",
          "default" : "10000",
          "type" : "integer"
        },
        "recursive" : {
          "description" : "If a directory, will look for files in all the sub-directories as well.",
          "default" : "false",
          "type" : "boolean"
        },
        "rename-using-copy" : {
          "description" : "Perform rename operations using a copy and delete strategy. This is primarily used in environments where the regular rename operation is unreliable (e.g. across different file systems or networks). This option takes precedence over the copyAndDeleteOnRenameFail parameter that will automatically fall back to the copy and delete strategy, but only after additional delays.",
          "default" : "false",
          "type" : "boolean"
        },
        "repeat-count" : {
          "description" : "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
          "default" : "0",
          "type" : "integer"
        },
        "run-logging-level" : {
          "description" : "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
          "default" : "TRACE",
          "enum" : [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ],
          "type" : "string"
        },
        "scheduled-executor-service" : {
          "description" : "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
          "type" : "string"
        },
        "scheduler" : {
          "description" : "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
          "default" : "none",
          "type" : "string"
        },
        "scheduler-properties" : {
          "description" : "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
          "type" : "string"
        },
        "send-empty-message-when-idle" : {
          "description" : "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
          "default" : "false",
          "type" : "boolean"
        },
        "shuffle" : {
          "description" : "To shuffle the list of files (sort in random order)",
          "default" : "false",
          "type" : "boolean"
        },
        "sort-by" : {
          "description" : "Built-in sort by using the File Language. Supports nested sorts, so you can have a sort by file name and as a 2nd group sort by modified date.",
          "type" : "string"
        },
        "sorter" : {
          "description" : "Pluggable sorter as a java.util.Comparator class.",
          "type" : "string"
        },
        "start-scheduler" : {
          "description" : "Whether the scheduler should be auto started.",
          "default" : "true",
          "type" : "boolean"
        },
        "starting-directory-must-exist" : {
          "description" : "Whether the starting directory must exist. Mind that the autoCreate option is default enabled, which means the starting directory is normally auto created if it doesn't exist. You can disable autoCreate and enable this to ensure the starting directory must exist. Will thrown an exception if the directory doesn't exist.",
          "default" : "false",
          "type" : "boolean"
        },
        "starting-directory-must-have-access" : {
          "description" : "Whether the starting directory has access permissions. Mind that the startingDirectoryMustExist parameter must be set to true in order to verify that the directory exists. Will thrown an exception if the directory doesn't have read and write permissions.",
          "default" : "false",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "temp-file-name" : {
          "description" : "The same as tempPrefix option but offering a more fine grained control on the naming of the temporary filename as it uses the File Language. The location for tempFilename is relative to the final file location in the option 'fileName', not the target directory in the base uri. For example if option fileName includes a directory prefix: dir/finalFilename then tempFileName is relative to that subdirectory dir.",
          "type" : "string"
        },
        "temp-prefix" : {
          "description" : "This option is used to write the file using a temporary name and then, after the write is complete, rename it to the real name. Can be used to identify files being written and also avoid consumers (not using exclusive read locks) reading in progress files. Is often used by FTP when uploading big files.",
          "type" : "string"
        },
        "time-unit" : {
          "description" : "Time unit for initialDelay and delay options.",
          "default" : "MILLISECONDS",
          "enum" : [ "NANOSECONDS", "MICROSECONDS", "MILLISECONDS", "SECONDS", "MINUTES", "HOURS", "DAYS" ],
          "type" : "string"
        },
        "use-fixed-delay" : {
          "description" : "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
          "default" : "true",
          "type" : "boolean"
        }
      }
    },
    "file-watch" : {
      "type" : "object",
      "required" : [ "path" ],
      "properties" : {
        "path" : {
          "description" : "Path of directory to consume events from.",
          "type" : "string"
        },
        "ant-include" : {
          "description" : "ANT style pattern to match files. The file is matched against path relative to endpoint path. Pattern must be also relative (not starting with slash)",
          "default" : "**",
          "type" : "string"
        },
        "auto-create" : {
          "description" : "Auto create directory if does not exists.",
          "default" : "true",
          "type" : "boolean"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "concurrent-consumers" : {
          "description" : "The number of concurrent consumers. Increase this value, if your route is slow to prevent buffering in queue.",
          "default" : "1",
          "type" : "integer"
        },
        "events" : {
          "description" : "Comma separated list of events to watch.",
          "default" : "CREATE,MODIFY,DELETE",
          "enum" : [ "CREATE", "MODIFY", "DELETE" ],
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "file-hasher" : {
          "description" : "Reference to io.methvin.watcher.hashing.FileHasher. This prevents emitting duplicate events on some platforms. For working with large files and if you dont need detect multiple modifications per second per file, use #lastModifiedTimeFileHasher. You can also provide custom implementation in registry.",
          "default" : "#murmur3FFileHasher",
          "type" : "string"
        },
        "poll-threads" : {
          "description" : "The number of threads polling WatchService. Increase this value, if you see OVERFLOW messages in log.",
          "default" : "1",
          "type" : "integer"
        },
        "queue-size" : {
          "description" : "Maximum size of queue between WatchService and consumer. Unbounded by default.",
          "default" : "2147483647",
          "type" : "integer"
        },
        "recursive" : {
          "description" : "Watch recursive in current and child directories (including newly created directories).",
          "default" : "true",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "use-file-hashing" : {
          "description" : "Enables or disables file hashing to detect duplicate events. If you disable this, you can get some events multiple times on some platforms and JDKs. Check java.nio.file.WatchService limitations for your target platform.",
          "default" : "true",
          "type" : "boolean"
        }
      }
    },
    "flatpack" : {
      "type" : "object",
      "required" : [ "resourceUri" ],
      "properties" : {
        "resource-uri" : {
          "description" : "URL for loading the flatpack mapping file from classpath or file system",
          "type" : "string"
        },
        "type" : {
          "description" : "Whether to use fixed or delimiter",
          "default" : "delim",
          "enum" : [ "fixed", "delim" ],
          "type" : "string"
        },
        "allow-short-lines" : {
          "description" : "Allows for lines to be shorter than expected and ignores the extra characters",
          "default" : "false",
          "type" : "boolean"
        },
        "backoff-error-threshold" : {
          "description" : "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-idle-threshold" : {
          "description" : "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-multiplier" : {
          "description" : "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
          "type" : "integer"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "delay" : {
          "description" : "Milliseconds before the next poll.",
          "default" : "500",
          "type" : "integer"
        },
        "delimiter" : {
          "description" : "The default character delimiter for delimited files.",
          "default" : ",",
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "greedy" : {
          "description" : "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
          "default" : "false",
          "type" : "boolean"
        },
        "ignore-extra-columns" : {
          "description" : "Allows for lines to be longer than expected and ignores the extra characters",
          "default" : "false",
          "type" : "boolean"
        },
        "ignore-first-record" : {
          "description" : "Whether the first line is ignored for delimited files (for the column headers).",
          "default" : "true",
          "type" : "boolean"
        },
        "initial-delay" : {
          "description" : "Milliseconds before the first poll starts.",
          "default" : "1000",
          "type" : "integer"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "poll-strategy" : {
          "description" : "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
          "type" : "string"
        },
        "repeat-count" : {
          "description" : "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
          "default" : "0",
          "type" : "integer"
        },
        "run-logging-level" : {
          "description" : "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
          "default" : "TRACE",
          "enum" : [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ],
          "type" : "string"
        },
        "scheduled-executor-service" : {
          "description" : "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
          "type" : "string"
        },
        "scheduler" : {
          "description" : "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
          "default" : "none",
          "type" : "string"
        },
        "scheduler-properties" : {
          "description" : "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
          "type" : "string"
        },
        "send-empty-message-when-idle" : {
          "description" : "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
          "default" : "false",
          "type" : "boolean"
        },
        "split-rows" : {
          "description" : "Sets the Component to send each row as a separate exchange once parsed",
          "default" : "true",
          "type" : "boolean"
        },
        "start-scheduler" : {
          "description" : "Whether the scheduler should be auto started.",
          "default" : "true",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "text-qualifier" : {
          "description" : "The text qualifier for delimited files.",
          "type" : "string"
        },
        "time-unit" : {
          "description" : "Time unit for initialDelay and delay options.",
          "default" : "MILLISECONDS",
          "enum" : [ "NANOSECONDS", "MICROSECONDS", "MILLISECONDS", "SECONDS", "MINUTES", "HOURS", "DAYS" ],
          "type" : "string"
        },
        "use-fixed-delay" : {
          "description" : "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
          "default" : "true",
          "type" : "boolean"
        }
      }
    },
    "flink" : {
      "type" : "object",
      "required" : [ "endpointType" ],
      "properties" : {
        "endpoint-type" : {
          "description" : "Type of the endpoint (dataset, datastream).",
          "enum" : [ "dataset", "datastream" ],
          "type" : "string"
        },
        "collect" : {
          "description" : "Indicates if results should be collected or counted.",
          "default" : "true",
          "type" : "boolean"
        },
        "data-set" : {
          "description" : "DataSet to compute against.",
          "type" : "string"
        },
        "data-set-callback" : {
          "description" : "Function performing action against a DataSet.",
          "type" : "string"
        },
        "data-stream" : {
          "description" : "DataStream to compute against.",
          "type" : "string"
        },
        "data-stream-callback" : {
          "description" : "Function performing action against a DataStream.",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "fop" : {
      "type" : "object",
      "required" : [ "outputType" ],
      "properties" : {
        "output-type" : {
          "description" : "The primary output format is PDF but other output formats are also supported.",
          "enum" : [ "pdf", "ps", "pcl", "png", "jpeg", "svg", "xml", "mif", "rtf", "txt" ],
          "type" : "string"
        },
        "fop-factory" : {
          "description" : "Allows to use a custom configured or implementation of org.apache.fop.apps.FopFactory.",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "user-config-url" : {
          "description" : "The location of a configuration file which can be loaded from classpath or file system.",
          "type" : "string"
        }
      }
    },
    "freemarker" : {
      "type" : "object",
      "required" : [ "resourceUri" ],
      "properties" : {
        "resource-uri" : {
          "description" : "Path to the resource. You can prefix with: classpath, file, http, ref, or bean. classpath, file and http loads the resource using these protocols (classpath is default). ref will lookup the resource in the registry. bean will call a method on a bean to be used as the resource. For bean you can specify the method name after dot, eg bean:myBean.myMethod.",
          "type" : "string"
        },
        "allow-context-map-all" : {
          "description" : "Sets whether the context map should allow access to all details. By default only the message body and headers can be accessed. This option can be enabled for full access to the current Exchange and CamelContext. Doing so impose a potential security risk as this opens access to the full power of CamelContext API.",
          "default" : "false",
          "type" : "boolean"
        },
        "allow-template-from-header" : {
          "description" : "Whether to allow to use resource template from header or not (default false). Enabling this allows to specify dynamic templates via message header. However this can be seen as a potential security vulnerability if the header is coming from a malicious user, so use this with care.",
          "default" : "false",
          "type" : "boolean"
        },
        "configuration" : {
          "description" : "Sets the Freemarker configuration to use",
          "type" : "string"
        },
        "content-cache" : {
          "description" : "Sets whether to use resource content cache or not",
          "default" : "false",
          "type" : "boolean"
        },
        "encoding" : {
          "description" : "Sets the encoding to be used for loading the template file.",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "template-update-delay" : {
          "description" : "Number of seconds the loaded template resource will remain in the cache.",
          "type" : "integer"
        }
      }
    },
    "ftp" : {
      "type" : "object",
      "properties" : {
        "directory-name" : {
          "description" : "The starting directory",
          "type" : "string"
        },
        "host" : {
          "description" : "Hostname of the FTP server",
          "type" : "string"
        },
        "port" : {
          "description" : "Port of the FTP server",
          "type" : "integer"
        },
        "account" : {
          "description" : "Account to use for login",
          "type" : "string"
        },
        "active-port-range" : {
          "description" : "Set the client side port range in active mode. The syntax is: minPort-maxPort Both port numbers are inclusive, eg 10000-19999 to include all 1xxxx ports.",
          "type" : "string"
        },
        "allow-null-body" : {
          "description" : "Used to specify if a null body is allowed during file writing. If set to true then an empty file will be created, when set to false, and attempting to send a null body to the file component, a GenericFileWriteException of 'Cannot write null body to file.' will be thrown. If the fileExist option is set to 'Override', then the file will be truncated, and if set to append the file will remain unchanged.",
          "default" : "false",
          "type" : "boolean"
        },
        "ant-exclude" : {
          "description" : "Ant style filter exclusion. If both antInclude and antExclude are used, antExclude takes precedence over antInclude. Multiple exclusions may be specified in comma-delimited format.",
          "type" : "string"
        },
        "ant-filter-case-sensitive" : {
          "description" : "Sets case sensitive flag on ant filter.",
          "default" : "true",
          "type" : "boolean"
        },
        "ant-include" : {
          "description" : "Ant style filter inclusion. Multiple inclusions may be specified in comma-delimited format.",
          "type" : "string"
        },
        "auto-create" : {
          "description" : "Automatically create missing directories in the file's pathname. For the file consumer, that means creating the starting directory. For the file producer, it means the directory the files should be written to.",
          "default" : "true",
          "type" : "boolean"
        },
        "backoff-error-threshold" : {
          "description" : "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-idle-threshold" : {
          "description" : "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-multiplier" : {
          "description" : "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
          "type" : "integer"
        },
        "binary" : {
          "description" : "Specifies the file transfer mode, BINARY or ASCII. Default is ASCII (false).",
          "default" : "false",
          "type" : "boolean"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "buffer-size" : {
          "description" : "Buffer size in bytes used for writing files (or in case of FTP for downloading and uploading files).",
          "default" : "131072",
          "type" : "integer"
        },
        "charset" : {
          "description" : "This option is used to specify the encoding of the file. You can use this on the consumer, to specify the encodings of the files, which allow Camel to know the charset it should load the file content in case the file content is being accessed. Likewise when writing a file, you can use this option to specify which charset to write the file as well. Do mind that when writing the file Camel may have to read the message content into memory to be able to convert the data into the configured charset, so do not use this if you have big messages.",
          "type" : "string"
        },
        "chmod" : {
          "description" : "Allows you to set chmod on the stored file. For example chmod=640.",
          "type" : "string"
        },
        "connect-timeout" : {
          "description" : "Sets the connect timeout for waiting for a connection to be established Used by both FTPClient and JSCH",
          "default" : "10000",
          "type" : "string"
        },
        "delay" : {
          "description" : "Milliseconds before the next poll.",
          "default" : "500",
          "type" : "integer"
        },
        "delete" : {
          "description" : "If true, the file will be deleted after it is processed successfully.",
          "default" : "false",
          "type" : "boolean"
        },
        "disconnect" : {
          "description" : "Whether or not to disconnect from remote FTP server right after use. Disconnect will only disconnect the current connection to the FTP server. If you have a consumer which you want to stop, then you need to stop the consumer/route instead.",
          "default" : "false",
          "type" : "boolean"
        },
        "disconnect-on-batch-complete" : {
          "description" : "Whether or not to disconnect from remote FTP server right after a Batch upload is complete. disconnectOnBatchComplete will only disconnect the current connection to the FTP server.",
          "default" : "false",
          "type" : "boolean"
        },
        "done-file-name" : {
          "description" : "Producer: If provided, then Camel will write a 2nd done file when the original file has been written. The done file will be empty. This option configures what file name to use. Either you can specify a fixed name. Or you can use dynamic placeholders. The done file will always be written in the same folder as the original file. Consumer: If provided, Camel will only consume files if a done file exists. This option configures what file name to use. Either you can specify a fixed name. Or you can use dynamic placeholders.The done file is always expected in the same folder as the original file. Only ${file.name} and ${file.name.next} is supported as dynamic placeholders.",
          "type" : "string"
        },
        "download" : {
          "description" : "Whether the FTP consumer should download the file. If this option is set to false, then the message body will be null, but the consumer will still trigger a Camel Exchange that has details about the file such as file name, file size, etc. It's just that the file will not be downloaded.",
          "default" : "false",
          "type" : "boolean"
        },
        "eager-delete-target-file" : {
          "description" : "Whether or not to eagerly delete any existing target file. This option only applies when you use fileExists=Override and the tempFileName option as well. You can use this to disable (set it to false) deleting the target file before the temp file is written. For example you may write big files and want the target file to exists during the temp file is being written. This ensure the target file is only deleted until the very last moment, just before the temp file is being renamed to the target filename. This option is also used to control whether to delete any existing files when fileExist=Move is enabled, and an existing file exists. If this option copyAndDeleteOnRenameFails false, then an exception will be thrown if an existing file existed, if its true, then the existing file is deleted before the move operation.",
          "default" : "true",
          "type" : "boolean"
        },
        "eager-max-messages-per-poll" : {
          "description" : "Allows for controlling whether the limit from maxMessagesPerPoll is eager or not. If eager then the limit is during the scanning of files. Where as false would scan all files, and then perform sorting. Setting this option to false allows for sorting all files first, and then limit the poll. Mind that this requires a higher memory usage as all file details are in memory to perform the sorting.",
          "default" : "true",
          "type" : "boolean"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "exclude" : {
          "description" : "Is used to exclude files, if filename matches the regex pattern (matching is case in-senstive). Notice if you use symbols such as plus sign and others you would need to configure this using the RAW() syntax if configuring this as an endpoint uri. See more details at configuring endpoint uris",
          "type" : "string"
        },
        "exclusive-read-lock-strategy" : {
          "description" : "Pluggable read-lock as a org.apache.camel.component.file.GenericFileExclusiveReadLockStrategy implementation.",
          "type" : "string"
        },
        "fast-exists-check" : {
          "description" : "If set this option to be true, camel-ftp will use the list file directly to check if the file exists. Since some FTP server may not support to list the file directly, if the option is false, camel-ftp will use the old way to list the directory and check if the file exists. This option also influences readLock=changed to control whether it performs a fast check to update file information or not. This can be used to speed up the process if the FTP server has a lot of files.",
          "default" : "false",
          "type" : "boolean"
        },
        "file-exist" : {
          "description" : "What to do if a file already exists with the same name. Override, which is the default, replaces the existing file. - Append - adds content to the existing file. - Fail - throws a GenericFileOperationException, indicating that there is already an existing file. - Ignore - silently ignores the problem and does not override the existing file, but assumes everything is okay. - Move - option requires to use the moveExisting option to be configured as well. The option eagerDeleteTargetFile can be used to control what to do if an moving the file, and there exists already an existing file, otherwise causing the move operation to fail. The Move option will move any existing files, before writing the target file. - TryRename is only applicable if tempFileName option is in use. This allows to try renaming the file from the temporary name to the actual name, without doing any exists check. This check may be faster on some file systems and especially FTP servers.",
          "default" : "Override",
          "enum" : [ "Override", "Append", "Fail", "Ignore", "Move", "TryRename" ],
          "type" : "string"
        },
        "file-name" : {
          "description" : "Use Expression such as File Language to dynamically set the filename. For consumers, it's used as a filename filter. For producers, it's used to evaluate the filename to write. If an expression is set, it take precedence over the CamelFileName header. (Note: The header itself can also be an Expression). The expression options support both String and Expression types. If the expression is a String type, it is always evaluated using the File Language. If the expression is an Expression type, the specified Expression type is used - this allows you, for instance, to use OGNL expressions. For the consumer, you can use it to filter filenames, so you can for instance consume today's file using the File Language syntax: mydata-${date:now:yyyyMMdd}.txt. The producers support the CamelOverruleFileName header which takes precedence over any existing CamelFileName header; the CamelOverruleFileName is a header that is used only once, and makes it easier as this avoids to temporary store CamelFileName and have to restore it afterwards.",
          "type" : "string"
        },
        "filter" : {
          "description" : "Pluggable filter as a org.apache.camel.component.file.GenericFileFilter class. Will skip files if filter returns false in its accept() method.",
          "type" : "string"
        },
        "filter-directory" : {
          "description" : "Filters the directory based on Simple language. For example to filter on current date, you can use a simple date pattern such as ${date:now:yyyMMdd}",
          "type" : "string"
        },
        "filter-file" : {
          "description" : "Filters the file based on Simple language. For example to filter on file size, you can use ${file:size} 5000",
          "type" : "string"
        },
        "flatten" : {
          "description" : "Flatten is used to flatten the file name path to strip any leading paths, so it's just the file name. This allows you to consume recursively into sub-directories, but when you eg write the files to another directory they will be written in a single directory. Setting this to true on the producer enforces that any file name in CamelFileName header will be stripped for any leading paths.",
          "default" : "false",
          "type" : "boolean"
        },
        "ftp-client" : {
          "description" : "To use a custom instance of FTPClient",
          "type" : "string"
        },
        "ftp-client-config" : {
          "description" : "To use a custom instance of FTPClientConfig to configure the FTP client the endpoint should use.",
          "type" : "string"
        },
        "ftp-client-config-parameters" : {
          "description" : "Used by FtpComponent to provide additional parameters for the FTPClientConfig",
          "type" : "string"
        },
        "ftp-client-parameters" : {
          "description" : "Used by FtpComponent to provide additional parameters for the FTPClient",
          "type" : "string"
        },
        "greedy" : {
          "description" : "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
          "default" : "false",
          "type" : "boolean"
        },
        "handle-directory-parser-absolute-result" : {
          "description" : "Allows you to set how the consumer will handle subfolders and files in the path if the directory parser results in with absolute paths The reason for this is that some FTP servers may return file names with absolute paths, and if so then the FTP component needs to handle this by converting the returned path into a relative path.",
          "default" : "false",
          "type" : "boolean"
        },
        "idempotent" : {
          "description" : "Option to use the Idempotent Consumer EIP pattern to let Camel skip already processed files. Will by default use a memory based LRUCache that holds 1000 entries. If noop=true then idempotent will be enabled as well to avoid consuming the same files over and over again.",
          "default" : "false",
          "type" : "boolean"
        },
        "idempotent-key" : {
          "description" : "To use a custom idempotent key. By default the absolute path of the file is used. You can use the File Language, for example to use the file name and file size, you can do: idempotentKey=${file:name}-${file:size}",
          "type" : "string"
        },
        "idempotent-repository" : {
          "description" : "A pluggable repository org.apache.camel.spi.IdempotentRepository which by default use MemoryMessageIdRepository if none is specified and idempotent is true.",
          "type" : "string"
        },
        "ignore-file-not-found-or-permission-error" : {
          "description" : "Whether to ignore when (trying to list files in directories or when downloading a file), which does not exist or due to permission error. By default when a directory or file does not exists or insufficient permission, then an exception is thrown. Setting this option to true allows to ignore that instead.",
          "default" : "false",
          "type" : "boolean"
        },
        "in-progress-repository" : {
          "description" : "A pluggable in-progress repository org.apache.camel.spi.IdempotentRepository. The in-progress repository is used to account the current in progress files being consumed. By default a memory based repository is used.",
          "type" : "string"
        },
        "include" : {
          "description" : "Is used to include files, if filename matches the regex pattern (matching is case in-sensitive). Notice if you use symbols such as plus sign and others you would need to configure this using the RAW() syntax if configuring this as an endpoint uri. See more details at configuring endpoint uris",
          "type" : "string"
        },
        "initial-delay" : {
          "description" : "Milliseconds before the first poll starts.",
          "default" : "1000",
          "type" : "integer"
        },
        "jail-starting-directory" : {
          "description" : "Used for jailing (restricting) writing files to the starting directory (and sub) only. This is enabled by default to not allow Camel to write files to outside directories (to be more secured out of the box). You can turn this off to allow writing files to directories outside the starting directory, such as parent or root folders.",
          "default" : "true",
          "type" : "boolean"
        },
        "keep-last-modified" : {
          "description" : "Will keep the last modified timestamp from the source file (if any). Will use the Exchange.FILE_LAST_MODIFIED header to located the timestamp. This header can contain either a java.util.Date or long with the timestamp. If the timestamp exists and the option is enabled it will set this timestamp on the written file. Note: This option only applies to the file producer. You cannot use this option with any of the ftp producers.",
          "default" : "false",
          "type" : "boolean"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "local-work-directory" : {
          "description" : "When consuming, a local work directory can be used to store the remote file content directly in local files, to avoid loading the content into memory. This is beneficial, if you consume a very big remote file and thus can conserve memory.",
          "type" : "string"
        },
        "max-depth" : {
          "description" : "The maximum depth to traverse when recursively processing a directory.",
          "default" : "2147483647",
          "type" : "integer"
        },
        "max-messages-per-poll" : {
          "description" : "To define a maximum messages to gather per poll. By default no maximum is set. Can be used to set a limit of e.g. 1000 to avoid when starting up the server that there are thousands of files. Set a value of 0 or negative to disabled it. Notice: If this option is in use then the File and FTP components will limit before any sorting. For example if you have 100000 files and use maxMessagesPerPoll=500, then only the first 500 files will be picked up, and then sorted. You can use the eagerMaxMessagesPerPoll option and set this to false to allow to scan all files first and then sort afterwards.",
          "type" : "integer"
        },
        "maximum-reconnect-attempts" : {
          "description" : "Specifies the maximum reconnect attempts Camel performs when it tries to connect to the remote FTP server. Use 0 to disable this behavior.",
          "type" : "integer"
        },
        "min-depth" : {
          "description" : "The minimum depth to start processing when recursively processing a directory. Using minDepth=1 means the base directory. Using minDepth=2 means the first sub directory.",
          "type" : "integer"
        },
        "move" : {
          "description" : "Expression (such as Simple Language) used to dynamically set the filename when moving it after processing. To move files into a .done subdirectory just enter .done.",
          "type" : "string"
        },
        "move-existing" : {
          "description" : "Expression (such as File Language) used to compute file name to use when fileExist=Move is configured. To move files into a backup subdirectory just enter backup. This option only supports the following File Language tokens: file:name, file:name.ext, file:name.noext, file:onlyname, file:onlyname.noext, file:ext, and file:parent. Notice the file:parent is not supported by the FTP component, as the FTP component can only move any existing files to a relative directory based on current dir as base.",
          "type" : "string"
        },
        "move-existing-file-strategy" : {
          "description" : "Strategy (Custom Strategy) used to move file with special naming token to use when fileExist=Move is configured. By default, there is an implementation used if no custom strategy is provided",
          "type" : "string"
        },
        "move-failed" : {
          "description" : "Sets the move failure expression based on Simple language. For example, to move files into a .error subdirectory use: .error. Note: When moving the files to the fail location Camel will handle the error and will not pick up the file again.",
          "type" : "string"
        },
        "noop" : {
          "description" : "If true, the file is not moved or deleted in any way. This option is good for readonly data, or for ETL type requirements. If noop=true, Camel will set idempotent=true as well, to avoid consuming the same files over and over again.",
          "default" : "false",
          "type" : "boolean"
        },
        "on-completion-exception-handler" : {
          "description" : "To use a custom org.apache.camel.spi.ExceptionHandler to handle any thrown exceptions that happens during the file on completion process where the consumer does either a commit or rollback. The default implementation will log any exception at WARN level and ignore.",
          "type" : "string"
        },
        "passive-mode" : {
          "description" : "Sets passive mode connections. Default is active mode connections.",
          "default" : "false",
          "type" : "boolean"
        },
        "password" : {
          "description" : "Password to use for login",
          "type" : "string"
        },
        "poll-strategy" : {
          "description" : "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
          "type" : "string"
        },
        "pre-move" : {
          "description" : "Expression (such as File Language) used to dynamically set the filename when moving it before processing. For example to move in-progress files into the order directory set this value to order.",
          "type" : "string"
        },
        "pre-sort" : {
          "description" : "When pre-sort is enabled then the consumer will sort the file and directory names during polling, that was retrieved from the file system. You may want to do this in case you need to operate on the files in a sorted order. The pre-sort is executed before the consumer starts to filter, and accept files to process by Camel. This option is default=false meaning disabled.",
          "default" : "false",
          "type" : "boolean"
        },
        "process-strategy" : {
          "description" : "A pluggable org.apache.camel.component.file.GenericFileProcessStrategy allowing you to implement your own readLock option or similar. Can also be used when special conditions must be met before a file can be consumed, such as a special ready file exists. If this option is set then the readLock option does not apply.",
          "type" : "string"
        },
        "read-lock" : {
          "description" : "Used by consumer, to only poll the files if it has exclusive read-lock on the file (i.e. the file is not in-progress or being written). Camel will wait until the file lock is granted. This option provides the build in strategies: - none - No read lock is in use - markerFile - Camel creates a marker file (fileName.camelLock) and then holds a lock on it. This option is not available for the FTP component - changed - Changed is using file length/modification timestamp to detect whether the file is currently being copied or not. Will at least use 1 sec to determine this, so this option cannot consume files as fast as the others, but can be more reliable as the JDK IO API cannot always determine whether a file is currently being used by another process. The option readLockCheckInterval can be used to set the check frequency. - fileLock - is for using java.nio.channels.FileLock. This option is not avail for Windows OS and the FTP component. This approach should be avoided when accessing a remote file system via a mount/share unless that file system supports distributed file locks. - rename - rename is for using a try to rename the file as a test if we can get exclusive read-lock. - idempotent - (only for file component) idempotent is for using a idempotentRepository as the read-lock. This allows to use read locks that supports clustering if the idempotent repository implementation supports that. - idempotent-changed - (only for file component) idempotent-changed is for using a idempotentRepository and changed as the combined read-lock. This allows to use read locks that supports clustering if the idempotent repository implementation supports that. - idempotent-rename - (only for file component) idempotent-rename is for using a idempotentRepository and rename as the combined read-lock. This allows to use read locks that supports clustering if the idempotent repository implementation supports that.Notice: The various read locks is not all suited to work in clustered mode, where concurrent consumers on different nodes is competing for the same files on a shared file system. The markerFile using a close to atomic operation to create the empty marker file, but its not guaranteed to work in a cluster. The fileLock may work better but then the file system need to support distributed file locks, and so on. Using the idempotent read lock can support clustering if the idempotent repository supports clustering, such as Hazelcast Component or Infinispan.",
          "default" : "none",
          "enum" : [ "none", "markerFile", "fileLock", "rename", "changed", "idempotent", "idempotent-changed", "idempotent-rename" ],
          "type" : "string"
        },
        "read-lock-check-interval" : {
          "description" : "Interval in millis for the read-lock, if supported by the read lock. This interval is used for sleeping between attempts to acquire the read lock. For example when using the changed read lock, you can set a higher interval period to cater for slow writes. The default of 1 sec. may be too fast if the producer is very slow writing the file. Notice: For FTP the default readLockCheckInterval is 5000. The readLockTimeout value must be higher than readLockCheckInterval, but a rule of thumb is to have a timeout that is at least 2 or more times higher than the readLockCheckInterval. This is needed to ensure that amble time is allowed for the read lock process to try to grab the lock before the timeout was hit.",
          "default" : "1000",
          "type" : "integer"
        },
        "read-lock-delete-orphan-lock-files" : {
          "description" : "Whether or not read lock with marker files should upon startup delete any orphan read lock files, which may have been left on the file system, if Camel was not properly shutdown (such as a JVM crash). If turning this option to false then any orphaned lock file will cause Camel to not attempt to pickup that file, this could also be due another node is concurrently reading files from the same shared directory.",
          "default" : "true",
          "type" : "boolean"
        },
        "read-lock-logging-level" : {
          "description" : "Logging level used when a read lock could not be acquired. By default a DEBUG is logged. You can change this level, for example to OFF to not have any logging. This option is only applicable for readLock of types: changed, fileLock, idempotent, idempotent-changed, idempotent-rename, rename.",
          "default" : "DEBUG",
          "enum" : [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ],
          "type" : "string"
        },
        "read-lock-marker-file" : {
          "description" : "Whether to use marker file with the changed, rename, or exclusive read lock types. By default a marker file is used as well to guard against other processes picking up the same files. This behavior can be turned off by setting this option to false. For example if you do not want to write marker files to the file systems by the Camel application.",
          "default" : "true",
          "type" : "boolean"
        },
        "read-lock-min-age" : {
          "description" : "This option is applied only for readLock=changed. It allows to specify a minimum age the file must be before attempting to acquire the read lock. For example use readLockMinAge=300s to require the file is at last 5 minutes old. This can speedup the changed read lock as it will only attempt to acquire files which are at least that given age.",
          "default" : "0",
          "type" : "integer"
        },
        "read-lock-min-length" : {
          "description" : "This option is applied only for readLock=changed. It allows you to configure a minimum file length. By default Camel expects the file to contain data, and thus the default value is 1. You can set this option to zero, to allow consuming zero-length files.",
          "default" : "1",
          "type" : "integer"
        },
        "read-lock-remove-on-commit" : {
          "description" : "This option is applied only for readLock=idempotent. It allows to specify whether to remove the file name entry from the idempotent repository when processing the file is succeeded and a commit happens. By default the file is not removed which ensures that any race-condition do not occur so another active node may attempt to grab the file. Instead the idempotent repository may support eviction strategies that you can configure to evict the file name entry after X minutes - this ensures no problems with race conditions. See more details at the readLockIdempotentReleaseDelay option.",
          "default" : "false",
          "type" : "boolean"
        },
        "read-lock-remove-on-rollback" : {
          "description" : "This option is applied only for readLock=idempotent. It allows to specify whether to remove the file name entry from the idempotent repository when processing the file failed and a rollback happens. If this option is false, then the file name entry is confirmed (as if the file did a commit).",
          "default" : "true",
          "type" : "boolean"
        },
        "read-lock-timeout" : {
          "description" : "Optional timeout in millis for the read-lock, if supported by the read-lock. If the read-lock could not be granted and the timeout triggered, then Camel will skip the file. At next poll Camel, will try the file again, and this time maybe the read-lock could be granted. Use a value of 0 or lower to indicate forever. Currently fileLock, changed and rename support the timeout. Notice: For FTP the default readLockTimeout value is 20000 instead of 10000. The readLockTimeout value must be higher than readLockCheckInterval, but a rule of thumb is to have a timeout that is at least 2 or more times higher than the readLockCheckInterval. This is needed to ensure that amble time is allowed for the read lock process to try to grab the lock before the timeout was hit.",
          "default" : "10000",
          "type" : "integer"
        },
        "reconnect-delay" : {
          "description" : "Delay in millis Camel will wait before performing a reconnect attempt.",
          "type" : "string"
        },
        "recursive" : {
          "description" : "If a directory, will look for files in all the sub-directories as well.",
          "default" : "false",
          "type" : "boolean"
        },
        "repeat-count" : {
          "description" : "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
          "default" : "0",
          "type" : "integer"
        },
        "resume-download" : {
          "description" : "Configures whether resume download is enabled. This must be supported by the FTP server (almost all FTP servers support it). In addition the options localWorkDirectory must be configured so downloaded files are stored in a local directory, and the option binary must be enabled, which is required to support resuming of downloads.",
          "default" : "false",
          "type" : "boolean"
        },
        "run-logging-level" : {
          "description" : "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
          "default" : "TRACE",
          "enum" : [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ],
          "type" : "string"
        },
        "scheduled-executor-service" : {
          "description" : "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
          "type" : "string"
        },
        "scheduler" : {
          "description" : "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
          "default" : "none",
          "type" : "string"
        },
        "scheduler-properties" : {
          "description" : "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
          "type" : "string"
        },
        "send-empty-message-when-idle" : {
          "description" : "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
          "default" : "false",
          "type" : "boolean"
        },
        "send-noop" : {
          "description" : "Whether to send a noop command as a pre-write check before uploading files to the FTP server. This is enabled by default as a validation of the connection is still valid, which allows to silently re-connect to be able to upload the file. However if this causes problems, you can turn this option off.",
          "default" : "true",
          "type" : "boolean"
        },
        "separator" : {
          "description" : "Sets the path separator to be used. UNIX = Uses unix style path separator Windows = Uses windows style path separator Auto = (is default) Use existing path separator in file name",
          "default" : "UNIX",
          "enum" : [ "UNIX", "Windows", "Auto" ],
          "type" : "string"
        },
        "shuffle" : {
          "description" : "To shuffle the list of files (sort in random order)",
          "default" : "false",
          "type" : "boolean"
        },
        "site-command" : {
          "description" : "Sets optional site command(s) to be executed after successful login. Multiple site commands can be separated using a new line character.",
          "type" : "string"
        },
        "so-timeout" : {
          "description" : "Sets the so timeout FTP and FTPS Only for Camel 2.4. SFTP for Camel 2.14.3/2.15.3/2.16 onwards. Is the SocketOptions.SO_TIMEOUT value in millis. Recommended option is to set this to 300000 so as not have a hanged connection. On SFTP this option is set as timeout on the JSCH Session instance.",
          "default" : "5m",
          "type" : "string"
        },
        "sort-by" : {
          "description" : "Built-in sort by using the File Language. Supports nested sorts, so you can have a sort by file name and as a 2nd group sort by modified date.",
          "type" : "string"
        },
        "sorter" : {
          "description" : "Pluggable sorter as a java.util.Comparator class.",
          "type" : "string"
        },
        "start-scheduler" : {
          "description" : "Whether the scheduler should be auto started.",
          "default" : "true",
          "type" : "boolean"
        },
        "stepwise" : {
          "description" : "Sets whether we should stepwise change directories while traversing file structures when downloading files, or as well when uploading a file to a directory. You can disable this if you for example are in a situation where you cannot change directory on the FTP server due security reasons. Stepwise cannot be used together with streamDownload.",
          "default" : "true",
          "type" : "boolean"
        },
        "stream-download" : {
          "description" : "Sets the download method to use when not using a local working directory. If set to true, the remote files are streamed to the route as they are read. When set to false, the remote files are loaded into memory before being sent into the route. If enabling this option then you must set stepwise=false as both cannot be enabled at the same time.",
          "default" : "false",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "temp-file-name" : {
          "description" : "The same as tempPrefix option but offering a more fine grained control on the naming of the temporary filename as it uses the File Language. The location for tempFilename is relative to the final file location in the option 'fileName', not the target directory in the base uri. For example if option fileName includes a directory prefix: dir/finalFilename then tempFileName is relative to that subdirectory dir.",
          "type" : "string"
        },
        "temp-prefix" : {
          "description" : "This option is used to write the file using a temporary name and then, after the write is complete, rename it to the real name. Can be used to identify files being written and also avoid consumers (not using exclusive read locks) reading in progress files. Is often used by FTP when uploading big files.",
          "type" : "string"
        },
        "throw-exception-on-connect-failed" : {
          "description" : "Should an exception be thrown if connection failed (exhausted) By default exception is not thrown and a WARN is logged. You can use this to enable exception being thrown and handle the thrown exception from the org.apache.camel.spi.PollingConsumerPollStrategy rollback method.",
          "default" : "false",
          "type" : "boolean"
        },
        "time-unit" : {
          "description" : "Time unit for initialDelay and delay options.",
          "default" : "MILLISECONDS",
          "enum" : [ "NANOSECONDS", "MICROSECONDS", "MILLISECONDS", "SECONDS", "MINUTES", "HOURS", "DAYS" ],
          "type" : "string"
        },
        "timeout" : {
          "description" : "Sets the data timeout for waiting for reply Used only by FTPClient",
          "default" : "30s",
          "type" : "string"
        },
        "transfer-logging-interval-seconds" : {
          "description" : "Configures the interval in seconds to use when logging the progress of upload and download operations that are in-flight. This is used for logging progress when operations takes longer time.",
          "default" : "5",
          "type" : "integer"
        },
        "transfer-logging-level" : {
          "description" : "Configure the logging level to use when logging the progress of upload and download operations.",
          "default" : "DEBUG",
          "enum" : [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ],
          "type" : "string"
        },
        "transfer-logging-verbose" : {
          "description" : "Configures whether the perform verbose (fine grained) logging of the progress of upload and download operations.",
          "default" : "false",
          "type" : "boolean"
        },
        "use-fixed-delay" : {
          "description" : "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
          "default" : "true",
          "type" : "boolean"
        },
        "use-list" : {
          "description" : "Whether to allow using LIST command when downloading a file. Default is true. In some use cases you may want to download a specific file and are not allowed to use the LIST command, and therefore you can set this option to false. Notice when using this option, then the specific file to download does not include meta-data information such as file size, timestamp, permissions etc, because those information is only possible to retrieve when LIST command is in use.",
          "default" : "true",
          "type" : "boolean"
        },
        "username" : {
          "description" : "Username to use for login",
          "type" : "string"
        }
      },
      "required" : [ "host" ]
    },
    "ftps" : {
      "type" : "object",
      "properties" : {
        "directory-name" : {
          "description" : "The starting directory",
          "type" : "string"
        },
        "host" : {
          "description" : "Hostname of the FTP server",
          "type" : "string"
        },
        "port" : {
          "description" : "Port of the FTP server",
          "type" : "integer"
        },
        "account" : {
          "description" : "Account to use for login",
          "type" : "string"
        },
        "active-port-range" : {
          "description" : "Set the client side port range in active mode. The syntax is: minPort-maxPort Both port numbers are inclusive, eg 10000-19999 to include all 1xxxx ports.",
          "type" : "string"
        },
        "allow-null-body" : {
          "description" : "Used to specify if a null body is allowed during file writing. If set to true then an empty file will be created, when set to false, and attempting to send a null body to the file component, a GenericFileWriteException of 'Cannot write null body to file.' will be thrown. If the fileExist option is set to 'Override', then the file will be truncated, and if set to append the file will remain unchanged.",
          "default" : "false",
          "type" : "boolean"
        },
        "ant-exclude" : {
          "description" : "Ant style filter exclusion. If both antInclude and antExclude are used, antExclude takes precedence over antInclude. Multiple exclusions may be specified in comma-delimited format.",
          "type" : "string"
        },
        "ant-filter-case-sensitive" : {
          "description" : "Sets case sensitive flag on ant filter.",
          "default" : "true",
          "type" : "boolean"
        },
        "ant-include" : {
          "description" : "Ant style filter inclusion. Multiple inclusions may be specified in comma-delimited format.",
          "type" : "string"
        },
        "auto-create" : {
          "description" : "Automatically create missing directories in the file's pathname. For the file consumer, that means creating the starting directory. For the file producer, it means the directory the files should be written to.",
          "default" : "true",
          "type" : "boolean"
        },
        "backoff-error-threshold" : {
          "description" : "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-idle-threshold" : {
          "description" : "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-multiplier" : {
          "description" : "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
          "type" : "integer"
        },
        "binary" : {
          "description" : "Specifies the file transfer mode, BINARY or ASCII. Default is ASCII (false).",
          "default" : "false",
          "type" : "boolean"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "buffer-size" : {
          "description" : "Buffer size in bytes used for writing files (or in case of FTP for downloading and uploading files).",
          "default" : "131072",
          "type" : "integer"
        },
        "charset" : {
          "description" : "This option is used to specify the encoding of the file. You can use this on the consumer, to specify the encodings of the files, which allow Camel to know the charset it should load the file content in case the file content is being accessed. Likewise when writing a file, you can use this option to specify which charset to write the file as well. Do mind that when writing the file Camel may have to read the message content into memory to be able to convert the data into the configured charset, so do not use this if you have big messages.",
          "type" : "string"
        },
        "chmod" : {
          "description" : "Allows you to set chmod on the stored file. For example chmod=640.",
          "type" : "string"
        },
        "connect-timeout" : {
          "description" : "Sets the connect timeout for waiting for a connection to be established Used by both FTPClient and JSCH",
          "default" : "10000",
          "type" : "string"
        },
        "delay" : {
          "description" : "Milliseconds before the next poll.",
          "default" : "500",
          "type" : "integer"
        },
        "delete" : {
          "description" : "If true, the file will be deleted after it is processed successfully.",
          "default" : "false",
          "type" : "boolean"
        },
        "disable-secure-data-channel-defaults" : {
          "description" : "Use this option to disable default options when using secure data channel. This allows you to be in full control what the execPbsz and execProt setting should be used. Default is false",
          "default" : "false",
          "type" : "boolean"
        },
        "disconnect" : {
          "description" : "Whether or not to disconnect from remote FTP server right after use. Disconnect will only disconnect the current connection to the FTP server. If you have a consumer which you want to stop, then you need to stop the consumer/route instead.",
          "default" : "false",
          "type" : "boolean"
        },
        "disconnect-on-batch-complete" : {
          "description" : "Whether or not to disconnect from remote FTP server right after a Batch upload is complete. disconnectOnBatchComplete will only disconnect the current connection to the FTP server.",
          "default" : "false",
          "type" : "boolean"
        },
        "done-file-name" : {
          "description" : "Producer: If provided, then Camel will write a 2nd done file when the original file has been written. The done file will be empty. This option configures what file name to use. Either you can specify a fixed name. Or you can use dynamic placeholders. The done file will always be written in the same folder as the original file. Consumer: If provided, Camel will only consume files if a done file exists. This option configures what file name to use. Either you can specify a fixed name. Or you can use dynamic placeholders.The done file is always expected in the same folder as the original file. Only ${file.name} and ${file.name.next} is supported as dynamic placeholders.",
          "type" : "string"
        },
        "download" : {
          "description" : "Whether the FTP consumer should download the file. If this option is set to false, then the message body will be null, but the consumer will still trigger a Camel Exchange that has details about the file such as file name, file size, etc. It's just that the file will not be downloaded.",
          "default" : "false",
          "type" : "boolean"
        },
        "eager-delete-target-file" : {
          "description" : "Whether or not to eagerly delete any existing target file. This option only applies when you use fileExists=Override and the tempFileName option as well. You can use this to disable (set it to false) deleting the target file before the temp file is written. For example you may write big files and want the target file to exists during the temp file is being written. This ensure the target file is only deleted until the very last moment, just before the temp file is being renamed to the target filename. This option is also used to control whether to delete any existing files when fileExist=Move is enabled, and an existing file exists. If this option copyAndDeleteOnRenameFails false, then an exception will be thrown if an existing file existed, if its true, then the existing file is deleted before the move operation.",
          "default" : "true",
          "type" : "boolean"
        },
        "eager-max-messages-per-poll" : {
          "description" : "Allows for controlling whether the limit from maxMessagesPerPoll is eager or not. If eager then the limit is during the scanning of files. Where as false would scan all files, and then perform sorting. Setting this option to false allows for sorting all files first, and then limit the poll. Mind that this requires a higher memory usage as all file details are in memory to perform the sorting.",
          "default" : "true",
          "type" : "boolean"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "exclude" : {
          "description" : "Is used to exclude files, if filename matches the regex pattern (matching is case in-senstive). Notice if you use symbols such as plus sign and others you would need to configure this using the RAW() syntax if configuring this as an endpoint uri. See more details at configuring endpoint uris",
          "type" : "string"
        },
        "exclusive-read-lock-strategy" : {
          "description" : "Pluggable read-lock as a org.apache.camel.component.file.GenericFileExclusiveReadLockStrategy implementation.",
          "type" : "string"
        },
        "exec-pbsz" : {
          "description" : "When using secure data channel you can set the exec protection buffer size",
          "type" : "integer"
        },
        "exec-prot" : {
          "description" : "The exec protection level PROT command. C - Clear S - Safe(SSL protocol only) E - Confidential(SSL protocol only) P - Private",
          "type" : "string"
        },
        "fast-exists-check" : {
          "description" : "If set this option to be true, camel-ftp will use the list file directly to check if the file exists. Since some FTP server may not support to list the file directly, if the option is false, camel-ftp will use the old way to list the directory and check if the file exists. This option also influences readLock=changed to control whether it performs a fast check to update file information or not. This can be used to speed up the process if the FTP server has a lot of files.",
          "default" : "false",
          "type" : "boolean"
        },
        "file-exist" : {
          "description" : "What to do if a file already exists with the same name. Override, which is the default, replaces the existing file. - Append - adds content to the existing file. - Fail - throws a GenericFileOperationException, indicating that there is already an existing file. - Ignore - silently ignores the problem and does not override the existing file, but assumes everything is okay. - Move - option requires to use the moveExisting option to be configured as well. The option eagerDeleteTargetFile can be used to control what to do if an moving the file, and there exists already an existing file, otherwise causing the move operation to fail. The Move option will move any existing files, before writing the target file. - TryRename is only applicable if tempFileName option is in use. This allows to try renaming the file from the temporary name to the actual name, without doing any exists check. This check may be faster on some file systems and especially FTP servers.",
          "default" : "Override",
          "enum" : [ "Override", "Append", "Fail", "Ignore", "Move", "TryRename" ],
          "type" : "string"
        },
        "file-name" : {
          "description" : "Use Expression such as File Language to dynamically set the filename. For consumers, it's used as a filename filter. For producers, it's used to evaluate the filename to write. If an expression is set, it take precedence over the CamelFileName header. (Note: The header itself can also be an Expression). The expression options support both String and Expression types. If the expression is a String type, it is always evaluated using the File Language. If the expression is an Expression type, the specified Expression type is used - this allows you, for instance, to use OGNL expressions. For the consumer, you can use it to filter filenames, so you can for instance consume today's file using the File Language syntax: mydata-${date:now:yyyyMMdd}.txt. The producers support the CamelOverruleFileName header which takes precedence over any existing CamelFileName header; the CamelOverruleFileName is a header that is used only once, and makes it easier as this avoids to temporary store CamelFileName and have to restore it afterwards.",
          "type" : "string"
        },
        "filter" : {
          "description" : "Pluggable filter as a org.apache.camel.component.file.GenericFileFilter class. Will skip files if filter returns false in its accept() method.",
          "type" : "string"
        },
        "filter-directory" : {
          "description" : "Filters the directory based on Simple language. For example to filter on current date, you can use a simple date pattern such as ${date:now:yyyMMdd}",
          "type" : "string"
        },
        "filter-file" : {
          "description" : "Filters the file based on Simple language. For example to filter on file size, you can use ${file:size} 5000",
          "type" : "string"
        },
        "flatten" : {
          "description" : "Flatten is used to flatten the file name path to strip any leading paths, so it's just the file name. This allows you to consume recursively into sub-directories, but when you eg write the files to another directory they will be written in a single directory. Setting this to true on the producer enforces that any file name in CamelFileName header will be stripped for any leading paths.",
          "default" : "false",
          "type" : "boolean"
        },
        "ftp-client" : {
          "description" : "To use a custom instance of FTPClient",
          "type" : "string"
        },
        "ftp-client-config" : {
          "description" : "To use a custom instance of FTPClientConfig to configure the FTP client the endpoint should use.",
          "type" : "string"
        },
        "ftp-client-config-parameters" : {
          "description" : "Used by FtpComponent to provide additional parameters for the FTPClientConfig",
          "type" : "string"
        },
        "ftp-client-key-store-parameters" : {
          "description" : "Set the key store parameters",
          "type" : "string"
        },
        "ftp-client-parameters" : {
          "description" : "Used by FtpComponent to provide additional parameters for the FTPClient",
          "type" : "string"
        },
        "ftp-client-trust-store-parameters" : {
          "description" : "Set the trust store parameters",
          "type" : "string"
        },
        "greedy" : {
          "description" : "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
          "default" : "false",
          "type" : "boolean"
        },
        "handle-directory-parser-absolute-result" : {
          "description" : "Allows you to set how the consumer will handle subfolders and files in the path if the directory parser results in with absolute paths The reason for this is that some FTP servers may return file names with absolute paths, and if so then the FTP component needs to handle this by converting the returned path into a relative path.",
          "default" : "false",
          "type" : "boolean"
        },
        "idempotent" : {
          "description" : "Option to use the Idempotent Consumer EIP pattern to let Camel skip already processed files. Will by default use a memory based LRUCache that holds 1000 entries. If noop=true then idempotent will be enabled as well to avoid consuming the same files over and over again.",
          "default" : "false",
          "type" : "boolean"
        },
        "idempotent-key" : {
          "description" : "To use a custom idempotent key. By default the absolute path of the file is used. You can use the File Language, for example to use the file name and file size, you can do: idempotentKey=${file:name}-${file:size}",
          "type" : "string"
        },
        "idempotent-repository" : {
          "description" : "A pluggable repository org.apache.camel.spi.IdempotentRepository which by default use MemoryMessageIdRepository if none is specified and idempotent is true.",
          "type" : "string"
        },
        "ignore-file-not-found-or-permission-error" : {
          "description" : "Whether to ignore when (trying to list files in directories or when downloading a file), which does not exist or due to permission error. By default when a directory or file does not exists or insufficient permission, then an exception is thrown. Setting this option to true allows to ignore that instead.",
          "default" : "false",
          "type" : "boolean"
        },
        "implicit" : {
          "description" : "Set the security mode (Implicit/Explicit). true - Implicit Mode / False - Explicit Mode",
          "default" : "false",
          "type" : "boolean"
        },
        "in-progress-repository" : {
          "description" : "A pluggable in-progress repository org.apache.camel.spi.IdempotentRepository. The in-progress repository is used to account the current in progress files being consumed. By default a memory based repository is used.",
          "type" : "string"
        },
        "include" : {
          "description" : "Is used to include files, if filename matches the regex pattern (matching is case in-sensitive). Notice if you use symbols such as plus sign and others you would need to configure this using the RAW() syntax if configuring this as an endpoint uri. See more details at configuring endpoint uris",
          "type" : "string"
        },
        "initial-delay" : {
          "description" : "Milliseconds before the first poll starts.",
          "default" : "1000",
          "type" : "integer"
        },
        "jail-starting-directory" : {
          "description" : "Used for jailing (restricting) writing files to the starting directory (and sub) only. This is enabled by default to not allow Camel to write files to outside directories (to be more secured out of the box). You can turn this off to allow writing files to directories outside the starting directory, such as parent or root folders.",
          "default" : "true",
          "type" : "boolean"
        },
        "keep-last-modified" : {
          "description" : "Will keep the last modified timestamp from the source file (if any). Will use the Exchange.FILE_LAST_MODIFIED header to located the timestamp. This header can contain either a java.util.Date or long with the timestamp. If the timestamp exists and the option is enabled it will set this timestamp on the written file. Note: This option only applies to the file producer. You cannot use this option with any of the ftp producers.",
          "default" : "false",
          "type" : "boolean"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "local-work-directory" : {
          "description" : "When consuming, a local work directory can be used to store the remote file content directly in local files, to avoid loading the content into memory. This is beneficial, if you consume a very big remote file and thus can conserve memory.",
          "type" : "string"
        },
        "max-depth" : {
          "description" : "The maximum depth to traverse when recursively processing a directory.",
          "default" : "2147483647",
          "type" : "integer"
        },
        "max-messages-per-poll" : {
          "description" : "To define a maximum messages to gather per poll. By default no maximum is set. Can be used to set a limit of e.g. 1000 to avoid when starting up the server that there are thousands of files. Set a value of 0 or negative to disabled it. Notice: If this option is in use then the File and FTP components will limit before any sorting. For example if you have 100000 files and use maxMessagesPerPoll=500, then only the first 500 files will be picked up, and then sorted. You can use the eagerMaxMessagesPerPoll option and set this to false to allow to scan all files first and then sort afterwards.",
          "type" : "integer"
        },
        "maximum-reconnect-attempts" : {
          "description" : "Specifies the maximum reconnect attempts Camel performs when it tries to connect to the remote FTP server. Use 0 to disable this behavior.",
          "type" : "integer"
        },
        "min-depth" : {
          "description" : "The minimum depth to start processing when recursively processing a directory. Using minDepth=1 means the base directory. Using minDepth=2 means the first sub directory.",
          "type" : "integer"
        },
        "move" : {
          "description" : "Expression (such as Simple Language) used to dynamically set the filename when moving it after processing. To move files into a .done subdirectory just enter .done.",
          "type" : "string"
        },
        "move-existing" : {
          "description" : "Expression (such as File Language) used to compute file name to use when fileExist=Move is configured. To move files into a backup subdirectory just enter backup. This option only supports the following File Language tokens: file:name, file:name.ext, file:name.noext, file:onlyname, file:onlyname.noext, file:ext, and file:parent. Notice the file:parent is not supported by the FTP component, as the FTP component can only move any existing files to a relative directory based on current dir as base.",
          "type" : "string"
        },
        "move-existing-file-strategy" : {
          "description" : "Strategy (Custom Strategy) used to move file with special naming token to use when fileExist=Move is configured. By default, there is an implementation used if no custom strategy is provided",
          "type" : "string"
        },
        "move-failed" : {
          "description" : "Sets the move failure expression based on Simple language. For example, to move files into a .error subdirectory use: .error. Note: When moving the files to the fail location Camel will handle the error and will not pick up the file again.",
          "type" : "string"
        },
        "noop" : {
          "description" : "If true, the file is not moved or deleted in any way. This option is good for readonly data, or for ETL type requirements. If noop=true, Camel will set idempotent=true as well, to avoid consuming the same files over and over again.",
          "default" : "false",
          "type" : "boolean"
        },
        "on-completion-exception-handler" : {
          "description" : "To use a custom org.apache.camel.spi.ExceptionHandler to handle any thrown exceptions that happens during the file on completion process where the consumer does either a commit or rollback. The default implementation will log any exception at WARN level and ignore.",
          "type" : "string"
        },
        "passive-mode" : {
          "description" : "Sets passive mode connections. Default is active mode connections.",
          "default" : "false",
          "type" : "boolean"
        },
        "password" : {
          "description" : "Password to use for login",
          "type" : "string"
        },
        "poll-strategy" : {
          "description" : "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
          "type" : "string"
        },
        "pre-move" : {
          "description" : "Expression (such as File Language) used to dynamically set the filename when moving it before processing. For example to move in-progress files into the order directory set this value to order.",
          "type" : "string"
        },
        "pre-sort" : {
          "description" : "When pre-sort is enabled then the consumer will sort the file and directory names during polling, that was retrieved from the file system. You may want to do this in case you need to operate on the files in a sorted order. The pre-sort is executed before the consumer starts to filter, and accept files to process by Camel. This option is default=false meaning disabled.",
          "default" : "false",
          "type" : "boolean"
        },
        "process-strategy" : {
          "description" : "A pluggable org.apache.camel.component.file.GenericFileProcessStrategy allowing you to implement your own readLock option or similar. Can also be used when special conditions must be met before a file can be consumed, such as a special ready file exists. If this option is set then the readLock option does not apply.",
          "type" : "string"
        },
        "read-lock" : {
          "description" : "Used by consumer, to only poll the files if it has exclusive read-lock on the file (i.e. the file is not in-progress or being written). Camel will wait until the file lock is granted. This option provides the build in strategies: - none - No read lock is in use - markerFile - Camel creates a marker file (fileName.camelLock) and then holds a lock on it. This option is not available for the FTP component - changed - Changed is using file length/modification timestamp to detect whether the file is currently being copied or not. Will at least use 1 sec to determine this, so this option cannot consume files as fast as the others, but can be more reliable as the JDK IO API cannot always determine whether a file is currently being used by another process. The option readLockCheckInterval can be used to set the check frequency. - fileLock - is for using java.nio.channels.FileLock. This option is not avail for Windows OS and the FTP component. This approach should be avoided when accessing a remote file system via a mount/share unless that file system supports distributed file locks. - rename - rename is for using a try to rename the file as a test if we can get exclusive read-lock. - idempotent - (only for file component) idempotent is for using a idempotentRepository as the read-lock. This allows to use read locks that supports clustering if the idempotent repository implementation supports that. - idempotent-changed - (only for file component) idempotent-changed is for using a idempotentRepository and changed as the combined read-lock. This allows to use read locks that supports clustering if the idempotent repository implementation supports that. - idempotent-rename - (only for file component) idempotent-rename is for using a idempotentRepository and rename as the combined read-lock. This allows to use read locks that supports clustering if the idempotent repository implementation supports that.Notice: The various read locks is not all suited to work in clustered mode, where concurrent consumers on different nodes is competing for the same files on a shared file system. The markerFile using a close to atomic operation to create the empty marker file, but its not guaranteed to work in a cluster. The fileLock may work better but then the file system need to support distributed file locks, and so on. Using the idempotent read lock can support clustering if the idempotent repository supports clustering, such as Hazelcast Component or Infinispan.",
          "default" : "none",
          "enum" : [ "none", "markerFile", "fileLock", "rename", "changed", "idempotent", "idempotent-changed", "idempotent-rename" ],
          "type" : "string"
        },
        "read-lock-check-interval" : {
          "description" : "Interval in millis for the read-lock, if supported by the read lock. This interval is used for sleeping between attempts to acquire the read lock. For example when using the changed read lock, you can set a higher interval period to cater for slow writes. The default of 1 sec. may be too fast if the producer is very slow writing the file. Notice: For FTP the default readLockCheckInterval is 5000. The readLockTimeout value must be higher than readLockCheckInterval, but a rule of thumb is to have a timeout that is at least 2 or more times higher than the readLockCheckInterval. This is needed to ensure that amble time is allowed for the read lock process to try to grab the lock before the timeout was hit.",
          "default" : "1000",
          "type" : "integer"
        },
        "read-lock-delete-orphan-lock-files" : {
          "description" : "Whether or not read lock with marker files should upon startup delete any orphan read lock files, which may have been left on the file system, if Camel was not properly shutdown (such as a JVM crash). If turning this option to false then any orphaned lock file will cause Camel to not attempt to pickup that file, this could also be due another node is concurrently reading files from the same shared directory.",
          "default" : "true",
          "type" : "boolean"
        },
        "read-lock-logging-level" : {
          "description" : "Logging level used when a read lock could not be acquired. By default a DEBUG is logged. You can change this level, for example to OFF to not have any logging. This option is only applicable for readLock of types: changed, fileLock, idempotent, idempotent-changed, idempotent-rename, rename.",
          "default" : "DEBUG",
          "enum" : [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ],
          "type" : "string"
        },
        "read-lock-marker-file" : {
          "description" : "Whether to use marker file with the changed, rename, or exclusive read lock types. By default a marker file is used as well to guard against other processes picking up the same files. This behavior can be turned off by setting this option to false. For example if you do not want to write marker files to the file systems by the Camel application.",
          "default" : "true",
          "type" : "boolean"
        },
        "read-lock-min-age" : {
          "description" : "This option is applied only for readLock=changed. It allows to specify a minimum age the file must be before attempting to acquire the read lock. For example use readLockMinAge=300s to require the file is at last 5 minutes old. This can speedup the changed read lock as it will only attempt to acquire files which are at least that given age.",
          "default" : "0",
          "type" : "integer"
        },
        "read-lock-min-length" : {
          "description" : "This option is applied only for readLock=changed. It allows you to configure a minimum file length. By default Camel expects the file to contain data, and thus the default value is 1. You can set this option to zero, to allow consuming zero-length files.",
          "default" : "1",
          "type" : "integer"
        },
        "read-lock-remove-on-commit" : {
          "description" : "This option is applied only for readLock=idempotent. It allows to specify whether to remove the file name entry from the idempotent repository when processing the file is succeeded and a commit happens. By default the file is not removed which ensures that any race-condition do not occur so another active node may attempt to grab the file. Instead the idempotent repository may support eviction strategies that you can configure to evict the file name entry after X minutes - this ensures no problems with race conditions. See more details at the readLockIdempotentReleaseDelay option.",
          "default" : "false",
          "type" : "boolean"
        },
        "read-lock-remove-on-rollback" : {
          "description" : "This option is applied only for readLock=idempotent. It allows to specify whether to remove the file name entry from the idempotent repository when processing the file failed and a rollback happens. If this option is false, then the file name entry is confirmed (as if the file did a commit).",
          "default" : "true",
          "type" : "boolean"
        },
        "read-lock-timeout" : {
          "description" : "Optional timeout in millis for the read-lock, if supported by the read-lock. If the read-lock could not be granted and the timeout triggered, then Camel will skip the file. At next poll Camel, will try the file again, and this time maybe the read-lock could be granted. Use a value of 0 or lower to indicate forever. Currently fileLock, changed and rename support the timeout. Notice: For FTP the default readLockTimeout value is 20000 instead of 10000. The readLockTimeout value must be higher than readLockCheckInterval, but a rule of thumb is to have a timeout that is at least 2 or more times higher than the readLockCheckInterval. This is needed to ensure that amble time is allowed for the read lock process to try to grab the lock before the timeout was hit.",
          "default" : "10000",
          "type" : "integer"
        },
        "reconnect-delay" : {
          "description" : "Delay in millis Camel will wait before performing a reconnect attempt.",
          "type" : "string"
        },
        "recursive" : {
          "description" : "If a directory, will look for files in all the sub-directories as well.",
          "default" : "false",
          "type" : "boolean"
        },
        "repeat-count" : {
          "description" : "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
          "default" : "0",
          "type" : "integer"
        },
        "resume-download" : {
          "description" : "Configures whether resume download is enabled. This must be supported by the FTP server (almost all FTP servers support it). In addition the options localWorkDirectory must be configured so downloaded files are stored in a local directory, and the option binary must be enabled, which is required to support resuming of downloads.",
          "default" : "false",
          "type" : "boolean"
        },
        "run-logging-level" : {
          "description" : "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
          "default" : "TRACE",
          "enum" : [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ],
          "type" : "string"
        },
        "scheduled-executor-service" : {
          "description" : "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
          "type" : "string"
        },
        "scheduler" : {
          "description" : "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
          "default" : "none",
          "type" : "string"
        },
        "scheduler-properties" : {
          "description" : "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
          "type" : "string"
        },
        "security-protocol" : {
          "description" : "Set the underlying security protocol.",
          "default" : "TLSv1.2",
          "type" : "string"
        },
        "send-empty-message-when-idle" : {
          "description" : "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
          "default" : "false",
          "type" : "boolean"
        },
        "send-noop" : {
          "description" : "Whether to send a noop command as a pre-write check before uploading files to the FTP server. This is enabled by default as a validation of the connection is still valid, which allows to silently re-connect to be able to upload the file. However if this causes problems, you can turn this option off.",
          "default" : "true",
          "type" : "boolean"
        },
        "separator" : {
          "description" : "Sets the path separator to be used. UNIX = Uses unix style path separator Windows = Uses windows style path separator Auto = (is default) Use existing path separator in file name",
          "default" : "UNIX",
          "enum" : [ "UNIX", "Windows", "Auto" ],
          "type" : "string"
        },
        "shuffle" : {
          "description" : "To shuffle the list of files (sort in random order)",
          "default" : "false",
          "type" : "boolean"
        },
        "site-command" : {
          "description" : "Sets optional site command(s) to be executed after successful login. Multiple site commands can be separated using a new line character.",
          "type" : "string"
        },
        "so-timeout" : {
          "description" : "Sets the so timeout FTP and FTPS Only for Camel 2.4. SFTP for Camel 2.14.3/2.15.3/2.16 onwards. Is the SocketOptions.SO_TIMEOUT value in millis. Recommended option is to set this to 300000 so as not have a hanged connection. On SFTP this option is set as timeout on the JSCH Session instance.",
          "default" : "5m",
          "type" : "string"
        },
        "sort-by" : {
          "description" : "Built-in sort by using the File Language. Supports nested sorts, so you can have a sort by file name and as a 2nd group sort by modified date.",
          "type" : "string"
        },
        "sorter" : {
          "description" : "Pluggable sorter as a java.util.Comparator class.",
          "type" : "string"
        },
        "ssl-context-parameters" : {
          "description" : "Gets the JSSE configuration that overrides any settings in FtpsEndpoint#ftpClientKeyStoreParameters, ftpClientTrustStoreParameters, and FtpsConfiguration#getSecurityProtocol().",
          "type" : "string"
        },
        "start-scheduler" : {
          "description" : "Whether the scheduler should be auto started.",
          "default" : "true",
          "type" : "boolean"
        },
        "stepwise" : {
          "description" : "Sets whether we should stepwise change directories while traversing file structures when downloading files, or as well when uploading a file to a directory. You can disable this if you for example are in a situation where you cannot change directory on the FTP server due security reasons. Stepwise cannot be used together with streamDownload.",
          "default" : "true",
          "type" : "boolean"
        },
        "stream-download" : {
          "description" : "Sets the download method to use when not using a local working directory. If set to true, the remote files are streamed to the route as they are read. When set to false, the remote files are loaded into memory before being sent into the route. If enabling this option then you must set stepwise=false as both cannot be enabled at the same time.",
          "default" : "false",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "temp-file-name" : {
          "description" : "The same as tempPrefix option but offering a more fine grained control on the naming of the temporary filename as it uses the File Language. The location for tempFilename is relative to the final file location in the option 'fileName', not the target directory in the base uri. For example if option fileName includes a directory prefix: dir/finalFilename then tempFileName is relative to that subdirectory dir.",
          "type" : "string"
        },
        "temp-prefix" : {
          "description" : "This option is used to write the file using a temporary name and then, after the write is complete, rename it to the real name. Can be used to identify files being written and also avoid consumers (not using exclusive read locks) reading in progress files. Is often used by FTP when uploading big files.",
          "type" : "string"
        },
        "throw-exception-on-connect-failed" : {
          "description" : "Should an exception be thrown if connection failed (exhausted) By default exception is not thrown and a WARN is logged. You can use this to enable exception being thrown and handle the thrown exception from the org.apache.camel.spi.PollingConsumerPollStrategy rollback method.",
          "default" : "false",
          "type" : "boolean"
        },
        "time-unit" : {
          "description" : "Time unit for initialDelay and delay options.",
          "default" : "MILLISECONDS",
          "enum" : [ "NANOSECONDS", "MICROSECONDS", "MILLISECONDS", "SECONDS", "MINUTES", "HOURS", "DAYS" ],
          "type" : "string"
        },
        "timeout" : {
          "description" : "Sets the data timeout for waiting for reply Used only by FTPClient",
          "default" : "30s",
          "type" : "string"
        },
        "transfer-logging-interval-seconds" : {
          "description" : "Configures the interval in seconds to use when logging the progress of upload and download operations that are in-flight. This is used for logging progress when operations takes longer time.",
          "default" : "5",
          "type" : "integer"
        },
        "transfer-logging-level" : {
          "description" : "Configure the logging level to use when logging the progress of upload and download operations.",
          "default" : "DEBUG",
          "enum" : [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ],
          "type" : "string"
        },
        "transfer-logging-verbose" : {
          "description" : "Configures whether the perform verbose (fine grained) logging of the progress of upload and download operations.",
          "default" : "false",
          "type" : "boolean"
        },
        "use-fixed-delay" : {
          "description" : "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
          "default" : "true",
          "type" : "boolean"
        },
        "use-list" : {
          "description" : "Whether to allow using LIST command when downloading a file. Default is true. In some use cases you may want to download a specific file and are not allowed to use the LIST command, and therefore you can set this option to false. Notice when using this option, then the specific file to download does not include meta-data information such as file size, timestamp, permissions etc, because those information is only possible to retrieve when LIST command is in use.",
          "default" : "true",
          "type" : "boolean"
        },
        "username" : {
          "description" : "Username to use for login",
          "type" : "string"
        }
      },
      "required" : [ "host" ]
    },
    "ganglia" : {
      "type" : "object",
      "properties" : {
        "host" : {
          "description" : "Host name for Ganglia server",
          "default" : "239.2.11.71",
          "type" : "string"
        },
        "port" : {
          "description" : "Port for Ganglia server",
          "default" : "8649",
          "type" : "integer"
        },
        "dmax" : {
          "description" : "Minumum time in seconds before Ganglia will purge the metric value if it expires. Set to 0 and the value will remain in Ganglia indefinitely until a gmond agent restart.",
          "default" : "0",
          "type" : "integer"
        },
        "group-name" : {
          "description" : "The group that the metric belongs to.",
          "default" : "java",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "metric-name" : {
          "description" : "The name to use for the metric.",
          "default" : "metric",
          "type" : "string"
        },
        "mode" : {
          "description" : "Send the UDP metric packets using MULTICAST or UNICAST",
          "default" : "MULTICAST",
          "enum" : [ "MULTICAST", "UNICAST" ],
          "type" : "string"
        },
        "prefix" : {
          "description" : "Prefix the metric name with this string and an underscore.",
          "type" : "string"
        },
        "slope" : {
          "description" : "The slope",
          "default" : "BOTH",
          "enum" : [ "ZERO", "POSITIVE", "NEGATIVE", "BOTH" ],
          "type" : "string"
        },
        "spoof-hostname" : {
          "description" : "Spoofing information IP:hostname",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "tmax" : {
          "description" : "Maximum time in seconds that the value can be considered current. After this, Ganglia considers the value to have expired.",
          "default" : "60",
          "type" : "integer"
        },
        "ttl" : {
          "description" : "If using multicast, set the TTL of the packets",
          "default" : "5",
          "type" : "integer"
        },
        "type" : {
          "description" : "The type of value",
          "default" : "STRING",
          "enum" : [ "STRING", "INT8", "UINT8", "INT16", "UINT16", "INT32", "UINT32", "FLOAT", "DOUBLE" ],
          "type" : "string"
        },
        "units" : {
          "description" : "Any unit of measurement that qualifies the metric, e.g. widgets, litres, bytes. Do not include a prefix such as k (kilo) or m (milli), other tools may scale the units later. The value should be unscaled.",
          "type" : "string"
        },
        "wire-format31x" : {
          "description" : "Use the wire format of Ganglia 3.1.0 and later versions. Set this to false to use Ganglia 3.0.x or earlier.",
          "default" : "true",
          "type" : "boolean"
        }
      }
    },
    "geocoder" : {
      "type" : "object",
      "properties" : {
        "address" : {
          "description" : "The geo address which should be prefixed with address:",
          "type" : "string"
        },
        "latlng" : {
          "description" : "The geo latitude and longitude which should be prefixed with latlng:",
          "type" : "string"
        },
        "api-key" : {
          "description" : "API Key to access Google. Mandatory for Google GeoCoding server.",
          "type" : "string"
        },
        "client-id" : {
          "description" : "Client ID to access Google GeoCoding server.",
          "type" : "string"
        },
        "client-key" : {
          "description" : "Client Key to access Google GeoCoding server.",
          "type" : "string"
        },
        "headers-only" : {
          "description" : "Whether to only enrich the Exchange with headers, and leave the body as-is.",
          "default" : "false",
          "type" : "boolean"
        },
        "language" : {
          "description" : "The language to use.",
          "default" : "en",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "proxy-auth-domain" : {
          "description" : "Proxy Authentication Domain to access Google GeoCoding server.",
          "type" : "string"
        },
        "proxy-auth-host" : {
          "description" : "Proxy Authentication Host to access Google GeoCoding server.",
          "type" : "string"
        },
        "proxy-auth-method" : {
          "description" : "Authentication Method to Google GeoCoding server.",
          "type" : "string"
        },
        "proxy-auth-password" : {
          "description" : "Proxy Password to access GeoCoding server.",
          "type" : "string"
        },
        "proxy-auth-username" : {
          "description" : "Proxy Username to access GeoCoding server.",
          "type" : "string"
        },
        "proxy-host" : {
          "description" : "Proxy Host to access GeoCoding server.",
          "type" : "string"
        },
        "proxy-port" : {
          "description" : "Proxy Port to access GeoCoding server.",
          "type" : "integer"
        },
        "server-url" : {
          "description" : "URL to the geocoder server. Mandatory for Nominatim server.",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "type" : {
          "description" : "Type of GeoCoding server. Supported Nominatim and Google.",
          "enum" : [ "NOMINATIM", "GOOGLE" ],
          "type" : "string"
        }
      }
    },
    "git" : {
      "type" : "object",
      "required" : [ "localPath" ],
      "properties" : {
        "local-path" : {
          "description" : "Local repository path",
          "type" : "string"
        },
        "allow-empty" : {
          "description" : "The flag to manage empty git commits",
          "default" : "true",
          "type" : "boolean"
        },
        "branch-name" : {
          "description" : "The branch name to work on",
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "operation" : {
          "description" : "The operation to do on the repository",
          "enum" : [ "clone", "init", "add", "remove", "commit", "commitAll", "createBranch", "deleteBranch", "createTag", "deleteTag", "status", "log", "push", "pull", "showBranches", "cherryPick", "remoteAdd", "remoteList" ],
          "type" : "string"
        },
        "password" : {
          "description" : "Remote repository password",
          "type" : "string"
        },
        "remote-name" : {
          "description" : "The remote repository name to use in particular operation like pull",
          "type" : "string"
        },
        "remote-path" : {
          "description" : "The remote repository path",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "tag-name" : {
          "description" : "The tag name to work on",
          "type" : "string"
        },
        "type" : {
          "description" : "The consumer type",
          "enum" : [ "commit", "tag", "branch" ],
          "type" : "string"
        },
        "username" : {
          "description" : "Remote repository username",
          "type" : "string"
        }
      }
    },
    "github" : {
      "type" : "object",
      "properties" : {
        "branch-name" : {
          "description" : "Name of branch",
          "type" : "string"
        },
        "type" : {
          "description" : "What git operation to execute",
          "enum" : [ "CLOSEPULLREQUEST", "PULLREQUESTCOMMENT", "COMMIT", "PULLREQUEST", "TAG", "PULLREQUESTSTATE", "PULLREQUESTFILES", "GETCOMMITFILE", "CREATEISSUE", "EVENT" ],
          "type" : "string"
        },
        "backoff-error-threshold" : {
          "description" : "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-idle-threshold" : {
          "description" : "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-multiplier" : {
          "description" : "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
          "type" : "integer"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "delay" : {
          "description" : "Milliseconds before the next poll.",
          "default" : "500",
          "type" : "integer"
        },
        "encoding" : {
          "description" : "To use the given encoding when getting a git commit file",
          "type" : "string"
        },
        "event-fetch-strategy" : {
          "description" : "To specify a custom strategy that configures how the EventsConsumer fetches events.",
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "greedy" : {
          "description" : "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
          "default" : "false",
          "type" : "boolean"
        },
        "initial-delay" : {
          "description" : "Milliseconds before the first poll starts.",
          "default" : "1000",
          "type" : "integer"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "oauth-token" : {
          "description" : "GitHub OAuth token. Must be configured on either component or endpoint.",
          "type" : "string"
        },
        "poll-strategy" : {
          "description" : "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
          "type" : "string"
        },
        "repeat-count" : {
          "description" : "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
          "default" : "0",
          "type" : "integer"
        },
        "repo-name" : {
          "description" : "GitHub repository name",
          "type" : "string"
        },
        "repo-owner" : {
          "description" : "GitHub repository owner (organization)",
          "type" : "string"
        },
        "run-logging-level" : {
          "description" : "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
          "default" : "TRACE",
          "enum" : [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ],
          "type" : "string"
        },
        "scheduled-executor-service" : {
          "description" : "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
          "type" : "string"
        },
        "scheduler" : {
          "description" : "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
          "default" : "none",
          "type" : "string"
        },
        "scheduler-properties" : {
          "description" : "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
          "type" : "string"
        },
        "send-empty-message-when-idle" : {
          "description" : "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
          "default" : "false",
          "type" : "boolean"
        },
        "start-scheduler" : {
          "description" : "Whether the scheduler should be auto started.",
          "default" : "true",
          "type" : "boolean"
        },
        "state" : {
          "description" : "To set git commit status state",
          "enum" : [ "error", "failure", "pending", "success" ],
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "target-url" : {
          "description" : "To set git commit status target url",
          "type" : "string"
        },
        "time-unit" : {
          "description" : "Time unit for initialDelay and delay options.",
          "default" : "MILLISECONDS",
          "enum" : [ "NANOSECONDS", "MICROSECONDS", "MILLISECONDS", "SECONDS", "MINUTES", "HOURS", "DAYS" ],
          "type" : "string"
        },
        "use-fixed-delay" : {
          "description" : "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
          "default" : "true",
          "type" : "boolean"
        }
      },
      "required" : [ "type", "repoName", "repoOwner" ]
    },
    "google-bigquery" : {
      "type" : "object",
      "required" : [ "datasetId", "projectId" ],
      "properties" : {
        "dataset-id" : {
          "description" : "BigQuery Dataset Id",
          "type" : "string"
        },
        "project-id" : {
          "description" : "Google Cloud Project Id",
          "type" : "string"
        },
        "table-id" : {
          "description" : "BigQuery table id",
          "type" : "string"
        },
        "connection-factory" : {
          "description" : "ConnectionFactory to obtain connection to Bigquery Service. If not provided the default one will be used",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "use-as-insert-id" : {
          "description" : "Field name to use as insert id",
          "type" : "string"
        }
      }
    },
    "google-bigquery-sql" : {
      "type" : "object",
      "required" : [ "projectId", "query" ],
      "properties" : {
        "project-id" : {
          "description" : "Google Cloud Project Id",
          "type" : "string"
        },
        "query" : {
          "description" : "BigQuery standard SQL query",
          "type" : "string"
        },
        "connection-factory" : {
          "description" : "ConnectionFactory to obtain connection to Bigquery Service. If not provided the default one will be used",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "google-calendar" : {
      "type" : "object",
      "required" : [ "apiName", "methodName" ],
      "properties" : {
        "api-name" : {
          "description" : "What kind of operation to perform",
          "enum" : [ "ACL", "LIST", "CALENDARS", "CHANNELS", "COLORS", "FREEBUSY", "EVENTS", "SETTINGS" ],
          "type" : "string"
        },
        "method-name" : {
          "description" : "What sub operation to use for the selected operation",
          "enum" : [ "calendarImport", "clear", "delete", "get", "insert", "instances", "list", "move", "patch", "query", "quickAdd", "stop", "update", "watch" ],
          "type" : "string"
        },
        "access-token" : {
          "description" : "OAuth 2 access token. This typically expires after an hour so refreshToken is recommended for long term usage.",
          "type" : "string"
        },
        "application-name" : {
          "description" : "Google calendar application name. Example would be camel-google-calendar/1.0",
          "type" : "string"
        },
        "backoff-error-threshold" : {
          "description" : "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-idle-threshold" : {
          "description" : "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-multiplier" : {
          "description" : "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
          "type" : "integer"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "client-id" : {
          "description" : "Client ID of the calendar application",
          "type" : "string"
        },
        "client-secret" : {
          "description" : "Client secret of the calendar application",
          "type" : "string"
        },
        "delay" : {
          "description" : "Milliseconds before the next poll.",
          "default" : "500",
          "type" : "integer"
        },
        "email-address" : {
          "description" : "The emailAddress of the Google Service Account.",
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "greedy" : {
          "description" : "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
          "default" : "false",
          "type" : "boolean"
        },
        "in-body" : {
          "description" : "Sets the name of a parameter to be passed in the exchange In Body",
          "type" : "string"
        },
        "initial-delay" : {
          "description" : "Milliseconds before the first poll starts.",
          "default" : "1000",
          "type" : "integer"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "p12-file-name" : {
          "description" : "The name of the p12 file which has the private key to use with the Google Service Account.",
          "type" : "string"
        },
        "poll-strategy" : {
          "description" : "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
          "type" : "string"
        },
        "refresh-token" : {
          "description" : "OAuth 2 refresh token. Using this, the Google Calendar component can obtain a new accessToken whenever the current one expires - a necessity if the application is long-lived.",
          "type" : "string"
        },
        "repeat-count" : {
          "description" : "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
          "default" : "0",
          "type" : "integer"
        },
        "run-logging-level" : {
          "description" : "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
          "default" : "TRACE",
          "enum" : [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ],
          "type" : "string"
        },
        "scheduled-executor-service" : {
          "description" : "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
          "type" : "string"
        },
        "scheduler" : {
          "description" : "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
          "default" : "none",
          "type" : "string"
        },
        "scheduler-properties" : {
          "description" : "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
          "type" : "string"
        },
        "scopes" : {
          "description" : "Specifies the level of permissions you want a calendar application to have to a user account. You can separate multiple scopes by comma. See https://developers.google.com/google-apps/calendar/auth for more info.",
          "default" : "https://www.googleapis.com/auth/calendar",
          "type" : "string"
        },
        "send-empty-message-when-idle" : {
          "description" : "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
          "default" : "false",
          "type" : "boolean"
        },
        "start-scheduler" : {
          "description" : "Whether the scheduler should be auto started.",
          "default" : "true",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "time-unit" : {
          "description" : "Time unit for initialDelay and delay options.",
          "default" : "MILLISECONDS",
          "enum" : [ "NANOSECONDS", "MICROSECONDS", "MILLISECONDS", "SECONDS", "MINUTES", "HOURS", "DAYS" ],
          "type" : "string"
        },
        "use-fixed-delay" : {
          "description" : "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
          "default" : "true",
          "type" : "boolean"
        },
        "user" : {
          "description" : "The email address of the user the application is trying to impersonate in the service account flow",
          "type" : "string"
        }
      }
    },
    "google-calendar-stream" : {
      "type" : "object",
      "required" : [ "index" ],
      "properties" : {
        "index" : {
          "description" : "Specifies an index for the endpoint",
          "type" : "string"
        },
        "access-token" : {
          "description" : "OAuth 2 access token. This typically expires after an hour so refreshToken is recommended for long term usage.",
          "type" : "string"
        },
        "application-name" : {
          "description" : "Google Calendar application name. Example would be camel-google-calendar/1.0",
          "type" : "string"
        },
        "backoff-error-threshold" : {
          "description" : "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-idle-threshold" : {
          "description" : "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-multiplier" : {
          "description" : "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
          "type" : "integer"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "calendar-id" : {
          "description" : "The calendarId to be used",
          "default" : "primary",
          "type" : "string"
        },
        "client-id" : {
          "description" : "Client ID of the calendar application",
          "type" : "string"
        },
        "client-secret" : {
          "description" : "Client secret of the calendar application",
          "type" : "string"
        },
        "consider-last-update" : {
          "description" : "Take into account the lastUpdate of the last event polled as start date for the next poll",
          "default" : "false",
          "type" : "boolean"
        },
        "consume-from-now" : {
          "description" : "Consume events in the selected calendar from now on",
          "default" : "true",
          "type" : "boolean"
        },
        "delay" : {
          "description" : "Milliseconds before the next poll.",
          "default" : "500",
          "type" : "integer"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "greedy" : {
          "description" : "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
          "default" : "false",
          "type" : "boolean"
        },
        "initial-delay" : {
          "description" : "Milliseconds before the first poll starts.",
          "default" : "1000",
          "type" : "integer"
        },
        "max-results" : {
          "description" : "Max results to be returned",
          "default" : "10",
          "type" : "integer"
        },
        "poll-strategy" : {
          "description" : "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
          "type" : "string"
        },
        "query" : {
          "description" : "The query to execute on calendar",
          "type" : "string"
        },
        "refresh-token" : {
          "description" : "OAuth 2 refresh token. Using this, the Google Calendar component can obtain a new accessToken whenever the current one expires - a necessity if the application is long-lived.",
          "type" : "string"
        },
        "repeat-count" : {
          "description" : "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
          "default" : "0",
          "type" : "integer"
        },
        "run-logging-level" : {
          "description" : "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
          "default" : "TRACE",
          "enum" : [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ],
          "type" : "string"
        },
        "scheduled-executor-service" : {
          "description" : "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
          "type" : "string"
        },
        "scheduler" : {
          "description" : "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
          "default" : "none",
          "type" : "string"
        },
        "scheduler-properties" : {
          "description" : "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
          "type" : "string"
        },
        "scopes" : {
          "description" : "Specifies the level of permissions you want a calendar application to have to a user account. See https://developers.google.com/calendar/auth for more info.",
          "type" : "string"
        },
        "send-empty-message-when-idle" : {
          "description" : "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
          "default" : "false",
          "type" : "boolean"
        },
        "start-scheduler" : {
          "description" : "Whether the scheduler should be auto started.",
          "default" : "true",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "time-unit" : {
          "description" : "Time unit for initialDelay and delay options.",
          "default" : "MILLISECONDS",
          "enum" : [ "NANOSECONDS", "MICROSECONDS", "MILLISECONDS", "SECONDS", "MINUTES", "HOURS", "DAYS" ],
          "type" : "string"
        },
        "use-fixed-delay" : {
          "description" : "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
          "default" : "true",
          "type" : "boolean"
        }
      }
    },
    "google-drive" : {
      "type" : "object",
      "required" : [ "apiName", "methodName" ],
      "properties" : {
        "api-name" : {
          "description" : "What kind of operation to perform",
          "enum" : [ "DRIVE_ABOUT", "DRIVE_APPS", "DRIVE_CHANGES", "DRIVE_CHANNELS", "DRIVE_CHILDREN", "DRIVE_COMMENTS", "DRIVE_FILES", "DRIVE_PARENTS", "DRIVE_PERMISSIONS", "DRIVE_PROPERTIES", "DRIVE_REALTIME", "DRIVE_REPLIES", "DRIVE_REVISIONS" ],
          "type" : "string"
        },
        "method-name" : {
          "description" : "What sub operation to use for the selected operation",
          "enum" : [ "copy", "delete", "get", "getIdForEmail", "insert", "list", "patch", "stop", "touch", "trash", "untrash", "update", "watch" ],
          "type" : "string"
        },
        "access-token" : {
          "description" : "OAuth 2 access token. This typically expires after an hour so refreshToken is recommended for long term usage.",
          "type" : "string"
        },
        "application-name" : {
          "description" : "Google drive application name. Example would be camel-google-drive/1.0",
          "type" : "string"
        },
        "backoff-error-threshold" : {
          "description" : "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-idle-threshold" : {
          "description" : "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-multiplier" : {
          "description" : "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
          "type" : "integer"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "client-factory" : {
          "description" : "To use the GoogleCalendarClientFactory as factory for creating the client. Will by default use BatchGoogleDriveClientFactory",
          "type" : "string"
        },
        "client-id" : {
          "description" : "Client ID of the drive application",
          "type" : "string"
        },
        "client-secret" : {
          "description" : "Client secret of the drive application",
          "type" : "string"
        },
        "delay" : {
          "description" : "Milliseconds before the next poll.",
          "default" : "500",
          "type" : "integer"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "greedy" : {
          "description" : "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
          "default" : "false",
          "type" : "boolean"
        },
        "in-body" : {
          "description" : "Sets the name of a parameter to be passed in the exchange In Body",
          "type" : "string"
        },
        "initial-delay" : {
          "description" : "Milliseconds before the first poll starts.",
          "default" : "1000",
          "type" : "integer"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "poll-strategy" : {
          "description" : "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
          "type" : "string"
        },
        "refresh-token" : {
          "description" : "OAuth 2 refresh token. Using this, the Google Calendar component can obtain a new accessToken whenever the current one expires - a necessity if the application is long-lived.",
          "type" : "string"
        },
        "repeat-count" : {
          "description" : "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
          "default" : "0",
          "type" : "integer"
        },
        "run-logging-level" : {
          "description" : "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
          "default" : "TRACE",
          "enum" : [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ],
          "type" : "string"
        },
        "scheduled-executor-service" : {
          "description" : "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
          "type" : "string"
        },
        "scheduler" : {
          "description" : "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
          "default" : "none",
          "type" : "string"
        },
        "scheduler-properties" : {
          "description" : "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
          "type" : "string"
        },
        "scopes" : {
          "description" : "Specifies the level of permissions you want a drive application to have to a user account. See https://developers.google.com/drive/web/scopes for more info.",
          "type" : "string"
        },
        "send-empty-message-when-idle" : {
          "description" : "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
          "default" : "false",
          "type" : "boolean"
        },
        "start-scheduler" : {
          "description" : "Whether the scheduler should be auto started.",
          "default" : "true",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "time-unit" : {
          "description" : "Time unit for initialDelay and delay options.",
          "default" : "MILLISECONDS",
          "enum" : [ "NANOSECONDS", "MICROSECONDS", "MILLISECONDS", "SECONDS", "MINUTES", "HOURS", "DAYS" ],
          "type" : "string"
        },
        "use-fixed-delay" : {
          "description" : "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
          "default" : "true",
          "type" : "boolean"
        }
      }
    },
    "google-mail" : {
      "type" : "object",
      "required" : [ "apiName", "methodName" ],
      "properties" : {
        "api-name" : {
          "description" : "What kind of operation to perform",
          "enum" : [ "THREADS", "MESSAGES", "ATTACHMENTS", "LABELS", "HISTORY", "DRAFTS", "USERS" ],
          "type" : "string"
        },
        "method-name" : {
          "description" : "What sub operation to use for the selected operation",
          "enum" : [ "attachments", "create", "delete", "get", "getProfile", "gmailImport", "insert", "list", "modify", "patch", "send", "stop", "trash", "untrash", "update", "watch" ],
          "type" : "string"
        },
        "access-token" : {
          "description" : "OAuth 2 access token. This typically expires after an hour so refreshToken is recommended for long term usage.",
          "type" : "string"
        },
        "application-name" : {
          "description" : "Google mail application name. Example would be camel-google-mail/1.0",
          "type" : "string"
        },
        "backoff-error-threshold" : {
          "description" : "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-idle-threshold" : {
          "description" : "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-multiplier" : {
          "description" : "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
          "type" : "integer"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "client-id" : {
          "description" : "Client ID of the mail application",
          "type" : "string"
        },
        "client-secret" : {
          "description" : "Client secret of the mail application",
          "type" : "string"
        },
        "delay" : {
          "description" : "Milliseconds before the next poll.",
          "default" : "500",
          "type" : "integer"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "greedy" : {
          "description" : "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
          "default" : "false",
          "type" : "boolean"
        },
        "in-body" : {
          "description" : "Sets the name of a parameter to be passed in the exchange In Body",
          "type" : "string"
        },
        "initial-delay" : {
          "description" : "Milliseconds before the first poll starts.",
          "default" : "1000",
          "type" : "integer"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "poll-strategy" : {
          "description" : "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
          "type" : "string"
        },
        "refresh-token" : {
          "description" : "OAuth 2 refresh token. Using this, the Google Calendar component can obtain a new accessToken whenever the current one expires - a necessity if the application is long-lived.",
          "type" : "string"
        },
        "repeat-count" : {
          "description" : "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
          "default" : "0",
          "type" : "integer"
        },
        "run-logging-level" : {
          "description" : "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
          "default" : "TRACE",
          "enum" : [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ],
          "type" : "string"
        },
        "scheduled-executor-service" : {
          "description" : "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
          "type" : "string"
        },
        "scheduler" : {
          "description" : "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
          "default" : "none",
          "type" : "string"
        },
        "scheduler-properties" : {
          "description" : "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
          "type" : "string"
        },
        "send-empty-message-when-idle" : {
          "description" : "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
          "default" : "false",
          "type" : "boolean"
        },
        "start-scheduler" : {
          "description" : "Whether the scheduler should be auto started.",
          "default" : "true",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "time-unit" : {
          "description" : "Time unit for initialDelay and delay options.",
          "default" : "MILLISECONDS",
          "enum" : [ "NANOSECONDS", "MICROSECONDS", "MILLISECONDS", "SECONDS", "MINUTES", "HOURS", "DAYS" ],
          "type" : "string"
        },
        "use-fixed-delay" : {
          "description" : "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
          "default" : "true",
          "type" : "boolean"
        }
      }
    },
    "google-mail-stream" : {
      "type" : "object",
      "required" : [ "index" ],
      "properties" : {
        "index" : {
          "description" : "Currently not in use",
          "type" : "string"
        },
        "access-token" : {
          "description" : "OAuth 2 access token. This typically expires after an hour so refreshToken is recommended for long term usage.",
          "type" : "string"
        },
        "application-name" : {
          "description" : "Google mail application name. Example would be camel-google-mail/1.0",
          "type" : "string"
        },
        "backoff-error-threshold" : {
          "description" : "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-idle-threshold" : {
          "description" : "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-multiplier" : {
          "description" : "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
          "type" : "integer"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "client-id" : {
          "description" : "Client ID of the mail application",
          "type" : "string"
        },
        "client-secret" : {
          "description" : "Client secret of the mail application",
          "type" : "string"
        },
        "delay" : {
          "description" : "Milliseconds before the next poll.",
          "default" : "500",
          "type" : "integer"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "greedy" : {
          "description" : "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
          "default" : "false",
          "type" : "boolean"
        },
        "initial-delay" : {
          "description" : "Milliseconds before the first poll starts.",
          "default" : "1000",
          "type" : "integer"
        },
        "labels" : {
          "description" : "Comma separated list of labels to take into account",
          "type" : "string"
        },
        "mark-as-read" : {
          "description" : "Mark the message as read once it has been consumed",
          "default" : "false",
          "type" : "boolean"
        },
        "max-results" : {
          "description" : "Max results to be returned",
          "default" : "10",
          "type" : "integer"
        },
        "poll-strategy" : {
          "description" : "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
          "type" : "string"
        },
        "query" : {
          "description" : "The query to execute on gmail box",
          "default" : "is:unread",
          "type" : "string"
        },
        "refresh-token" : {
          "description" : "OAuth 2 refresh token. Using this, the Google Calendar component can obtain a new accessToken whenever the current one expires - a necessity if the application is long-lived.",
          "type" : "string"
        },
        "repeat-count" : {
          "description" : "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
          "default" : "0",
          "type" : "integer"
        },
        "run-logging-level" : {
          "description" : "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
          "default" : "TRACE",
          "enum" : [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ],
          "type" : "string"
        },
        "scheduled-executor-service" : {
          "description" : "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
          "type" : "string"
        },
        "scheduler" : {
          "description" : "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
          "default" : "none",
          "type" : "string"
        },
        "scheduler-properties" : {
          "description" : "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
          "type" : "string"
        },
        "send-empty-message-when-idle" : {
          "description" : "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
          "default" : "false",
          "type" : "boolean"
        },
        "start-scheduler" : {
          "description" : "Whether the scheduler should be auto started.",
          "default" : "true",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "time-unit" : {
          "description" : "Time unit for initialDelay and delay options.",
          "default" : "MILLISECONDS",
          "enum" : [ "NANOSECONDS", "MICROSECONDS", "MILLISECONDS", "SECONDS", "MINUTES", "HOURS", "DAYS" ],
          "type" : "string"
        },
        "use-fixed-delay" : {
          "description" : "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
          "default" : "true",
          "type" : "boolean"
        }
      }
    },
    "google-pubsub" : {
      "type" : "object",
      "required" : [ "destinationName", "projectId" ],
      "properties" : {
        "destination-name" : {
          "description" : "Destination Name",
          "type" : "string"
        },
        "project-id" : {
          "description" : "Project Id",
          "type" : "string"
        },
        "ack-mode" : {
          "description" : "AUTO = exchange gets ack'ed/nack'ed on completion. NONE = downstream process has to ack/nack explicitly",
          "default" : "AUTO",
          "enum" : [ "AUTO", "NONE" ],
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "concurrent-consumers" : {
          "description" : "The number of parallel streams consuming from the subscription",
          "default" : "1",
          "type" : "integer"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "logger-id" : {
          "description" : "Logger ID to use when a match to the parent route required",
          "type" : "string"
        },
        "max-messages-per-poll" : {
          "description" : "The max number of messages to receive from the server in a single API call",
          "default" : "1",
          "type" : "integer"
        },
        "serializer" : {
          "description" : "A custom GooglePubsubSerializer to use for serializing message payloads in the producer",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "synchronous-pull" : {
          "description" : "Synchronously pull batches of messages",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "google-sheets" : {
      "type" : "object",
      "required" : [ "apiName", "methodName" ],
      "properties" : {
        "api-name" : {
          "description" : "What kind of operation to perform",
          "enum" : [ "SPREADSHEETS", "DATA" ],
          "type" : "string"
        },
        "method-name" : {
          "description" : "What sub operation to use for the selected operation",
          "enum" : [ "create", "get", "update", "append", "batchUpdate", "clear" ],
          "type" : "string"
        },
        "access-token" : {
          "description" : "OAuth 2 access token. This typically expires after an hour so refreshToken is recommended for long term usage.",
          "type" : "string"
        },
        "application-name" : {
          "description" : "Google Sheets application name. Example would be camel-google-sheets/1.0",
          "type" : "string"
        },
        "backoff-error-threshold" : {
          "description" : "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-idle-threshold" : {
          "description" : "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-multiplier" : {
          "description" : "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
          "type" : "integer"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "client-id" : {
          "description" : "Client ID of the sheets application",
          "type" : "string"
        },
        "client-secret" : {
          "description" : "Client secret of the sheets application",
          "type" : "string"
        },
        "delay" : {
          "description" : "Milliseconds before the next poll.",
          "default" : "500",
          "type" : "integer"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "greedy" : {
          "description" : "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
          "default" : "false",
          "type" : "boolean"
        },
        "in-body" : {
          "description" : "Sets the name of a parameter to be passed in the exchange In Body",
          "type" : "string"
        },
        "initial-delay" : {
          "description" : "Milliseconds before the first poll starts.",
          "default" : "1000",
          "type" : "integer"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "poll-strategy" : {
          "description" : "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
          "type" : "string"
        },
        "refresh-token" : {
          "description" : "OAuth 2 refresh token. Using this, the Google Sheets component can obtain a new accessToken whenever the current one expires - a necessity if the application is long-lived.",
          "type" : "string"
        },
        "repeat-count" : {
          "description" : "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
          "default" : "0",
          "type" : "integer"
        },
        "run-logging-level" : {
          "description" : "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
          "default" : "TRACE",
          "enum" : [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ],
          "type" : "string"
        },
        "scheduled-executor-service" : {
          "description" : "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
          "type" : "string"
        },
        "scheduler" : {
          "description" : "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
          "default" : "none",
          "type" : "string"
        },
        "scheduler-properties" : {
          "description" : "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
          "type" : "string"
        },
        "send-empty-message-when-idle" : {
          "description" : "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
          "default" : "false",
          "type" : "boolean"
        },
        "split-result" : {
          "description" : "When consumer return an array or collection this will generate one exchange per element, and their routes will be executed once for each exchange. Set this value to false to use a single exchange for the entire list or array.",
          "default" : "true",
          "type" : "boolean"
        },
        "start-scheduler" : {
          "description" : "Whether the scheduler should be auto started.",
          "default" : "true",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "time-unit" : {
          "description" : "Time unit for initialDelay and delay options.",
          "default" : "MILLISECONDS",
          "enum" : [ "NANOSECONDS", "MICROSECONDS", "MILLISECONDS", "SECONDS", "MINUTES", "HOURS", "DAYS" ],
          "type" : "string"
        },
        "use-fixed-delay" : {
          "description" : "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
          "default" : "true",
          "type" : "boolean"
        }
      }
    },
    "google-sheets-stream" : {
      "type" : "object",
      "required" : [ "apiName" ],
      "properties" : {
        "api-name" : {
          "description" : "Sets the apiName.",
          "type" : "string"
        },
        "access-token" : {
          "description" : "OAuth 2 access token. This typically expires after an hour so refreshToken is recommended for long term usage.",
          "type" : "string"
        },
        "application-name" : {
          "description" : "Google sheets application name. Example would be camel-google-sheets/1.0",
          "type" : "string"
        },
        "backoff-error-threshold" : {
          "description" : "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-idle-threshold" : {
          "description" : "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-multiplier" : {
          "description" : "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
          "type" : "integer"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "client-id" : {
          "description" : "Client ID of the sheets application",
          "type" : "string"
        },
        "client-secret" : {
          "description" : "Client secret of the sheets application",
          "type" : "string"
        },
        "delay" : {
          "description" : "Milliseconds before the next poll.",
          "default" : "500",
          "type" : "integer"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "greedy" : {
          "description" : "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
          "default" : "false",
          "type" : "boolean"
        },
        "include-grid-data" : {
          "description" : "True if grid data should be returned.",
          "default" : "false",
          "type" : "boolean"
        },
        "initial-delay" : {
          "description" : "Milliseconds before the first poll starts.",
          "default" : "1000",
          "type" : "integer"
        },
        "major-dimension" : {
          "description" : "Specifies the major dimension that results should use..",
          "default" : "ROWS",
          "enum" : [ "ROWS", "COLUMNS", "DIMENSION_UNSPECIFIED" ],
          "type" : "string"
        },
        "max-results" : {
          "description" : "Specify the maximum number of returned results. This will limit the number of rows in a returned value range data set or the number of returned value ranges in a batch request.",
          "type" : "integer"
        },
        "poll-strategy" : {
          "description" : "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
          "type" : "string"
        },
        "range" : {
          "description" : "Specifies the range of rows and columns in a sheet to get data from.",
          "type" : "string"
        },
        "refresh-token" : {
          "description" : "OAuth 2 refresh token. Using this, the Google Calendar component can obtain a new accessToken whenever the current one expires - a necessity if the application is long-lived.",
          "type" : "string"
        },
        "repeat-count" : {
          "description" : "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
          "default" : "0",
          "type" : "integer"
        },
        "run-logging-level" : {
          "description" : "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
          "default" : "TRACE",
          "enum" : [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ],
          "type" : "string"
        },
        "scheduled-executor-service" : {
          "description" : "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
          "type" : "string"
        },
        "scheduler" : {
          "description" : "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
          "default" : "none",
          "type" : "string"
        },
        "scheduler-properties" : {
          "description" : "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
          "type" : "string"
        },
        "scopes" : {
          "description" : "Specifies the level of permissions you want a sheets application to have to a user account. See https://developers.google.com/identity/protocols/googlescopes for more info.",
          "type" : "string"
        },
        "send-empty-message-when-idle" : {
          "description" : "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
          "default" : "false",
          "type" : "boolean"
        },
        "split-results" : {
          "description" : "True if value range result should be split into rows or columns to process each of them individually. When true each row or column is represented with a separate exchange in batch processing. Otherwise value range object is used as exchange junk size.",
          "default" : "false",
          "type" : "boolean"
        },
        "spreadsheet-id" : {
          "description" : "Specifies the spreadsheet identifier that is used to identify the target to obtain.",
          "type" : "string"
        },
        "start-scheduler" : {
          "description" : "Whether the scheduler should be auto started.",
          "default" : "true",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "time-unit" : {
          "description" : "Time unit for initialDelay and delay options.",
          "default" : "MILLISECONDS",
          "enum" : [ "NANOSECONDS", "MICROSECONDS", "MILLISECONDS", "SECONDS", "MINUTES", "HOURS", "DAYS" ],
          "type" : "string"
        },
        "use-fixed-delay" : {
          "description" : "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
          "default" : "true",
          "type" : "boolean"
        },
        "value-render-option" : {
          "description" : "Determines how values should be rendered in the output.",
          "default" : "FORMATTED_VALUE",
          "enum" : [ "FORMATTED_VALUE", "UNFORMATTED_VALUE", "FORMULA" ],
          "type" : "string"
        }
      }
    },
    "gora" : {
      "type" : "object",
      "required" : [ "name" ],
      "properties" : {
        "name" : {
          "description" : "Instance name",
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "concurrent-consumers" : {
          "description" : "Number of concurrent consumers",
          "default" : "1",
          "type" : "integer"
        },
        "data-store-class" : {
          "description" : "The type of the dataStore",
          "type" : "string"
        },
        "end-key" : {
          "description" : "The End Key",
          "type" : "string"
        },
        "end-time" : {
          "description" : "The End Time",
          "type" : "integer"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "fields" : {
          "description" : "The Fields",
          "type" : "string"
        },
        "flush-on-every-operation" : {
          "description" : "Flush on every operation",
          "default" : "true",
          "type" : "boolean"
        },
        "hadoop-configuration" : {
          "description" : "Hadoop Configuration",
          "type" : "string"
        },
        "key-class" : {
          "description" : "The type class of the key",
          "type" : "string"
        },
        "key-range-from" : {
          "description" : "The Key Range From",
          "type" : "string"
        },
        "key-range-to" : {
          "description" : "The Key Range To",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "limit" : {
          "description" : "The Limit",
          "type" : "integer"
        },
        "start-key" : {
          "description" : "The Start Key",
          "type" : "string"
        },
        "start-time" : {
          "description" : "The Start Time",
          "type" : "integer"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "time-range-from" : {
          "description" : "The Time Range From",
          "type" : "integer"
        },
        "time-range-to" : {
          "description" : "The Time Range To",
          "type" : "integer"
        },
        "timestamp" : {
          "description" : "The Timestamp",
          "type" : "integer"
        },
        "value-class" : {
          "description" : "The type of the value",
          "type" : "string"
        }
      }
    },
    "grape" : {
      "type" : "object",
      "required" : [ "defaultCoordinates" ],
      "properties" : {
        "default-coordinates" : {
          "description" : "Maven coordinates to use as default to grab if the message body is empty.",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "graphql" : {
      "type" : "object",
      "required" : [ "httpUri" ],
      "properties" : {
        "http-uri" : {
          "description" : "The GraphQL server URI.",
          "type" : "string"
        },
        "access-token" : {
          "description" : "The access token sent in the Authorization header.",
          "type" : "string"
        },
        "jwt-authorization-type" : {
          "description" : "The JWT Authorization type. Default is Bearer.",
          "default" : "Bearer",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "operation-name" : {
          "description" : "The query or mutation name.",
          "type" : "string"
        },
        "password" : {
          "description" : "The password for Basic authentication.",
          "type" : "string"
        },
        "proxy-host" : {
          "description" : "The proxy host in the format hostname:port.",
          "type" : "string"
        },
        "query" : {
          "description" : "The query text.",
          "type" : "string"
        },
        "query-file" : {
          "description" : "The query file name located in the classpath.",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "username" : {
          "description" : "The username for Basic authentication.",
          "type" : "string"
        },
        "variables" : {
          "description" : "The JsonObject instance containing the operation variables.",
          "type" : "string"
        }
      }
    },
    "grpc" : {
      "type" : "object",
      "required" : [ "host", "port", "service" ],
      "properties" : {
        "host" : {
          "description" : "The gRPC server host name. This is localhost or 0.0.0.0 when being a consumer or remote server host name when using producer.",
          "type" : "string"
        },
        "port" : {
          "description" : "The gRPC local or remote server port",
          "type" : "integer"
        },
        "service" : {
          "description" : "Fully qualified service name from the protocol buffer descriptor file (package dot service definition name)",
          "type" : "string"
        },
        "authentication-type" : {
          "description" : "Authentication method type in advance to the SSL/TLS negotiation",
          "default" : "NONE",
          "enum" : [ "NONE", "GOOGLE", "JWT" ],
          "type" : "string"
        },
        "auto-discover-client-interceptors" : {
          "description" : "Setting the autoDiscoverClientInterceptors mechanism, if true, the component will look for a ClientInterceptor instance in the registry automatically otherwise it will skip that checking.",
          "default" : "true",
          "type" : "boolean"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "consumer-strategy" : {
          "description" : "This option specifies the top-level strategy for processing service requests and responses in streaming mode. If an aggregation strategy is selected, all requests will be accumulated in the list, then transferred to the flow, and the accumulated responses will be sent to the sender. If a propagation strategy is selected, request is sent to the stream, and the response will be immediately sent back to the sender.",
          "default" : "PROPAGATION",
          "enum" : [ "AGGREGATION", "PROPAGATION" ],
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "flow-control-window" : {
          "description" : "The HTTP/2 flow control window size (MiB)",
          "default" : "1048576",
          "type" : "integer"
        },
        "forward-on-completed" : {
          "description" : "Determines if onCompleted events should be pushed to the Camel route.",
          "default" : "false",
          "type" : "boolean"
        },
        "forward-on-error" : {
          "description" : "Determines if onError events should be pushed to the Camel route. Exceptions will be set as message body.",
          "default" : "false",
          "type" : "boolean"
        },
        "jwt-algorithm" : {
          "description" : "JSON Web Token sign algorithm",
          "default" : "HMAC256",
          "enum" : [ "HMAC256", "HMAC384", "HMAC512" ],
          "type" : "string"
        },
        "jwt-issuer" : {
          "description" : "JSON Web Token issuer",
          "type" : "string"
        },
        "jwt-secret" : {
          "description" : "JSON Web Token secret",
          "type" : "string"
        },
        "jwt-subject" : {
          "description" : "JSON Web Token subject",
          "type" : "string"
        },
        "key-cert-chain-resource" : {
          "description" : "The X.509 certificate chain file resource in PEM format link",
          "type" : "string"
        },
        "key-password" : {
          "description" : "The PKCS#8 private key file password",
          "type" : "string"
        },
        "key-resource" : {
          "description" : "The PKCS#8 private key file resource in PEM format link",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "max-concurrent-calls-per-connection" : {
          "description" : "The maximum number of concurrent calls permitted for each incoming server connection",
          "default" : "2147483647",
          "type" : "integer"
        },
        "max-message-size" : {
          "description" : "The maximum message size allowed to be received/sent (MiB)",
          "default" : "4194304",
          "type" : "integer"
        },
        "method" : {
          "description" : "gRPC method name",
          "type" : "string"
        },
        "negotiation-type" : {
          "description" : "Identifies the security negotiation type used for HTTP/2 communication",
          "default" : "PLAINTEXT",
          "enum" : [ "TLS", "PLAINTEXT_UPGRADE", "PLAINTEXT" ],
          "type" : "string"
        },
        "producer-strategy" : {
          "description" : "The mode used to communicate with a remote gRPC server. In SIMPLE mode a single exchange is translated into a remote procedure call. In STREAMING mode all exchanges will be sent within the same request (input and output of the recipient gRPC service must be of type 'stream').",
          "default" : "SIMPLE",
          "enum" : [ "SIMPLE", "STREAMING" ],
          "type" : "string"
        },
        "route-controlled-stream-observer" : {
          "description" : "Lets the route to take control over stream observer. If this value is set to true, then the response observer of gRPC call will be set with the name GrpcConstants.GRPC_RESPONSE_OBSERVER in the Exchange object. Please note that the stream observer's onNext(), onError(), onCompleted() methods should be called in the route.",
          "default" : "false",
          "type" : "boolean"
        },
        "service-account-resource" : {
          "description" : "Service Account key file in JSON format resource link supported by the Google Cloud SDK",
          "type" : "string"
        },
        "stream-replies-to" : {
          "description" : "When using STREAMING client mode, it indicates the endpoint where responses should be forwarded.",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "trust-cert-collection-resource" : {
          "description" : "The trusted certificates collection file resource in PEM format for verifying the remote endpoint's certificate",
          "type" : "string"
        },
        "user-agent" : {
          "description" : "The user agent header passed to the server",
          "type" : "string"
        }
      }
    },
    "guava-eventbus" : {
      "type" : "object",
      "properties" : {
        "event-bus-ref" : {
          "description" : "To lookup the Guava EventBus from the registry with the given name",
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "event-class" : {
          "description" : "If used on the consumer side of the route, will filter events received from the EventBus to the instances of the class and superclasses of eventClass. Null value of this option is equal to setting it to the java.lang.Object i.e. the consumer will capture all messages incoming to the event bus. This option cannot be used together with listenerInterface option.",
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "listener-interface" : {
          "description" : "The interface with method(s) marked with the Subscribe annotation. Dynamic proxy will be created over the interface so it could be registered as the EventBus listener. Particularly useful when creating multi-event listeners and for handling DeadEvent properly. This option cannot be used together with eventClass option.",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "hazelcast-atomicvalue" : {
      "type" : "object",
      "required" : [ "cacheName" ],
      "properties" : {
        "cache-name" : {
          "description" : "The name of the cache",
          "type" : "string"
        },
        "default-operation" : {
          "description" : "To specify a default operation to use, if no operation header has been provided.",
          "enum" : [ "put", "delete", "get", "update", "query", "getAll", "clear", "putIfAbsent", "allAll", "removeAll", "retainAll", "evict", "evictAll", "valueCount", "containsKey", "containsValue", "keySet", "removevalue", "increment", "decrement", "setvalue", "destroy", "compareAndSet", "getAndAdd", "add", "offer", "peek", "poll", "remainingCapacity", "drainTo", "removeIf", "take", "publish", "readOnceHeal", "readOnceTail", "capacity" ],
          "type" : "string"
        },
        "hazelcast-instance" : {
          "description" : "The hazelcast instance reference which can be used for hazelcast endpoint.",
          "type" : "string"
        },
        "hazelcast-instance-name" : {
          "description" : "The hazelcast instance reference name which can be used for hazelcast endpoint. If you don't specify the instance reference, camel use the default hazelcast instance from the camel-hazelcast instance.",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "hazelcast-instance" : {
      "type" : "object",
      "required" : [ "cacheName" ],
      "properties" : {
        "cache-name" : {
          "description" : "The name of the cache",
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "default-operation" : {
          "description" : "To specify a default operation to use, if no operation header has been provided.",
          "enum" : [ "put", "delete", "get", "update", "query", "getAll", "clear", "putIfAbsent", "allAll", "removeAll", "retainAll", "evict", "evictAll", "valueCount", "containsKey", "containsValue", "keySet", "removevalue", "increment", "decrement", "setvalue", "destroy", "compareAndSet", "getAndAdd", "add", "offer", "peek", "poll", "remainingCapacity", "drainTo", "removeIf", "take", "publish", "readOnceHeal", "readOnceTail", "capacity" ],
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "hazelcast-instance" : {
          "description" : "The hazelcast instance reference which can be used for hazelcast endpoint.",
          "type" : "string"
        },
        "hazelcast-instance-name" : {
          "description" : "The hazelcast instance reference name which can be used for hazelcast endpoint. If you don't specify the instance reference, camel use the default hazelcast instance from the camel-hazelcast instance.",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "hazelcast-list" : {
      "type" : "object",
      "required" : [ "cacheName" ],
      "properties" : {
        "cache-name" : {
          "description" : "The name of the cache",
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "default-operation" : {
          "description" : "To specify a default operation to use, if no operation header has been provided.",
          "enum" : [ "put", "delete", "get", "update", "query", "getAll", "clear", "putIfAbsent", "allAll", "removeAll", "retainAll", "evict", "evictAll", "valueCount", "containsKey", "containsValue", "keySet", "removevalue", "increment", "decrement", "setvalue", "destroy", "compareAndSet", "getAndAdd", "add", "offer", "peek", "poll", "remainingCapacity", "drainTo", "removeIf", "take", "publish", "readOnceHeal", "readOnceTail", "capacity" ],
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "hazelcast-instance" : {
          "description" : "The hazelcast instance reference which can be used for hazelcast endpoint.",
          "type" : "string"
        },
        "hazelcast-instance-name" : {
          "description" : "The hazelcast instance reference name which can be used for hazelcast endpoint. If you don't specify the instance reference, camel use the default hazelcast instance from the camel-hazelcast instance.",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "hazelcast-map" : {
      "type" : "object",
      "required" : [ "cacheName" ],
      "properties" : {
        "cache-name" : {
          "description" : "The name of the cache",
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "default-operation" : {
          "description" : "To specify a default operation to use, if no operation header has been provided.",
          "enum" : [ "put", "delete", "get", "update", "query", "getAll", "clear", "putIfAbsent", "allAll", "removeAll", "retainAll", "evict", "evictAll", "valueCount", "containsKey", "containsValue", "keySet", "removevalue", "increment", "decrement", "setvalue", "destroy", "compareAndSet", "getAndAdd", "add", "offer", "peek", "poll", "remainingCapacity", "drainTo", "removeIf", "take", "publish", "readOnceHeal", "readOnceTail", "capacity" ],
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "hazelcast-instance" : {
          "description" : "The hazelcast instance reference which can be used for hazelcast endpoint.",
          "type" : "string"
        },
        "hazelcast-instance-name" : {
          "description" : "The hazelcast instance reference name which can be used for hazelcast endpoint. If you don't specify the instance reference, camel use the default hazelcast instance from the camel-hazelcast instance.",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "hazelcast-multimap" : {
      "type" : "object",
      "required" : [ "cacheName" ],
      "properties" : {
        "cache-name" : {
          "description" : "The name of the cache",
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "default-operation" : {
          "description" : "To specify a default operation to use, if no operation header has been provided.",
          "enum" : [ "put", "delete", "get", "update", "query", "getAll", "clear", "putIfAbsent", "allAll", "removeAll", "retainAll", "evict", "evictAll", "valueCount", "containsKey", "containsValue", "keySet", "removevalue", "increment", "decrement", "setvalue", "destroy", "compareAndSet", "getAndAdd", "add", "offer", "peek", "poll", "remainingCapacity", "drainTo", "removeIf", "take", "publish", "readOnceHeal", "readOnceTail", "capacity" ],
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "hazelcast-instance" : {
          "description" : "The hazelcast instance reference which can be used for hazelcast endpoint.",
          "type" : "string"
        },
        "hazelcast-instance-name" : {
          "description" : "The hazelcast instance reference name which can be used for hazelcast endpoint. If you don't specify the instance reference, camel use the default hazelcast instance from the camel-hazelcast instance.",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "hazelcast-queue" : {
      "type" : "object",
      "required" : [ "cacheName" ],
      "properties" : {
        "cache-name" : {
          "description" : "The name of the cache",
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "default-operation" : {
          "description" : "To specify a default operation to use, if no operation header has been provided.",
          "enum" : [ "put", "delete", "get", "update", "query", "getAll", "clear", "putIfAbsent", "allAll", "removeAll", "retainAll", "evict", "evictAll", "valueCount", "containsKey", "containsValue", "keySet", "removevalue", "increment", "decrement", "setvalue", "destroy", "compareAndSet", "getAndAdd", "add", "offer", "peek", "poll", "remainingCapacity", "drainTo", "removeIf", "take", "publish", "readOnceHeal", "readOnceTail", "capacity" ],
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "hazelcast-instance" : {
          "description" : "The hazelcast instance reference which can be used for hazelcast endpoint.",
          "type" : "string"
        },
        "hazelcast-instance-name" : {
          "description" : "The hazelcast instance reference name which can be used for hazelcast endpoint. If you don't specify the instance reference, camel use the default hazelcast instance from the camel-hazelcast instance.",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "polling-timeout" : {
          "description" : "Define the polling timeout of the Queue consumer in Poll mode",
          "default" : "10000",
          "type" : "integer"
        },
        "pool-size" : {
          "description" : "Define the Pool size for Queue Consumer Executor",
          "default" : "1",
          "type" : "integer"
        },
        "queue-consumer-mode" : {
          "description" : "Define the Queue Consumer mode: Listen or Poll",
          "default" : "Listen",
          "enum" : [ "listen", "poll" ],
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "hazelcast-replicatedmap" : {
      "type" : "object",
      "required" : [ "cacheName" ],
      "properties" : {
        "cache-name" : {
          "description" : "The name of the cache",
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "default-operation" : {
          "description" : "To specify a default operation to use, if no operation header has been provided.",
          "enum" : [ "put", "delete", "get", "update", "query", "getAll", "clear", "putIfAbsent", "allAll", "removeAll", "retainAll", "evict", "evictAll", "valueCount", "containsKey", "containsValue", "keySet", "removevalue", "increment", "decrement", "setvalue", "destroy", "compareAndSet", "getAndAdd", "add", "offer", "peek", "poll", "remainingCapacity", "drainTo", "removeIf", "take", "publish", "readOnceHeal", "readOnceTail", "capacity" ],
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "hazelcast-instance" : {
          "description" : "The hazelcast instance reference which can be used for hazelcast endpoint.",
          "type" : "string"
        },
        "hazelcast-instance-name" : {
          "description" : "The hazelcast instance reference name which can be used for hazelcast endpoint. If you don't specify the instance reference, camel use the default hazelcast instance from the camel-hazelcast instance.",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "hazelcast-ringbuffer" : {
      "type" : "object",
      "required" : [ "cacheName" ],
      "properties" : {
        "cache-name" : {
          "description" : "The name of the cache",
          "type" : "string"
        },
        "default-operation" : {
          "description" : "To specify a default operation to use, if no operation header has been provided.",
          "enum" : [ "put", "delete", "get", "update", "query", "getAll", "clear", "putIfAbsent", "allAll", "removeAll", "retainAll", "evict", "evictAll", "valueCount", "containsKey", "containsValue", "keySet", "removevalue", "increment", "decrement", "setvalue", "destroy", "compareAndSet", "getAndAdd", "add", "offer", "peek", "poll", "remainingCapacity", "drainTo", "removeIf", "take", "publish", "readOnceHeal", "readOnceTail", "capacity" ],
          "type" : "string"
        },
        "hazelcast-instance" : {
          "description" : "The hazelcast instance reference which can be used for hazelcast endpoint.",
          "type" : "string"
        },
        "hazelcast-instance-name" : {
          "description" : "The hazelcast instance reference name which can be used for hazelcast endpoint. If you don't specify the instance reference, camel use the default hazelcast instance from the camel-hazelcast instance.",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "hazelcast-seda" : {
      "type" : "object",
      "required" : [ "cacheName" ],
      "properties" : {
        "cache-name" : {
          "description" : "The name of the cache",
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "concurrent-consumers" : {
          "description" : "To use concurrent consumers polling from the SEDA queue.",
          "default" : "1",
          "type" : "integer"
        },
        "default-operation" : {
          "description" : "To specify a default operation to use, if no operation header has been provided.",
          "enum" : [ "put", "delete", "get", "update", "query", "getAll", "clear", "putIfAbsent", "allAll", "removeAll", "retainAll", "evict", "evictAll", "valueCount", "containsKey", "containsValue", "keySet", "removevalue", "increment", "decrement", "setvalue", "destroy", "compareAndSet", "getAndAdd", "add", "offer", "peek", "poll", "remainingCapacity", "drainTo", "removeIf", "take", "publish", "readOnceHeal", "readOnceTail", "capacity" ],
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "hazelcast-instance" : {
          "description" : "The hazelcast instance reference which can be used for hazelcast endpoint.",
          "type" : "string"
        },
        "hazelcast-instance-name" : {
          "description" : "The hazelcast instance reference name which can be used for hazelcast endpoint. If you don't specify the instance reference, camel use the default hazelcast instance from the camel-hazelcast instance.",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "on-error-delay" : {
          "description" : "Milliseconds before consumer continues polling after an error has occurred.",
          "default" : "1000",
          "type" : "integer"
        },
        "poll-timeout" : {
          "description" : "The timeout used when consuming from the SEDA queue. When a timeout occurs, the consumer can check whether it is allowed to continue running. Setting a lower value allows the consumer to react more quickly upon shutdown.",
          "default" : "1000",
          "type" : "integer"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "transacted" : {
          "description" : "If set to true then the consumer runs in transaction mode, where the messages in the seda queue will only be removed if the transaction commits, which happens when the processing is complete.",
          "default" : "false",
          "type" : "boolean"
        },
        "transfer-exchange" : {
          "description" : "If set to true the whole Exchange will be transfered. If header or body contains not serializable objects, they will be skipped.",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "hazelcast-set" : {
      "type" : "object",
      "required" : [ "cacheName" ],
      "properties" : {
        "cache-name" : {
          "description" : "The name of the cache",
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "default-operation" : {
          "description" : "To specify a default operation to use, if no operation header has been provided.",
          "enum" : [ "put", "delete", "get", "update", "query", "getAll", "clear", "putIfAbsent", "allAll", "removeAll", "retainAll", "evict", "evictAll", "valueCount", "containsKey", "containsValue", "keySet", "removevalue", "increment", "decrement", "setvalue", "destroy", "compareAndSet", "getAndAdd", "add", "offer", "peek", "poll", "remainingCapacity", "drainTo", "removeIf", "take", "publish", "readOnceHeal", "readOnceTail", "capacity" ],
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "hazelcast-instance" : {
          "description" : "The hazelcast instance reference which can be used for hazelcast endpoint.",
          "type" : "string"
        },
        "hazelcast-instance-name" : {
          "description" : "The hazelcast instance reference name which can be used for hazelcast endpoint. If you don't specify the instance reference, camel use the default hazelcast instance from the camel-hazelcast instance.",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "hazelcast-topic" : {
      "type" : "object",
      "required" : [ "cacheName" ],
      "properties" : {
        "cache-name" : {
          "description" : "The name of the cache",
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "default-operation" : {
          "description" : "To specify a default operation to use, if no operation header has been provided.",
          "enum" : [ "put", "delete", "get", "update", "query", "getAll", "clear", "putIfAbsent", "allAll", "removeAll", "retainAll", "evict", "evictAll", "valueCount", "containsKey", "containsValue", "keySet", "removevalue", "increment", "decrement", "setvalue", "destroy", "compareAndSet", "getAndAdd", "add", "offer", "peek", "poll", "remainingCapacity", "drainTo", "removeIf", "take", "publish", "readOnceHeal", "readOnceTail", "capacity" ],
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "hazelcast-instance" : {
          "description" : "The hazelcast instance reference which can be used for hazelcast endpoint.",
          "type" : "string"
        },
        "hazelcast-instance-name" : {
          "description" : "The hazelcast instance reference name which can be used for hazelcast endpoint. If you don't specify the instance reference, camel use the default hazelcast instance from the camel-hazelcast instance.",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "reliable" : {
          "description" : "Define if the endpoint will use a reliable Topic struct or not.",
          "default" : "false",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "hbase" : {
      "type" : "object",
      "required" : [ "tableName" ],
      "properties" : {
        "table-name" : {
          "description" : "The name of the table",
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "cell-mapping-strategy-factory" : {
          "description" : "To use a custom CellMappingStrategyFactory that is responsible for mapping cells.",
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "filters" : {
          "description" : "A list of filters to use.",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "mapping-strategy-class-name" : {
          "description" : "The class name of a custom mapping strategy implementation.",
          "type" : "string"
        },
        "mapping-strategy-name" : {
          "description" : "The strategy to use for mapping Camel messages to HBase columns. Supported values: header, or body.",
          "enum" : [ "header", "body" ],
          "type" : "string"
        },
        "max-messages-per-poll" : {
          "description" : "Gets the maximum number of messages as a limit to poll at each polling. Is default unlimited, but use 0 or negative number to disable it as unlimited.",
          "type" : "integer"
        },
        "max-results" : {
          "description" : "The maximum number of rows to scan.",
          "default" : "100",
          "type" : "integer"
        },
        "operation" : {
          "description" : "The HBase operation to perform",
          "enum" : [ "CamelHBasePut", "CamelHBaseGet", "CamelHBaseScan", "CamelHBaseDelete" ],
          "type" : "string"
        },
        "remove" : {
          "description" : "If the option is true, Camel HBase Consumer will remove the rows which it processes.",
          "default" : "true",
          "type" : "boolean"
        },
        "remove-handler" : {
          "description" : "To use a custom HBaseRemoveHandler that is executed when a row is to be removed.",
          "type" : "string"
        },
        "row-mapping" : {
          "description" : "To map the key/values from the Map to a HBaseRow. The following keys is supported: rowId - The id of the row. This has limited use as the row usually changes per Exchange. rowType - The type to covert row id to. Supported operations: CamelHBaseScan. family - The column family. Supports a number suffix for referring to more than one columns. qualifier - The column qualifier. Supports a number suffix for referring to more than one columns. value - The value. Supports a number suffix for referring to more than one columns valueType - The value type. Supports a number suffix for referring to more than one columns. Supported operations: CamelHBaseGet, and CamelHBaseScan.",
          "type" : "string"
        },
        "row-model" : {
          "description" : "An instance of org.apache.camel.component.hbase.model.HBaseRow which describes how each row should be modeled",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "user-group-information" : {
          "description" : "Defines privileges to communicate with HBase such as using kerberos.",
          "type" : "string"
        }
      }
    },
    "hdfs" : {
      "type" : "object",
      "required" : [ "hostName", "path" ],
      "properties" : {
        "host-name" : {
          "description" : "HDFS host to use",
          "type" : "string"
        },
        "path" : {
          "description" : "The directory path to use",
          "type" : "string"
        },
        "port" : {
          "description" : "HDFS port to use",
          "default" : "8020",
          "type" : "integer"
        },
        "append" : {
          "description" : "Append to existing file. Notice that not all HDFS file systems support the append option.",
          "default" : "false",
          "type" : "boolean"
        },
        "backoff-error-threshold" : {
          "description" : "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-idle-threshold" : {
          "description" : "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-multiplier" : {
          "description" : "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
          "type" : "integer"
        },
        "block-size" : {
          "description" : "The size of the HDFS blocks",
          "default" : "67108864",
          "type" : "integer"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "buffer-size" : {
          "description" : "The buffer size used by HDFS",
          "default" : "4096",
          "type" : "integer"
        },
        "check-idle-interval" : {
          "description" : "How often (time in millis) in to run the idle checker background task. This option is only in use if the splitter strategy is IDLE.",
          "default" : "500",
          "type" : "integer"
        },
        "chunk-size" : {
          "description" : "When reading a normal file, this is split into chunks producing a message per chunk.",
          "default" : "4096",
          "type" : "integer"
        },
        "compression-codec" : {
          "description" : "The compression codec to use",
          "default" : "DEFAULT",
          "enum" : [ "DEFAULT", "GZIP", "BZIP2" ],
          "type" : "string"
        },
        "compression-type" : {
          "description" : "The compression type to use (is default not in use)",
          "default" : "NONE",
          "enum" : [ "NONE", "RECORD", "BLOCK" ],
          "type" : "string"
        },
        "connect-on-startup" : {
          "description" : "Whether to connect to the HDFS file system on starting the producer/consumer. If false then the connection is created on-demand. Notice that HDFS may take up till 15 minutes to establish a connection, as it has hardcoded 45 x 20 sec redelivery. By setting this option to false allows your application to startup, and not block for up till 15 minutes.",
          "default" : "true",
          "type" : "boolean"
        },
        "delay" : {
          "description" : "Milliseconds before the next poll.",
          "default" : "500",
          "type" : "integer"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "file-system-type" : {
          "description" : "Set to LOCAL to not use HDFS but local java.io.File instead.",
          "default" : "HDFS",
          "enum" : [ "LOCAL", "HDFS" ],
          "type" : "string"
        },
        "file-type" : {
          "description" : "The file type to use. For more details see Hadoop HDFS documentation about the various files types.",
          "default" : "NORMAL_FILE",
          "enum" : [ "NORMAL_FILE", "SEQUENCE_FILE", "MAP_FILE", "BLOOMMAP_FILE", "ARRAY_FILE" ],
          "type" : "string"
        },
        "greedy" : {
          "description" : "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
          "default" : "false",
          "type" : "boolean"
        },
        "initial-delay" : {
          "description" : "Milliseconds before the first poll starts.",
          "default" : "1000",
          "type" : "integer"
        },
        "kerberos-config-file-location" : {
          "description" : "The location of the kerb5.conf file (https://web.mit.edu/kerberos/krb5-1.12/doc/admin/conf_files/krb5_conf.html)",
          "type" : "string"
        },
        "kerberos-keytab-location" : {
          "description" : "The location of the keytab file used to authenticate with the kerberos nodes (contains pairs of kerberos principals and encrypted keys (which are derived from the Kerberos password))",
          "type" : "string"
        },
        "kerberos-username" : {
          "description" : "The username used to authenticate with the kerberos nodes",
          "type" : "string"
        },
        "key-type" : {
          "description" : "The type for the key in case of sequence or map files.",
          "default" : "NULL",
          "enum" : [ "NULL", "BOOLEAN", "BYTE", "INT", "FLOAT", "LONG", "DOUBLE", "TEXT", "BYTES" ],
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "max-messages-per-poll" : {
          "description" : "To define a maximum messages to gather per poll. By default a limit of 100 is set. Can be used to set a limit of e.g. 1000 to avoid when starting up the server that there are thousands of files. Values can only be greater than 0. Notice: If this option is in use then the limit will be applied on the valid files. For example if you have 100000 files and use maxMessagesPerPoll=500, then only the first 500 files will be picked up.",
          "default" : "100",
          "type" : "integer"
        },
        "named-nodes" : {
          "description" : "A comma separated list of named nodes (e.g. srv11.example.com:8020,srv12.example.com:8020)",
          "type" : "string"
        },
        "opened-suffix" : {
          "description" : "When a file is opened for reading/writing the file is renamed with this suffix to avoid to read it during the writing phase.",
          "default" : "opened",
          "type" : "string"
        },
        "overwrite" : {
          "description" : "Whether to overwrite existing files with the same name",
          "default" : "true",
          "type" : "boolean"
        },
        "owner" : {
          "description" : "The file owner must match this owner for the consumer to pickup the file. Otherwise the file is skipped.",
          "type" : "string"
        },
        "pattern" : {
          "description" : "The pattern used for scanning the directory",
          "default" : "*",
          "type" : "string"
        },
        "poll-strategy" : {
          "description" : "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
          "type" : "string"
        },
        "read-suffix" : {
          "description" : "Once the file has been read is renamed with this suffix to avoid to read it again.",
          "default" : "read",
          "type" : "string"
        },
        "repeat-count" : {
          "description" : "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
          "default" : "0",
          "type" : "integer"
        },
        "replication" : {
          "description" : "The HDFS replication factor",
          "default" : "3",
          "type" : "integer"
        },
        "run-logging-level" : {
          "description" : "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
          "default" : "TRACE",
          "enum" : [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ],
          "type" : "string"
        },
        "scheduled-executor-service" : {
          "description" : "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
          "type" : "string"
        },
        "scheduler" : {
          "description" : "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
          "default" : "none",
          "type" : "string"
        },
        "scheduler-properties" : {
          "description" : "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
          "type" : "string"
        },
        "send-empty-message-when-idle" : {
          "description" : "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
          "default" : "false",
          "type" : "boolean"
        },
        "split-strategy" : {
          "description" : "In the current version of Hadoop opening a file in append mode is disabled since it's not very reliable. So, for the moment, it's only possible to create new files. The Camel HDFS endpoint tries to solve this problem in this way: If the split strategy option has been defined, the hdfs path will be used as a directory and files will be created using the configured UuidGenerator. Every time a splitting condition is met, a new file is created. The splitStrategy option is defined as a string with the following syntax: splitStrategy=ST:value,ST:value,... where ST can be: BYTES a new file is created, and the old is closed when the number of written bytes is more than value MESSAGES a new file is created, and the old is closed when the number of written messages is more than value IDLE a new file is created, and the old is closed when no writing happened in the last value milliseconds",
          "type" : "string"
        },
        "start-scheduler" : {
          "description" : "Whether the scheduler should be auto started.",
          "default" : "true",
          "type" : "boolean"
        },
        "stream-download" : {
          "description" : "Sets the download method to use when not using a local working directory. If set to true, the remote files are streamed to the route as they are read. When set to false, the remote files are loaded into memory before being sent into the route.",
          "default" : "false",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "time-unit" : {
          "description" : "Time unit for initialDelay and delay options.",
          "default" : "MILLISECONDS",
          "enum" : [ "NANOSECONDS", "MICROSECONDS", "MILLISECONDS", "SECONDS", "MINUTES", "HOURS", "DAYS" ],
          "type" : "string"
        },
        "use-fixed-delay" : {
          "description" : "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
          "default" : "true",
          "type" : "boolean"
        },
        "value-type" : {
          "description" : "The type for the key in case of sequence or map files",
          "default" : "BYTES",
          "enum" : [ "NULL", "BOOLEAN", "BYTE", "INT", "FLOAT", "LONG", "DOUBLE", "TEXT", "BYTES" ],
          "type" : "string"
        }
      }
    },
    "http" : {
      "type" : "object",
      "required" : [ "httpUri" ],
      "properties" : {
        "http-uri" : {
          "description" : "The url of the HTTP endpoint to call.",
          "type" : "string"
        },
        "auth-domain" : {
          "description" : "Authentication domain to use with NTML",
          "type" : "string"
        },
        "auth-host" : {
          "description" : "Authentication host to use with NTML",
          "type" : "string"
        },
        "auth-method" : {
          "description" : "Authentication methods allowed to use as a comma separated list of values Basic, Digest or NTLM.",
          "type" : "string"
        },
        "auth-method-priority" : {
          "description" : "Which authentication method to prioritize to use, either as Basic, Digest or NTLM.",
          "enum" : [ "Basic", "Digest", "NTLM" ],
          "type" : "string"
        },
        "auth-password" : {
          "description" : "Authentication password",
          "type" : "string"
        },
        "auth-username" : {
          "description" : "Authentication username",
          "type" : "string"
        },
        "authentication-preemptive" : {
          "description" : "If this option is true, camel-http sends preemptive basic authentication to the server.",
          "default" : "false",
          "type" : "boolean"
        },
        "bridge-endpoint" : {
          "description" : "If the option is true, HttpProducer will ignore the Exchange.HTTP_URI header, and use the endpoint's URI for request. You may also set the option throwExceptionOnFailure to be false to let the HttpProducer send all the fault response back.",
          "default" : "false",
          "type" : "boolean"
        },
        "chunked" : {
          "description" : "If this option is false the Servlet will disable the HTTP streaming and set the content-length header on the response",
          "default" : "true",
          "type" : "boolean"
        },
        "clear-expired-cookies" : {
          "description" : "Whether to clear expired cookies before sending the HTTP request. This ensures the cookies store does not keep growing by adding new cookies which is newer removed when they are expired.",
          "default" : "true",
          "type" : "boolean"
        },
        "client-builder" : {
          "description" : "Provide access to the http client request parameters used on new RequestConfig instances used by producers or consumers of this endpoint.",
          "type" : "string"
        },
        "client-connection-manager" : {
          "description" : "To use a custom HttpClientConnectionManager to manage connections",
          "type" : "string"
        },
        "connection-close" : {
          "description" : "Specifies whether a Connection Close header must be added to HTTP Request. By default connectionClose is false.",
          "default" : "false",
          "type" : "boolean"
        },
        "connections-per-route" : {
          "description" : "The maximum number of connections per route.",
          "default" : "20",
          "type" : "integer"
        },
        "cookie-handler" : {
          "description" : "Configure a cookie handler to maintain a HTTP session",
          "type" : "string"
        },
        "cookie-store" : {
          "description" : "To use a custom CookieStore. By default the BasicCookieStore is used which is an in-memory only cookie store. Notice if bridgeEndpoint=true then the cookie store is forced to be a noop cookie store as cookie shouldn't be stored as we are just bridging (eg acting as a proxy). If a cookieHandler is set then the cookie store is also forced to be a noop cookie store as cookie handling is then performed by the cookieHandler.",
          "type" : "string"
        },
        "copy-headers" : {
          "description" : "If this option is true then IN exchange headers will be copied to OUT exchange headers according to copy strategy. Setting this to false, allows to only include the headers from the HTTP response (not propagating IN headers).",
          "default" : "true",
          "type" : "boolean"
        },
        "custom-host-header" : {
          "description" : "To use custom host header for producer. When not set in query will be ignored. When set will override host header derived from url.",
          "type" : "string"
        },
        "delete-with-body" : {
          "description" : "Whether the HTTP DELETE should include the message body or not. By default HTTP DELETE do not include any HTTP body. However in some rare cases users may need to be able to include the message body.",
          "default" : "false",
          "type" : "boolean"
        },
        "disable-stream-cache" : {
          "description" : "Determines whether or not the raw input stream from Servlet is cached or not (Camel will read the stream into a in memory/overflow to file, Stream caching) cache. By default Camel will cache the Servlet input stream to support reading it multiple times to ensure it Camel can retrieve all data from the stream. However you can set this option to true when you for example need to access the raw stream, such as streaming it directly to a file or other persistent store. DefaultHttpBinding will copy the request input stream into a stream cache and put it into message body if this option is false to support reading the stream multiple times. If you use Servlet to bridge/proxy an endpoint then consider enabling this option to improve performance, in case you do not need to read the message payload multiple times. The http producer will by default cache the response body stream. If setting this option to true, then the producers will not cache the response body stream but use the response stream as-is as the message body.",
          "default" : "false",
          "type" : "boolean"
        },
        "get-with-body" : {
          "description" : "Whether the HTTP GET should include the message body or not. By default HTTP GET do not include any HTTP body. However in some rare cases users may need to be able to include the message body.",
          "default" : "false",
          "type" : "boolean"
        },
        "header-filter-strategy" : {
          "description" : "To use a custom HeaderFilterStrategy to filter header to and from Camel message.",
          "type" : "string"
        },
        "http-binding" : {
          "description" : "To use a custom HttpBinding to control the mapping between Camel message and HttpClient.",
          "type" : "string"
        },
        "http-client" : {
          "description" : "Sets a custom HttpClient to be used by the producer",
          "type" : "string"
        },
        "http-client-configurer" : {
          "description" : "Register a custom configuration strategy for new HttpClient instances created by producers or consumers such as to configure authentication mechanisms etc.",
          "type" : "string"
        },
        "http-client-options" : {
          "description" : "To configure the HttpClient using the key/values from the Map.",
          "type" : "string"
        },
        "http-context" : {
          "description" : "To use a custom HttpContext instance",
          "type" : "string"
        },
        "http-method" : {
          "description" : "Configure the HTTP method to use. The HttpMethod header cannot override this option if set.",
          "enum" : [ "GET", "POST", "PUT", "DELETE", "HEAD", "OPTIONS", "TRACE", "PATCH" ],
          "type" : "string"
        },
        "ignore-response-body" : {
          "description" : "If this option is true, The http producer won't read response body and cache the input stream",
          "default" : "false",
          "type" : "boolean"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "map-http-message-body" : {
          "description" : "If this option is true then IN exchange Body of the exchange will be mapped to HTTP body. Setting this to false will avoid the HTTP mapping.",
          "default" : "true",
          "type" : "boolean"
        },
        "map-http-message-form-url-encoded-body" : {
          "description" : "If this option is true then IN exchange Form Encoded body of the exchange will be mapped to HTTP. Setting this to false will avoid the HTTP Form Encoded body mapping.",
          "default" : "true",
          "type" : "boolean"
        },
        "map-http-message-headers" : {
          "description" : "If this option is true then IN exchange Headers of the exchange will be mapped to HTTP headers. Setting this to false will avoid the HTTP Headers mapping.",
          "default" : "true",
          "type" : "boolean"
        },
        "max-total-connections" : {
          "description" : "The maximum number of connections.",
          "default" : "200",
          "type" : "integer"
        },
        "ok-status-code-range" : {
          "description" : "The status codes which are considered a success response. The values are inclusive. Multiple ranges can be defined, separated by comma, e.g. 200-204,209,301-304. Each range must be a single number or from-to with the dash included.",
          "default" : "200-299",
          "type" : "string"
        },
        "preserve-host-header" : {
          "description" : "If the option is true, HttpProducer will set the Host header to the value contained in the current exchange Host header, useful in reverse proxy applications where you want the Host header received by the downstream server to reflect the URL called by the upstream client, this allows applications which use the Host header to generate accurate URL's for a proxied service",
          "default" : "false",
          "type" : "boolean"
        },
        "proxy-auth-domain" : {
          "description" : "Proxy authentication domain to use with NTML",
          "type" : "string"
        },
        "proxy-auth-host" : {
          "description" : "Proxy authentication host",
          "type" : "string"
        },
        "proxy-auth-method" : {
          "description" : "Proxy authentication method to use",
          "enum" : [ "Basic", "Digest", "NTLM" ],
          "type" : "string"
        },
        "proxy-auth-nt-host" : {
          "description" : "Proxy authentication domain (workstation name) to use with NTML",
          "type" : "string"
        },
        "proxy-auth-password" : {
          "description" : "Proxy authentication password",
          "type" : "string"
        },
        "proxy-auth-port" : {
          "description" : "Proxy authentication port",
          "type" : "integer"
        },
        "proxy-auth-scheme" : {
          "description" : "Proxy authentication scheme to use",
          "enum" : [ "http", "https" ],
          "type" : "string"
        },
        "proxy-auth-username" : {
          "description" : "Proxy authentication username",
          "type" : "string"
        },
        "proxy-host" : {
          "description" : "Proxy hostname to use",
          "type" : "string"
        },
        "proxy-port" : {
          "description" : "Proxy port to use",
          "type" : "integer"
        },
        "ssl-context-parameters" : {
          "description" : "To configure security using SSLContextParameters. Important: Only one instance of org.apache.camel.util.jsse.SSLContextParameters is supported per HttpComponent. If you need to use 2 or more different instances, you need to define a new HttpComponent per instance you need.",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "throw-exception-on-failure" : {
          "description" : "Option to disable throwing the HttpOperationFailedException in case of failed responses from the remote server. This allows you to get all responses regardless of the HTTP status code.",
          "default" : "true",
          "type" : "boolean"
        },
        "transfer-exception" : {
          "description" : "If enabled and an Exchange failed processing on the consumer side, and if the caused Exception was send back serialized in the response as a application/x-java-serialized-object content type. On the producer side the exception will be deserialized and thrown as is, instead of the HttpOperationFailedException. The caused exception is required to be serialized. This is by default turned off. If you enable this then be aware that Java will deserialize the incoming data from the request to Java and that can be a potential security risk.",
          "default" : "false",
          "type" : "boolean"
        },
        "use-system-properties" : {
          "description" : "To use System Properties as fallback for configuration",
          "default" : "false",
          "type" : "boolean"
        },
        "x509-hostname-verifier" : {
          "description" : "To use a custom X509HostnameVerifier such as DefaultHostnameVerifier or NoopHostnameVerifier",
          "type" : "string"
        }
      }
    },
    "https" : {
      "type" : "object",
      "$ref" : "#/definitions/http"
    },
    "iec60870-client" : {
      "type" : "object",
      "required" : [ "uriPath" ],
      "properties" : {
        "uri-path" : {
          "description" : "The object information address",
          "type" : "string"
        },
        "acknowledge-window" : {
          "description" : "Parameter W - Acknowledgment window.",
          "default" : "10",
          "type" : "integer"
        },
        "adsu-address-type" : {
          "description" : "The common ASDU address size. May be either SIZE_1 or SIZE_2.",
          "enum" : [ "SIZE_1", "SIZE_2" ],
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "cause-of-transmission-type" : {
          "description" : "The cause of transmission type. May be either SIZE_1 or SIZE_2.",
          "enum" : [ "SIZE_1", "SIZE_2" ],
          "type" : "string"
        },
        "cause-source-address" : {
          "description" : "Whether to include the source address",
          "type" : "integer"
        },
        "connection-id" : {
          "description" : "An identifier grouping connection instances",
          "type" : "string"
        },
        "connection-timeout" : {
          "description" : "Timeout in millis to wait for client to establish a connected connection.",
          "default" : "10000",
          "type" : "integer"
        },
        "data-module-options" : {
          "description" : "Data module options",
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "ignore-background-scan" : {
          "description" : "Whether background scan transmissions should be ignored.",
          "default" : "true",
          "type" : "boolean"
        },
        "ignore-daylight-saving-time" : {
          "description" : "Whether to ignore or respect DST",
          "default" : "false",
          "type" : "boolean"
        },
        "information-object-address-type" : {
          "description" : "The information address size. May be either SIZE_1, SIZE_2 or SIZE_3.",
          "enum" : [ "SIZE_1", "SIZE_2", "SIZE_3" ],
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "max-unacknowledged" : {
          "description" : "Parameter K - Maximum number of un-acknowledged messages.",
          "default" : "15",
          "type" : "integer"
        },
        "protocol-options" : {
          "description" : "Protocol options",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "time-zone" : {
          "description" : "The timezone to use. May be any Java time zone string",
          "default" : "UTC",
          "type" : "string"
        },
        "timeout1" : {
          "description" : "Timeout T1 in milliseconds.",
          "default" : "15000",
          "type" : "integer"
        },
        "timeout2" : {
          "description" : "Timeout T2 in milliseconds.",
          "default" : "10000",
          "type" : "integer"
        },
        "timeout3" : {
          "description" : "Timeout T3 in milliseconds.",
          "default" : "20000",
          "type" : "integer"
        }
      }
    },
    "iec60870-server" : {
      "type" : "object",
      "required" : [ "uriPath" ],
      "properties" : {
        "uri-path" : {
          "description" : "The object information address",
          "type" : "string"
        },
        "acknowledge-window" : {
          "description" : "Parameter W - Acknowledgment window.",
          "default" : "10",
          "type" : "integer"
        },
        "adsu-address-type" : {
          "description" : "The common ASDU address size. May be either SIZE_1 or SIZE_2.",
          "enum" : [ "SIZE_1", "SIZE_2" ],
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "cause-of-transmission-type" : {
          "description" : "The cause of transmission type. May be either SIZE_1 or SIZE_2.",
          "enum" : [ "SIZE_1", "SIZE_2" ],
          "type" : "string"
        },
        "cause-source-address" : {
          "description" : "Whether to include the source address",
          "type" : "integer"
        },
        "connection-id" : {
          "description" : "An identifier grouping connection instances",
          "type" : "string"
        },
        "connection-timeout" : {
          "description" : "Timeout in millis to wait for client to establish a connected connection.",
          "default" : "10000",
          "type" : "integer"
        },
        "data-module-options" : {
          "description" : "Data module options",
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "filter-non-execute" : {
          "description" : "Filter out all requests which don't have the execute bit set",
          "default" : "true",
          "type" : "boolean"
        },
        "ignore-background-scan" : {
          "description" : "Whether background scan transmissions should be ignored.",
          "default" : "true",
          "type" : "boolean"
        },
        "ignore-daylight-saving-time" : {
          "description" : "Whether to ignore or respect DST",
          "default" : "false",
          "type" : "boolean"
        },
        "information-object-address-type" : {
          "description" : "The information address size. May be either SIZE_1, SIZE_2 or SIZE_3.",
          "enum" : [ "SIZE_1", "SIZE_2", "SIZE_3" ],
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "max-unacknowledged" : {
          "description" : "Parameter K - Maximum number of un-acknowledged messages.",
          "default" : "15",
          "type" : "integer"
        },
        "protocol-options" : {
          "description" : "Protocol options",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "time-zone" : {
          "description" : "The timezone to use. May be any Java time zone string",
          "default" : "UTC",
          "type" : "string"
        },
        "timeout1" : {
          "description" : "Timeout T1 in milliseconds.",
          "default" : "15000",
          "type" : "integer"
        },
        "timeout2" : {
          "description" : "Timeout T2 in milliseconds.",
          "default" : "10000",
          "type" : "integer"
        },
        "timeout3" : {
          "description" : "Timeout T3 in milliseconds.",
          "default" : "20000",
          "type" : "integer"
        }
      }
    },
    "ignite-cache" : {
      "type" : "object",
      "required" : [ "cacheName" ],
      "properties" : {
        "cache-name" : {
          "description" : "The cache name.",
          "type" : "string"
        },
        "auto-unsubscribe" : {
          "description" : "Whether auto unsubscribe is enabled in the Continuous Query Consumer. Default value notice: ContinuousQuery.DFLT_AUTO_UNSUBSCRIBE",
          "default" : "true",
          "type" : "boolean"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "cache-peek-mode" : {
          "description" : "The CachePeekMode, only needed for operations that require it (IgniteCacheOperation#SIZE).",
          "default" : "ALL",
          "enum" : [ "ALL", "NEAR", "PRIMARY", "BACKUP", "ONHEAP", "OFFHEAP" ],
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "fail-if-inexistent-cache" : {
          "description" : "Whether to fail the initialization if the cache doesn't exist.",
          "default" : "false",
          "type" : "boolean"
        },
        "fire-existing-query-results" : {
          "description" : "Whether to process existing results that match the query. Used on initialization of the Continuous Query Consumer.",
          "default" : "false",
          "type" : "boolean"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "one-exchange-per-update" : {
          "description" : "Whether to pack each update in an individual Exchange, even if multiple updates are received in one batch. Only used by the Continuous Query Consumer.",
          "default" : "true",
          "type" : "boolean"
        },
        "operation" : {
          "description" : "The cache operation to invoke. Possible values: GET, PUT, REMOVE, SIZE, REBALANCE, QUERY, CLEAR.",
          "enum" : [ "GET", "PUT", "REMOVE", "SIZE", "REBALANCE", "QUERY", "CLEAR" ],
          "type" : "string"
        },
        "page-size" : {
          "description" : "The page size. Only used by the Continuous Query Consumer. Default value notice: ContinuousQuery.DFLT_PAGE_SIZE",
          "default" : "1",
          "type" : "integer"
        },
        "propagate-incoming-body-if-no-return-value" : {
          "description" : "Sets whether to propagate the incoming body if the return type of the underlying Ignite operation is void.",
          "default" : "true",
          "type" : "boolean"
        },
        "query" : {
          "description" : "The Query to execute, only needed for operations that require it, and for the Continuous Query Consumer.",
          "type" : "string"
        },
        "remote-filter" : {
          "description" : "The remote filter, only used by the Continuous Query Consumer.",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "time-interval" : {
          "description" : "The time interval for the Continuous Query Consumer. Default value notice: ContinuousQuery.DFLT_TIME_INTERVAL",
          "default" : "0",
          "type" : "integer"
        },
        "treat-collections-as-cache-objects" : {
          "description" : "Sets whether to treat Collections as cache objects or as Collections of items to insert/update/compute, etc.",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "ignite-compute" : {
      "type" : "object",
      "required" : [ "endpointId", "executionType" ],
      "properties" : {
        "endpoint-id" : {
          "description" : "The endpoint ID (not used).",
          "type" : "string"
        },
        "cluster-group-expression" : {
          "description" : "An expression that returns the Cluster Group for the IgniteCompute instance.",
          "type" : "string"
        },
        "compute-name" : {
          "description" : "The name of the compute job, which will be set via IgniteCompute#withName(String).",
          "type" : "string"
        },
        "execution-type" : {
          "description" : "The compute operation to perform. Possible values: CALL, BROADCAST, APPLY, EXECUTE, RUN, AFFINITY_CALL, AFFINITY_RUN. The component expects different payload types depending on the operation.",
          "enum" : [ "CALL", "BROADCAST", "APPLY", "EXECUTE", "RUN", "AFFINITY_CALL", "AFFINITY_RUN" ],
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "propagate-incoming-body-if-no-return-value" : {
          "description" : "Sets whether to propagate the incoming body if the return type of the underlying Ignite operation is void.",
          "default" : "true",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "task-name" : {
          "description" : "The task name, only applicable if using the IgniteComputeExecutionType#EXECUTE execution type.",
          "type" : "string"
        },
        "timeout-millis" : {
          "description" : "The timeout interval for triggered jobs, in milliseconds, which will be set via IgniteCompute#withTimeout(long).",
          "type" : "integer"
        },
        "treat-collections-as-cache-objects" : {
          "description" : "Sets whether to treat Collections as cache objects or as Collections of items to insert/update/compute, etc.",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "ignite-events" : {
      "type" : "object",
      "properties" : {
        "endpoint-id" : {
          "description" : "The endpoint ID (not used).",
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "cluster-group-expression" : {
          "description" : "The cluster group expression.",
          "type" : "string"
        },
        "events" : {
          "description" : "The event types to subscribe to as a comma-separated string of event constants as defined in EventType. For example: EVT_CACHE_ENTRY_CREATED,EVT_CACHE_OBJECT_REMOVED,EVT_IGFS_DIR_CREATED.",
          "default" : "EVTS_ALL",
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "propagate-incoming-body-if-no-return-value" : {
          "description" : "Sets whether to propagate the incoming body if the return type of the underlying Ignite operation is void.",
          "default" : "true",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "treat-collections-as-cache-objects" : {
          "description" : "Sets whether to treat Collections as cache objects or as Collections of items to insert/update/compute, etc.",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "ignite-idgen" : {
      "type" : "object",
      "required" : [ "name" ],
      "properties" : {
        "name" : {
          "description" : "The sequence name.",
          "type" : "string"
        },
        "batch-size" : {
          "description" : "The batch size.",
          "type" : "integer"
        },
        "initial-value" : {
          "description" : "The initial value.",
          "default" : "0",
          "type" : "integer"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "operation" : {
          "description" : "The operation to invoke on the Ignite ID Generator. Superseded by the IgniteConstants.IGNITE_IDGEN_OPERATION header in the IN message. Possible values: ADD_AND_GET, GET, GET_AND_ADD, GET_AND_INCREMENT, INCREMENT_AND_GET.",
          "enum" : [ "ADD_AND_GET", "GET", "GET_AND_ADD", "GET_AND_INCREMENT", "INCREMENT_AND_GET" ],
          "type" : "string"
        },
        "propagate-incoming-body-if-no-return-value" : {
          "description" : "Sets whether to propagate the incoming body if the return type of the underlying Ignite operation is void.",
          "default" : "true",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "treat-collections-as-cache-objects" : {
          "description" : "Sets whether to treat Collections as cache objects or as Collections of items to insert/update/compute, etc.",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "ignite-messaging" : {
      "type" : "object",
      "required" : [ "topic" ],
      "properties" : {
        "topic" : {
          "description" : "The topic name.",
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "cluster-group-expression" : {
          "description" : "The cluster group expression.",
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "propagate-incoming-body-if-no-return-value" : {
          "description" : "Sets whether to propagate the incoming body if the return type of the underlying Ignite operation is void.",
          "default" : "true",
          "type" : "boolean"
        },
        "send-mode" : {
          "description" : "The send mode to use. Possible values: UNORDERED, ORDERED.",
          "default" : "UNORDERED",
          "enum" : [ "ORDERED", "UNORDERED" ],
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "timeout" : {
          "description" : "The timeout for the send operation when using ordered messages.",
          "type" : "integer"
        },
        "treat-collections-as-cache-objects" : {
          "description" : "Sets whether to treat Collections as cache objects or as Collections of items to insert/update/compute, etc.",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "ignite-queue" : {
      "type" : "object",
      "required" : [ "name" ],
      "properties" : {
        "name" : {
          "description" : "The queue name.",
          "type" : "string"
        },
        "capacity" : {
          "description" : "The queue capacity. Default: non-bounded.",
          "type" : "integer"
        },
        "configuration" : {
          "description" : "The collection configuration. Default: empty configuration. You can also conveniently set inner properties by using configuration.xyz=123 options.",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "operation" : {
          "description" : "The operation to invoke on the Ignite Queue. Superseded by the IgniteConstants.IGNITE_QUEUE_OPERATION header in the IN message. Possible values: CONTAINS, ADD, SIZE, REMOVE, ITERATOR, CLEAR, RETAIN_ALL, ARRAY, DRAIN, ELEMENT, PEEK, OFFER, POLL, TAKE, PUT.",
          "enum" : [ "CONTAINS", "ADD", "SIZE", "REMOVE", "ITERATOR", "CLEAR", "RETAIN_ALL", "ARRAY", "DRAIN", "ELEMENT", "PEEK", "OFFER", "POLL", "TAKE", "PUT" ],
          "type" : "string"
        },
        "propagate-incoming-body-if-no-return-value" : {
          "description" : "Sets whether to propagate the incoming body if the return type of the underlying Ignite operation is void.",
          "default" : "true",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "timeout-millis" : {
          "description" : "The queue timeout in milliseconds. Default: no timeout.",
          "type" : "integer"
        },
        "treat-collections-as-cache-objects" : {
          "description" : "Sets whether to treat Collections as cache objects or as Collections of items to insert/update/compute, etc.",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "ignite-set" : {
      "type" : "object",
      "required" : [ "name" ],
      "properties" : {
        "name" : {
          "description" : "The set name.",
          "type" : "string"
        },
        "configuration" : {
          "description" : "The collection configuration. Default: empty configuration. You can also conveniently set inner properties by using configuration.xyz=123 options.",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "operation" : {
          "description" : "The operation to invoke on the Ignite Set. Superseded by the IgniteConstants.IGNITE_SETS_OPERATION header in the IN message. Possible values: CONTAINS, ADD, SIZE, REMOVE, ITERATOR, CLEAR, RETAIN_ALL, ARRAY.The set operation to perform.",
          "enum" : [ "CONTAINS", "ADD", "SIZE", "REMOVE", "ITERATOR", "CLEAR", "RETAIN_ALL", "ARRAY" ],
          "type" : "string"
        },
        "propagate-incoming-body-if-no-return-value" : {
          "description" : "Sets whether to propagate the incoming body if the return type of the underlying Ignite operation is void.",
          "default" : "true",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "treat-collections-as-cache-objects" : {
          "description" : "Sets whether to treat Collections as cache objects or as Collections of items to insert/update/compute, etc.",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "imap" : {
      "type" : "object",
      "required" : [ "host" ],
      "properties" : {
        "host" : {
          "description" : "The mail server host name",
          "type" : "string"
        },
        "port" : {
          "description" : "The port number of the mail server",
          "type" : "integer"
        },
        "additional-java-mail-properties" : {
          "description" : "Sets additional java mail properties, that will append/override any default properties that is set based on all the other options. This is useful if you need to add some special options but want to keep the others as is.",
          "type" : "string"
        },
        "alternative-body-header" : {
          "description" : "Specifies the key to an IN message header that contains an alternative email body. For example, if you send emails in text/html format and want to provide an alternative mail body for non-HTML email clients, set the alternative mail body with this key as a header.",
          "default" : "CamelMailAlternativeBody",
          "type" : "string"
        },
        "attachments-content-transfer-encoding-resolver" : {
          "description" : "To use a custom AttachmentsContentTransferEncodingResolver to resolve what content-type-encoding to use for attachments.",
          "type" : "string"
        },
        "authenticator" : {
          "description" : "The authenticator for login. If set then the password and username are ignored. Can be used for tokens which can expire and therefore must be read dynamically.",
          "type" : "string"
        },
        "backoff-error-threshold" : {
          "description" : "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-idle-threshold" : {
          "description" : "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-multiplier" : {
          "description" : "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
          "type" : "integer"
        },
        "bcc" : {
          "description" : "Sets the BCC email address. Separate multiple email addresses with comma.",
          "type" : "string"
        },
        "binding" : {
          "description" : "Sets the binding used to convert from a Camel message to and from a Mail message",
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "cc" : {
          "description" : "Sets the CC email address. Separate multiple email addresses with comma.",
          "type" : "string"
        },
        "close-folder" : {
          "description" : "Whether the consumer should close the folder after polling. Setting this option to false and having disconnect=false as well, then the consumer keep the folder open between polls.",
          "default" : "true",
          "type" : "boolean"
        },
        "connection-timeout" : {
          "description" : "The connection timeout in milliseconds.",
          "default" : "30000",
          "type" : "integer"
        },
        "content-type" : {
          "description" : "The mail message content type. Use text/html for HTML mails.",
          "default" : "text/plain",
          "type" : "string"
        },
        "content-type-resolver" : {
          "description" : "Resolver to determine Content-Type for file attachments.",
          "type" : "string"
        },
        "copy-to" : {
          "description" : "After processing a mail message, it can be copied to a mail folder with the given name. You can override this configuration value, with a header with the key copyTo, allowing you to copy messages to folder names configured at runtime.",
          "type" : "string"
        },
        "debug-mode" : {
          "description" : "Enable debug mode on the underlying mail framework. The SUN Mail framework logs the debug messages to System.out by default.",
          "default" : "false",
          "type" : "boolean"
        },
        "delay" : {
          "description" : "Milliseconds before the next poll.",
          "default" : "60000",
          "type" : "string"
        },
        "delete" : {
          "description" : "Deletes the messages after they have been processed. This is done by setting the DELETED flag on the mail message. If false, the SEEN flag is set instead. As of Camel 2.10 you can override this configuration option by setting a header with the key delete to determine if the mail should be deleted or not.",
          "default" : "false",
          "type" : "boolean"
        },
        "disconnect" : {
          "description" : "Whether the consumer should disconnect after polling. If enabled this forces Camel to connect on each poll.",
          "default" : "false",
          "type" : "boolean"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "fetch-size" : {
          "description" : "Sets the maximum number of messages to consume during a poll. This can be used to avoid overloading a mail server, if a mailbox folder contains a lot of messages. Default value of -1 means no fetch size and all messages will be consumed. Setting the value to 0 is a special corner case, where Camel will not consume any messages at all.",
          "default" : "-1",
          "type" : "integer"
        },
        "folder-name" : {
          "description" : "The folder to poll.",
          "default" : "INBOX",
          "type" : "string"
        },
        "from" : {
          "description" : "The from email address",
          "default" : "camel@localhost",
          "type" : "string"
        },
        "greedy" : {
          "description" : "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
          "default" : "false",
          "type" : "boolean"
        },
        "handle-failed-message" : {
          "description" : "If the mail consumer cannot retrieve a given mail message, then this option allows to handle the caused exception by the consumer's error handler. By enable the bridge error handler on the consumer, then the Camel routing error handler can handle the exception instead. The default behavior would be the consumer throws an exception and no mails from the batch would be able to be routed by Camel.",
          "default" : "false",
          "type" : "boolean"
        },
        "header-filter-strategy" : {
          "description" : "To use a custom org.apache.camel.spi.HeaderFilterStrategy to filter headers.",
          "type" : "string"
        },
        "idempotent-repository" : {
          "description" : "A pluggable repository org.apache.camel.spi.IdempotentRepository which allows to cluster consuming from the same mailbox, and let the repository coordinate whether a mail message is valid for the consumer to process. By default no repository is in use.",
          "type" : "string"
        },
        "idempotent-repository-remove-on-commit" : {
          "description" : "When using idempotent repository, then when the mail message has been successfully processed and is committed, should the message id be removed from the idempotent repository (default) or be kept in the repository. By default its assumed the message id is unique and has no value to be kept in the repository, because the mail message will be marked as seen/moved or deleted to prevent it from being consumed again. And therefore having the message id stored in the idempotent repository has little value. However this option allows to store the message id, for whatever reason you may have.",
          "default" : "true",
          "type" : "boolean"
        },
        "ignore-unsupported-charset" : {
          "description" : "Option to let Camel ignore unsupported charset in the local JVM when sending mails. If the charset is unsupported then charset=XXX (where XXX represents the unsupported charset) is removed from the content-type and it relies on the platform default instead.",
          "default" : "false",
          "type" : "boolean"
        },
        "ignore-uri-scheme" : {
          "description" : "Option to let Camel ignore unsupported charset in the local JVM when sending mails. If the charset is unsupported then charset=XXX (where XXX represents the unsupported charset) is removed from the content-type and it relies on the platform default instead.",
          "default" : "false",
          "type" : "boolean"
        },
        "initial-delay" : {
          "description" : "Milliseconds before the first poll starts.",
          "default" : "1000",
          "type" : "integer"
        },
        "java-mail-properties" : {
          "description" : "Sets the java mail options. Will clear any default properties and only use the properties provided for this method.",
          "type" : "string"
        },
        "java-mail-sender" : {
          "description" : "To use a custom org.apache.camel.component.mail.JavaMailSender for sending emails.",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "mail-uid-generator" : {
          "description" : "A pluggable MailUidGenerator that allows to use custom logic to generate UUID of the mail message.",
          "type" : "string"
        },
        "map-mail-message" : {
          "description" : "Specifies whether Camel should map the received mail message to Camel body/headers/attachments. If set to true, the body of the mail message is mapped to the body of the Camel IN message, the mail headers are mapped to IN headers, and the attachments to Camel IN attachment message. If this option is set to false then the IN message contains a raw javax.mail.Message. You can retrieve this raw message by calling exchange.getIn().getBody(javax.mail.Message.class).",
          "default" : "true",
          "type" : "boolean"
        },
        "max-messages-per-poll" : {
          "description" : "Specifies the maximum number of messages to gather per poll. By default, no maximum is set. Can be used to set a limit of e.g. 1000 to avoid downloading thousands of files when the server starts up. Set a value of 0 or negative to disable this option.",
          "type" : "integer"
        },
        "mime-decode-headers" : {
          "description" : "This option enables transparent MIME decoding and unfolding for mail headers.",
          "default" : "false",
          "type" : "boolean"
        },
        "move-to" : {
          "description" : "After processing a mail message, it can be moved to a mail folder with the given name. You can override this configuration value, with a header with the key moveTo, allowing you to move messages to folder names configured at runtime.",
          "type" : "string"
        },
        "password" : {
          "description" : "The password for login. See also setAuthenticator(MailAuthenticator).",
          "type" : "string"
        },
        "peek" : {
          "description" : "Will mark the javax.mail.Message as peeked before processing the mail message. This applies to IMAPMessage messages types only. By using peek the mail will not be eager marked as SEEN on the mail server, which allows us to rollback the mail message if there is an error processing in Camel.",
          "default" : "true",
          "type" : "boolean"
        },
        "poll-strategy" : {
          "description" : "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
          "type" : "string"
        },
        "post-process-action" : {
          "description" : "Refers to an MailBoxPostProcessAction for doing post processing tasks on the mailbox once the normal processing ended.",
          "type" : "string"
        },
        "repeat-count" : {
          "description" : "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
          "default" : "0",
          "type" : "integer"
        },
        "reply-to" : {
          "description" : "The Reply-To recipients (the receivers of the response mail). Separate multiple email addresses with a comma.",
          "type" : "string"
        },
        "run-logging-level" : {
          "description" : "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
          "default" : "TRACE",
          "enum" : [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ],
          "type" : "string"
        },
        "scheduled-executor-service" : {
          "description" : "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
          "type" : "string"
        },
        "scheduler" : {
          "description" : "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
          "default" : "none",
          "type" : "string"
        },
        "scheduler-properties" : {
          "description" : "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
          "type" : "string"
        },
        "search-term" : {
          "description" : "Refers to a javax.mail.search.SearchTerm which allows to filter mails based on search criteria such as subject, body, from, sent after a certain date etc.",
          "type" : "string"
        },
        "send-empty-message-when-idle" : {
          "description" : "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
          "default" : "false",
          "type" : "boolean"
        },
        "session" : {
          "description" : "Specifies the mail session that camel should use for all mail interactions. Useful in scenarios where mail sessions are created and managed by some other resource, such as a JavaEE container. When using a custom mail session, then the hostname and port from the mail session will be used (if configured on the session).",
          "type" : "string"
        },
        "skip-failed-message" : {
          "description" : "If the mail consumer cannot retrieve a given mail message, then this option allows to skip the message and move on to retrieve the next mail message. The default behavior would be the consumer throws an exception and no mails from the batch would be able to be routed by Camel.",
          "default" : "false",
          "type" : "boolean"
        },
        "sort-term" : {
          "description" : "Sorting order for messages. Only natively supported for IMAP. Emulated to some degree when using POP3 or when IMAP server does not have the SORT capability.",
          "type" : "string"
        },
        "ssl-context-parameters" : {
          "description" : "To configure security using SSLContextParameters.",
          "type" : "string"
        },
        "start-scheduler" : {
          "description" : "Whether the scheduler should be auto started.",
          "default" : "true",
          "type" : "boolean"
        },
        "subject" : {
          "description" : "The Subject of the message being sent. Note: Setting the subject in the header takes precedence over this option.",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "time-unit" : {
          "description" : "Time unit for initialDelay and delay options.",
          "default" : "MILLISECONDS",
          "enum" : [ "NANOSECONDS", "MICROSECONDS", "MILLISECONDS", "SECONDS", "MINUTES", "HOURS", "DAYS" ],
          "type" : "string"
        },
        "to" : {
          "description" : "Sets the To email address. Separate multiple email addresses with comma.",
          "type" : "string"
        },
        "unseen" : {
          "description" : "Whether to limit by unseen mails only.",
          "default" : "true",
          "type" : "boolean"
        },
        "use-fixed-delay" : {
          "description" : "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
          "default" : "true",
          "type" : "boolean"
        },
        "use-inline-attachments" : {
          "description" : "Whether to use disposition inline or attachment.",
          "default" : "false",
          "type" : "boolean"
        },
        "username" : {
          "description" : "The username for login. See also setAuthenticator(MailAuthenticator).",
          "type" : "string"
        }
      }
    },
    "imaps" : {
      "type" : "object",
      "$ref" : "#/definitions/imap"
    },
    "pop3" : {
      "type" : "object",
      "$ref" : "#/definitions/imap"
    },
    "pop3s" : {
      "type" : "object",
      "$ref" : "#/definitions/imap"
    },
    "smtp" : {
      "type" : "object",
      "$ref" : "#/definitions/imap"
    },
    "smtps" : {
      "type" : "object",
      "$ref" : "#/definitions/imap"
    },
    "infinispan" : {
      "type" : "object",
      "required" : [ "cacheName" ],
      "properties" : {
        "cache-name" : {
          "description" : "The name of the cache to use. Use current to use the existing cache name from the currently configured cached manager. Or use default for the default cache manager name.",
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "cache-container" : {
          "description" : "Specifies the cache Container to connect",
          "type" : "string"
        },
        "cache-container-configuration" : {
          "description" : "The CacheContainer configuration. Uses if the cacheContainer is not defined. Must be the following types: org.infinispan.client.hotrod.configuration.Configuration - for remote cache interaction configuration; org.infinispan.configuration.cache.Configuration - for embedded cache interaction configuration;",
          "type" : "string"
        },
        "clustered-listener" : {
          "description" : "If true, the listener will be installed for the entire cluster",
          "default" : "false",
          "type" : "boolean"
        },
        "command" : {
          "description" : "The operation to perform.",
          "default" : "PUT",
          "type" : "string"
        },
        "configuration-properties" : {
          "description" : "Implementation specific properties for the CacheManager",
          "type" : "string"
        },
        "configuration-uri" : {
          "description" : "An implementation specific URI for the CacheManager",
          "type" : "string"
        },
        "custom-listener" : {
          "description" : "Returns the custom listener in use, if provided",
          "type" : "string"
        },
        "default-value" : {
          "description" : "Set a specific default value for some producer operations",
          "type" : "string"
        },
        "event-types" : {
          "description" : "Specifies the set of event types to register by the consumer. Multiple event can be separated by comma. The possible event types are: CACHE_ENTRY_ACTIVATED, CACHE_ENTRY_PASSIVATED, CACHE_ENTRY_VISITED, CACHE_ENTRY_LOADED, CACHE_ENTRY_EVICTED, CACHE_ENTRY_CREATED, CACHE_ENTRY_REMOVED, CACHE_ENTRY_MODIFIED, TRANSACTION_COMPLETED, TRANSACTION_REGISTERED, CACHE_ENTRY_INVALIDATED, DATA_REHASHED, TOPOLOGY_CHANGED, PARTITION_STATUS_CHANGED",
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "flags" : {
          "description" : "A comma separated list of Flag to be applied by default on each cache invocation, not applicable to remote caches.",
          "type" : "string"
        },
        "hosts" : {
          "description" : "Specifies the host of the cache on Infinispan instance",
          "type" : "string"
        },
        "key" : {
          "description" : "Set a specific key for producer operations",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "old-value" : {
          "description" : "Set a specific old value for some producer operations",
          "type" : "string"
        },
        "operation" : {
          "description" : "The operation to perform.",
          "default" : "PUT",
          "enum" : [ "PUT", "PUTASYNC", "PUTALL", "PUTALLASYNC", "PUTIFABSENT", "PUTIFABSENTASYNC", "GET", "GETORDEFAULT", "CONTAINSKEY", "CONTAINSVALUE", "REMOVE", "REMOVEASYNC", "REPLACE", "REPLACEASYNC", "SIZE", "CLEAR", "CLEARASYNC", "QUERY", "STATS", "COMPUTE", "COMPUTEASYNC" ],
          "type" : "string"
        },
        "password" : {
          "description" : "Define the password to access the infinispan instance",
          "type" : "string"
        },
        "query-builder" : {
          "description" : "Specifies the query builder.",
          "type" : "string"
        },
        "remapping-function" : {
          "description" : "Set a specific remappingFunction to use in a compute operation",
          "type" : "string"
        },
        "result-header" : {
          "description" : "Store the operation result in a header instead of the message body. By default, resultHeader == null and the query result is stored in the message body, any existing content in the message body is discarded. If resultHeader is set, the value is used as the name of the header to store the query result and the original message body is preserved. This value can be overridden by an in message header named: CamelInfinispanOperationResultHeader",
          "type" : "string"
        },
        "sasl-mechanism" : {
          "description" : "Define the SASL Mechanism to access the infinispan instance",
          "type" : "string"
        },
        "secure" : {
          "description" : "Define if we are connecting to a secured Infinispan instance",
          "default" : "false",
          "type" : "boolean"
        },
        "security-realm" : {
          "description" : "Define the security realm to access the infinispan instance",
          "type" : "string"
        },
        "security-server-name" : {
          "description" : "Define the security server name to access the infinispan instance",
          "type" : "string"
        },
        "sync" : {
          "description" : "If true, the consumer will receive notifications synchronously",
          "default" : "true",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "username" : {
          "description" : "Define the username to access the infinispan instance",
          "type" : "string"
        },
        "value" : {
          "description" : "Set a specific value for producer operations",
          "type" : "string"
        }
      }
    },
    "influxdb" : {
      "type" : "object",
      "required" : [ "connectionBean" ],
      "properties" : {
        "connection-bean" : {
          "description" : "Connection to the influx database, of class InfluxDB.class",
          "type" : "string"
        },
        "batch" : {
          "description" : "Define if this operation is a batch operation or not",
          "default" : "false",
          "type" : "boolean"
        },
        "database-name" : {
          "description" : "The name of the database where the time series will be stored",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "operation" : {
          "description" : "Define if this operation is an insert or a query",
          "default" : "insert",
          "type" : "string"
        },
        "query" : {
          "description" : "Define the query in case of operation query",
          "type" : "string"
        },
        "retention-policy" : {
          "description" : "The string that defines the retention policy to the data created by the endpoint",
          "default" : "default",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "iota" : {
      "type" : "object",
      "required" : [ "name", "operation", "url" ],
      "properties" : {
        "name" : {
          "description" : "Component name",
          "type" : "string"
        },
        "depth" : {
          "description" : "The depth determines how deep the tangle is analysed for getting Tips",
          "default" : "9",
          "type" : "integer"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "min-weight-magnitude" : {
          "description" : "The minWeightMagnitude is the minimum number of zeroes that a proof-of-work output/transaction hash must end with to be considered valid by full nodes",
          "default" : "14",
          "type" : "integer"
        },
        "operation" : {
          "description" : "Which operation to perform, one of: sendTransfer, getNewAddress, getTransfers",
          "enum" : [ "sendTransfer", "getNewAddress", "getTransfers" ],
          "type" : "string"
        },
        "security-level" : {
          "description" : "Address security level",
          "default" : "1",
          "type" : "integer"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "tag" : {
          "description" : "TAG",
          "type" : "string"
        },
        "url" : {
          "description" : "Node url",
          "type" : "string"
        }
      }
    },
    "ipfs" : {
      "type" : "object",
      "required" : [ "ipfsCmd" ],
      "properties" : {
        "ipfs-cmd" : {
          "description" : "The ipfs command",
          "enum" : [ "add", "cat", "get", "version" ],
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "outdir" : {
          "description" : "The ipfs output directory",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "irc" : {
      "type" : "object",
      "required" : [ "hostname" ],
      "properties" : {
        "hostname" : {
          "description" : "Hostname for the IRC chat server",
          "type" : "string"
        },
        "port" : {
          "description" : "Port number for the IRC chat server. If no port is configured then a default port of either 6667, 6668 or 6669 is used.",
          "type" : "integer"
        },
        "auto-rejoin" : {
          "description" : "Whether to auto re-join when being kicked",
          "default" : "true",
          "type" : "boolean"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "channels" : {
          "description" : "Comma separated list of IRC channels.",
          "type" : "string"
        },
        "colors" : {
          "description" : "Whether or not the server supports color codes.",
          "default" : "true",
          "type" : "boolean"
        },
        "command-timeout" : {
          "description" : "Delay in milliseconds before sending commands after the connection is established.",
          "default" : "5000",
          "type" : "integer"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "keys" : {
          "description" : "Comma separated list of keys for channels.",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "names-on-join" : {
          "description" : "Sends NAMES command to channel after joining it. onReply has to be true in order to process the result which will have the header value irc.num = '353'.",
          "default" : "false",
          "type" : "boolean"
        },
        "nick-password" : {
          "description" : "Your IRC server nickname password.",
          "type" : "string"
        },
        "nickname" : {
          "description" : "The nickname used in chat.",
          "type" : "string"
        },
        "on-join" : {
          "description" : "Handle user join events.",
          "default" : "true",
          "type" : "boolean"
        },
        "on-kick" : {
          "description" : "Handle kick events.",
          "default" : "true",
          "type" : "boolean"
        },
        "on-mode" : {
          "description" : "Handle mode change events.",
          "default" : "true",
          "type" : "boolean"
        },
        "on-nick" : {
          "description" : "Handle nickname change events.",
          "default" : "true",
          "type" : "boolean"
        },
        "on-part" : {
          "description" : "Handle user part events.",
          "default" : "true",
          "type" : "boolean"
        },
        "on-privmsg" : {
          "description" : "Handle private message events.",
          "default" : "true",
          "type" : "boolean"
        },
        "on-quit" : {
          "description" : "Handle user quit events.",
          "default" : "true",
          "type" : "boolean"
        },
        "on-reply" : {
          "description" : "Whether or not to handle general responses to commands or informational messages.",
          "default" : "false",
          "type" : "boolean"
        },
        "on-topic" : {
          "description" : "Handle topic change events.",
          "default" : "true",
          "type" : "boolean"
        },
        "password" : {
          "description" : "The IRC server password.",
          "type" : "string"
        },
        "persistent" : {
          "description" : "Use persistent messages.",
          "default" : "true",
          "type" : "boolean"
        },
        "realname" : {
          "description" : "The IRC user's actual name.",
          "type" : "string"
        },
        "ssl-context-parameters" : {
          "description" : "Used for configuring security using SSL. Reference to a org.apache.camel.support.jsse.SSLContextParameters in the Registry. This reference overrides any configured SSLContextParameters at the component level. Note that this setting overrides the trustManager option.",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "trust-manager" : {
          "description" : "The trust manager used to verify the SSL server's certificate.",
          "type" : "string"
        },
        "username" : {
          "description" : "The IRC server user name.",
          "type" : "string"
        }
      }
    },
    "ironmq" : {
      "type" : "object",
      "required" : [ "queueName" ],
      "properties" : {
        "queue-name" : {
          "description" : "The name of the IronMQ queue",
          "type" : "string"
        },
        "backoff-error-threshold" : {
          "description" : "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-idle-threshold" : {
          "description" : "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-multiplier" : {
          "description" : "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
          "type" : "integer"
        },
        "batch-delete" : {
          "description" : "Should messages be deleted in one batch. This will limit the number of api requests since messages are deleted in one request, instead of one pr. exchange. If enabled care should be taken that the consumer is idempotent when processing exchanges.",
          "default" : "false",
          "type" : "boolean"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "client" : {
          "description" : "Reference to a io.iron.ironmq.Client in the Registry.",
          "type" : "string"
        },
        "concurrent-consumers" : {
          "description" : "The number of concurrent consumers.",
          "default" : "1",
          "type" : "integer"
        },
        "delay" : {
          "description" : "Milliseconds before the next poll.",
          "default" : "500",
          "type" : "integer"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "greedy" : {
          "description" : "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
          "default" : "false",
          "type" : "boolean"
        },
        "initial-delay" : {
          "description" : "Milliseconds before the first poll starts.",
          "default" : "1000",
          "type" : "integer"
        },
        "iron-mq-cloud" : {
          "description" : "IronMq Cloud url. Urls for public clusters: https://mq-aws-us-east-1-1.iron.io (US) and https://mq-aws-eu-west-1-1.iron.io (EU)",
          "default" : "https://mq-aws-us-east-1-1.iron.io",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "max-messages-per-poll" : {
          "description" : "Number of messages to poll pr. call. Maximum is 100.",
          "default" : "1",
          "type" : "integer"
        },
        "poll-strategy" : {
          "description" : "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
          "type" : "string"
        },
        "preserve-headers" : {
          "description" : "Should message headers be preserved when publishing messages. This will add the Camel headers to the Iron MQ message as a json payload with a header list, and a message body. Useful when Camel is both consumer and producer.",
          "default" : "false",
          "type" : "boolean"
        },
        "project-id" : {
          "description" : "IronMQ projectId",
          "type" : "string"
        },
        "repeat-count" : {
          "description" : "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
          "default" : "0",
          "type" : "integer"
        },
        "run-logging-level" : {
          "description" : "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
          "default" : "TRACE",
          "enum" : [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ],
          "type" : "string"
        },
        "scheduled-executor-service" : {
          "description" : "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
          "type" : "string"
        },
        "scheduler" : {
          "description" : "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
          "default" : "none",
          "type" : "string"
        },
        "scheduler-properties" : {
          "description" : "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
          "type" : "string"
        },
        "send-empty-message-when-idle" : {
          "description" : "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
          "default" : "false",
          "type" : "boolean"
        },
        "start-scheduler" : {
          "description" : "Whether the scheduler should be auto started.",
          "default" : "true",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "time-unit" : {
          "description" : "Time unit for initialDelay and delay options.",
          "default" : "MILLISECONDS",
          "enum" : [ "NANOSECONDS", "MICROSECONDS", "MILLISECONDS", "SECONDS", "MINUTES", "HOURS", "DAYS" ],
          "type" : "string"
        },
        "timeout" : {
          "description" : "After timeout (in seconds), item will be placed back onto the queue.",
          "default" : "60",
          "type" : "integer"
        },
        "token" : {
          "description" : "IronMQ token",
          "type" : "string"
        },
        "use-fixed-delay" : {
          "description" : "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
          "default" : "true",
          "type" : "boolean"
        },
        "visibility-delay" : {
          "description" : "The item will not be available on the queue until this many seconds have passed. Default is 0 seconds.",
          "type" : "integer"
        },
        "wait" : {
          "description" : "Time in seconds to wait for a message to become available. This enables long polling. Default is 0 (does not wait), maximum is 30.",
          "type" : "integer"
        }
      }
    },
    "jbpm" : {
      "type" : "object",
      "required" : [ "connectionURL", "deploymentId" ],
      "properties" : {
        "connection-url" : {
          "description" : "The URL to the jBPM server.",
          "type" : "string"
        },
        "event-listener-type" : {
          "description" : "Sets the event listener type to attach to",
          "type" : "string"
        },
        "attachment-id" : {
          "description" : "attachId to use when retrieving attachments",
          "type" : "integer"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "content-id" : {
          "description" : "contentId to use when retrieving attachments",
          "type" : "integer"
        },
        "deployment-id" : {
          "description" : "The id of the deployment",
          "type" : "string"
        },
        "emitter-send-items" : {
          "description" : "Sets if event produced by emitter should be sent as single items or complete collection",
          "type" : "boolean"
        },
        "entities" : {
          "description" : "The potentialOwners when nominateTask operation is performed",
          "type" : "string"
        },
        "event" : {
          "description" : "the data associated with this event when signalEvent operation is performed",
          "type" : "string"
        },
        "event-type" : {
          "description" : "the type of event to use when signalEvent operation is performed",
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "extra-jaxb-classes" : {
          "description" : "To load additional classes when working with XML",
          "type" : "string"
        },
        "identifier" : {
          "description" : "identifier the global identifier",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "max-number" : {
          "description" : "the maximum number of rules that should be fired",
          "type" : "integer"
        },
        "operation" : {
          "description" : "The operation to perform",
          "default" : "startProcess",
          "type" : "string"
        },
        "page" : {
          "description" : "The page to use when retrieving user tasks",
          "type" : "integer"
        },
        "page-size" : {
          "description" : "The page size to use when retrieving user tasks",
          "type" : "integer"
        },
        "parameters" : {
          "description" : "the variables that should be set for various operations",
          "type" : "string"
        },
        "password" : {
          "description" : "Password for authentication",
          "type" : "string"
        },
        "process-id" : {
          "description" : "the id of the process that should be acted upon",
          "type" : "string"
        },
        "process-instance-id" : {
          "description" : "the id of the process instance",
          "type" : "integer"
        },
        "statuses" : {
          "description" : "The list of status to use when filtering tasks",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "target-user-id" : {
          "description" : "The targetUserId used when delegating a task",
          "type" : "string"
        },
        "task" : {
          "description" : "The task instance to use with task operations",
          "type" : "string"
        },
        "task-id" : {
          "description" : "the id of the task",
          "type" : "integer"
        },
        "timeout" : {
          "description" : "A timeout value",
          "type" : "integer"
        },
        "user-id" : {
          "description" : "userId to use with task operations",
          "type" : "string"
        },
        "user-name" : {
          "description" : "Username for authentication",
          "type" : "string"
        },
        "value" : {
          "description" : "the value to assign to the global identifier",
          "type" : "string"
        },
        "work-item-id" : {
          "description" : "the id of the work item",
          "type" : "integer"
        }
      }
    },
    "jcache" : {
      "type" : "object",
      "required" : [ "cacheName" ],
      "properties" : {
        "cache-name" : {
          "description" : "The name of the cache",
          "type" : "string"
        },
        "action" : {
          "description" : "To configure using a cache operation by default. If an operation in the message header, then the operation from the header takes precedence.",
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "cache-configuration" : {
          "description" : "A Configuration for the Cache",
          "type" : "string"
        },
        "cache-configuration-properties" : {
          "description" : "The Properties for the javax.cache.spi.CachingProvider to create the CacheManager",
          "type" : "string"
        },
        "cache-loader-factory" : {
          "description" : "The CacheLoader factory",
          "type" : "string"
        },
        "cache-writer-factory" : {
          "description" : "The CacheWriter factory",
          "type" : "string"
        },
        "caching-provider" : {
          "description" : "The fully qualified class name of the javax.cache.spi.CachingProvider",
          "type" : "string"
        },
        "configuration-uri" : {
          "description" : "An implementation specific URI for the CacheManager",
          "type" : "string"
        },
        "create-cache-if-not-exists" : {
          "description" : "Configure if a cache need to be created if it does exist or can't be pre-configured.",
          "default" : "true",
          "type" : "boolean"
        },
        "event-filters" : {
          "description" : "The CacheEntryEventFilter. If using eventFilters option, then filteredEvents one will be ignored",
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "expiry-policy-factory" : {
          "description" : "The ExpiryPolicy factory",
          "type" : "string"
        },
        "filtered-events" : {
          "description" : "Events a consumer should filter (multiple events can be separated by comma). If using filteredEvents option, then eventFilters one will be ignored",
          "enum" : [ "CREATED", "UPDATED", "REMOVED", "EXPIRED" ],
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "lookup-providers" : {
          "description" : "Configure if a camel-cache should try to find implementations of jcache api in runtimes like OSGi.",
          "default" : "false",
          "type" : "boolean"
        },
        "management-enabled" : {
          "description" : "Whether management gathering is enabled",
          "default" : "false",
          "type" : "boolean"
        },
        "old-value-required" : {
          "description" : "if the old value is required for events",
          "default" : "false",
          "type" : "boolean"
        },
        "read-through" : {
          "description" : "If read-through caching should be used",
          "default" : "false",
          "type" : "boolean"
        },
        "statistics-enabled" : {
          "description" : "Whether statistics gathering is enabled",
          "default" : "false",
          "type" : "boolean"
        },
        "store-by-value" : {
          "description" : "If cache should use store-by-value or store-by-reference semantics",
          "default" : "true",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "if the event listener should block the thread causing the event",
          "default" : "false",
          "type" : "boolean"
        },
        "write-through" : {
          "description" : "If write-through caching should be used",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "jclouds" : {
      "type" : "object",
      "required" : [ "command", "providerId" ],
      "properties" : {
        "command" : {
          "description" : "What command to execute such as blobstore or compute.",
          "enum" : [ "blobstore", "compute" ],
          "type" : "string"
        },
        "provider-id" : {
          "description" : "The name of the cloud provider that provides the target service (e.g. aws-s3 or aws_ec2).",
          "type" : "string"
        },
        "blob-name" : {
          "description" : "The name of the blob.",
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "container" : {
          "description" : "The name of the blob container.",
          "type" : "string"
        },
        "directory" : {
          "description" : "An optional directory name to use",
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "group" : {
          "description" : "The group that will be assigned to the newly created node. Values depend on the actual cloud provider.",
          "type" : "string"
        },
        "hardware-id" : {
          "description" : "The hardware that will be used for creating a node. Values depend on the actual cloud provider.",
          "type" : "string"
        },
        "image-id" : {
          "description" : "The imageId that will be used for creating a node. Values depend on the actual cloud provider.",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "location-id" : {
          "description" : "The location that will be used for creating a node. Values depend on the actual cloud provider.",
          "type" : "string"
        },
        "node-id" : {
          "description" : "The id of the node that will run the script or destroyed.",
          "type" : "string"
        },
        "node-state" : {
          "description" : "To filter by node status to only select running nodes etc.",
          "enum" : [ "PENDING", "TERMINATED", "SUSPENDED", "RUNNING", "ERROR", "UNRECOGNIZED" ],
          "type" : "string"
        },
        "operation" : {
          "description" : "Specifies the type of operation that will be performed to the blobstore.",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "user" : {
          "description" : "The user on the target node that will run the script.",
          "type" : "string"
        }
      }
    },
    "jcr" : {
      "type" : "object",
      "properties" : {
        "base" : {
          "description" : "Get the base node when accessing the repository",
          "type" : "string"
        },
        "host" : {
          "description" : "Name of the javax.jcr.Repository to lookup from the Camel registry to be used.",
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "deep" : {
          "description" : "When isDeep is true, events whose associated parent node is at absPath or within its subgraph are received.",
          "default" : "false",
          "type" : "boolean"
        },
        "event-types" : {
          "description" : "eventTypes (a combination of one or more event types encoded as a bit mask value such as javax.jcr.observation.Event.NODE_ADDED, javax.jcr.observation.Event.NODE_REMOVED, etc.).",
          "type" : "integer"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "no-local" : {
          "description" : "If noLocal is true, then events generated by the session through which the listener was registered are ignored. Otherwise, they are not ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "node-type-names" : {
          "description" : "When a comma separated nodeTypeName list string is set, only events whose associated parent node has one of the node types (or a subtype of one of the node types) in this list will be received.",
          "type" : "string"
        },
        "password" : {
          "description" : "Password for login",
          "type" : "string"
        },
        "session-live-check-interval" : {
          "description" : "Interval in milliseconds to wait before each session live checking The default value is 60000 ms.",
          "default" : "60000",
          "type" : "string"
        },
        "session-live-check-interval-on-start" : {
          "description" : "Interval in milliseconds to wait before the first session live checking. The default value is 3000 ms.",
          "default" : "3000",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "username" : {
          "description" : "Username for login",
          "type" : "string"
        },
        "uuids" : {
          "description" : "When a comma separated uuid list string is set, only events whose associated parent node has one of the identifiers in the comma separated uuid list will be received.",
          "type" : "string"
        },
        "workspace-name" : {
          "description" : "The workspace to access. If it's not specified then the default one will be used",
          "type" : "string"
        }
      },
      "required" : [ "host" ]
    },
    "jdbc" : {
      "type" : "object",
      "required" : [ "dataSourceName" ],
      "properties" : {
        "data-source-name" : {
          "description" : "Name of DataSource to lookup in the Registry. If the name is dataSource or default, then Camel will attempt to lookup a default DataSource from the registry, meaning if there is a only one instance of DataSource found, then this DataSource will be used.",
          "type" : "string"
        },
        "allow-named-parameters" : {
          "description" : "Whether to allow using named parameters in the queries.",
          "default" : "true",
          "type" : "boolean"
        },
        "bean-row-mapper" : {
          "description" : "To use a custom org.apache.camel.component.jdbc.BeanRowMapper when using outputClass. The default implementation will lower case the row names and skip underscores, and dashes. For example CUST_ID is mapped as custId.",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "output-class" : {
          "description" : "Specify the full package and class name to use as conversion when outputType=SelectOne or SelectList.",
          "type" : "string"
        },
        "output-type" : {
          "description" : "Determines the output the producer should use.",
          "default" : "SelectList",
          "enum" : [ "SelectOne", "SelectList", "StreamList" ],
          "type" : "string"
        },
        "parameters" : {
          "description" : "Optional parameters to the java.sql.Statement. For example to set maxRows, fetchSize etc.",
          "type" : "string"
        },
        "prepare-statement-strategy" : {
          "description" : "Allows the plugin to use a custom org.apache.camel.component.jdbc.JdbcPrepareStatementStrategy to control preparation of the query and prepared statement.",
          "type" : "string"
        },
        "read-size" : {
          "description" : "The default maximum number of rows that can be read by a polling query. The default value is 0.",
          "type" : "integer"
        },
        "reset-auto-commit" : {
          "description" : "Camel will set the autoCommit on the JDBC connection to be false, commit the change after executed the statement and reset the autoCommit flag of the connection at the end, if the resetAutoCommit is true. If the JDBC connection doesn't support to reset the autoCommit flag, you can set the resetAutoCommit flag to be false, and Camel will not try to reset the autoCommit flag. When used with XA transactions you most likely need to set it to false so that the transaction manager is in charge of committing this tx.",
          "default" : "true",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "transacted" : {
          "description" : "Whether transactions are in use.",
          "default" : "false",
          "type" : "boolean"
        },
        "use-get-bytes-for-blob" : {
          "description" : "To read BLOB columns as bytes instead of string data. This may be needed for certain databases such as Oracle where you must read BLOB columns as bytes.",
          "default" : "false",
          "type" : "boolean"
        },
        "use-headers-as-parameters" : {
          "description" : "Set this option to true to use the prepareStatementStrategy with named parameters. This allows to define queries with named placeholders, and use headers with the dynamic values for the query placeholders.",
          "default" : "false",
          "type" : "boolean"
        },
        "use-jdbc4-column-name-and-label-semantics" : {
          "description" : "Sets whether to use JDBC 4 or JDBC 3.0 or older semantic when retrieving column name. JDBC 4.0 uses columnLabel to get the column name where as JDBC 3.0 uses both columnName or columnLabel. Unfortunately JDBC drivers behave differently so you can use this option to work out issues around your JDBC driver if you get problem using this component This option is default true.",
          "default" : "true",
          "type" : "boolean"
        }
      }
    },
    "jetty" : {
      "type" : "object",
      "required" : [ "httpUri" ],
      "properties" : {
        "http-uri" : {
          "description" : "The url of the HTTP endpoint to call.",
          "type" : "string"
        },
        "async" : {
          "description" : "Configure the consumer to work in async mode",
          "default" : "false",
          "type" : "boolean"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "chunked" : {
          "description" : "If this option is false the Servlet will disable the HTTP streaming and set the content-length header on the response",
          "default" : "true",
          "type" : "boolean"
        },
        "continuation-timeout" : {
          "description" : "Allows to set a timeout in millis when using Jetty as consumer (server). By default Jetty uses 30000. You can use a value of = 0 to never expire. If a timeout occurs then the request will be expired and Jetty will return back a http error 503 to the client. This option is only in use when using Jetty with the Asynchronous Routing Engine.",
          "default" : "30000",
          "type" : "integer"
        },
        "disable-stream-cache" : {
          "description" : "Determines whether or not the raw input stream from Servlet is cached or not (Camel will read the stream into a in memory/overflow to file, Stream caching) cache. By default Camel will cache the Servlet input stream to support reading it multiple times to ensure it Camel can retrieve all data from the stream. However you can set this option to true when you for example need to access the raw stream, such as streaming it directly to a file or other persistent store. DefaultHttpBinding will copy the request input stream into a stream cache and put it into message body if this option is false to support reading the stream multiple times. If you use Servlet to bridge/proxy an endpoint then consider enabling this option to improve performance, in case you do not need to read the message payload multiple times. The http producer will by default cache the response body stream. If setting this option to true, then the producers will not cache the response body stream but use the response stream as-is as the message body.",
          "default" : "false",
          "type" : "boolean"
        },
        "eager-check-content-available" : {
          "description" : "Whether to eager check whether the HTTP requests has content if the content-length header is 0 or not present. This can be turned on in case HTTP clients do not send streamed data.",
          "default" : "false",
          "type" : "boolean"
        },
        "enable-cors" : {
          "description" : "If the option is true, Jetty server will setup the CrossOriginFilter which supports the CORS out of box.",
          "default" : "false",
          "type" : "boolean"
        },
        "enable-jmx" : {
          "description" : "If this option is true, Jetty JMX support will be enabled for this endpoint. See Jetty JMX support for more details.",
          "default" : "false",
          "type" : "boolean"
        },
        "enable-multipart-filter" : {
          "description" : "Whether org.apache.camel.component.jetty.MultiPartFilter is enabled or not. You should set this value to false when bridging endpoints, to ensure multipart requests is proxied/bridged as well.",
          "default" : "false",
          "type" : "boolean"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "filter-init-parameters" : {
          "description" : "Configuration of the filter init parameters. These parameters will be applied to the filter list before starting the jetty server.",
          "type" : "string"
        },
        "filters" : {
          "description" : "Allows using a custom filters which is putted into a list and can be find in the Registry. Multiple values can be separated by comma.",
          "type" : "string"
        },
        "handlers" : {
          "description" : "Specifies a comma-delimited set of Handler instances to lookup in your Registry. These handlers are added to the Jetty servlet context (for example, to add security). Important: You can not use different handlers with different Jetty endpoints using the same port number. The handlers is associated to the port number. If you need different handlers, then use different port numbers.",
          "type" : "string"
        },
        "header-filter-strategy" : {
          "description" : "To use a custom HeaderFilterStrategy to filter header to and from Camel message.",
          "type" : "string"
        },
        "http-binding" : {
          "description" : "To use a custom HttpBinding to control the mapping between Camel message and HttpClient.",
          "type" : "string"
        },
        "http-method-restrict" : {
          "description" : "Used to only allow consuming if the HttpMethod matches, such as GET/POST/PUT etc. Multiple methods can be specified separated by comma.",
          "type" : "string"
        },
        "map-http-message-body" : {
          "description" : "If this option is true then IN exchange Body of the exchange will be mapped to HTTP body. Setting this to false will avoid the HTTP mapping.",
          "default" : "true",
          "type" : "boolean"
        },
        "map-http-message-form-url-encoded-body" : {
          "description" : "If this option is true then IN exchange Form Encoded body of the exchange will be mapped to HTTP. Setting this to false will avoid the HTTP Form Encoded body mapping.",
          "default" : "true",
          "type" : "boolean"
        },
        "map-http-message-headers" : {
          "description" : "If this option is true then IN exchange Headers of the exchange will be mapped to HTTP headers. Setting this to false will avoid the HTTP Headers mapping.",
          "default" : "true",
          "type" : "boolean"
        },
        "match-on-uri-prefix" : {
          "description" : "Whether or not the consumer should try to find a target consumer by matching the URI prefix if no exact match is found.",
          "default" : "false",
          "type" : "boolean"
        },
        "multipart-filter" : {
          "description" : "Allows using a custom multipart filter. Note: setting multipartFilterRef forces the value of enableMultipartFilter to true.",
          "type" : "string"
        },
        "mute-exception" : {
          "description" : "If enabled and an Exchange failed processing on the consumer side the response's body won't contain the exception's stack trace.",
          "default" : "false",
          "type" : "boolean"
        },
        "options-enabled" : {
          "description" : "Specifies whether to enable HTTP OPTIONS for this Servlet consumer. By default OPTIONS is turned off.",
          "default" : "false",
          "type" : "boolean"
        },
        "response-buffer-size" : {
          "description" : "To use a custom buffer size on the javax.servlet.ServletResponse.",
          "type" : "integer"
        },
        "send-date-header" : {
          "description" : "If the option is true, jetty server will send the date header to the client which sends the request. NOTE please make sure there is no any other camel-jetty endpoint is share the same port, otherwise this option may not work as expected.",
          "default" : "false",
          "type" : "boolean"
        },
        "send-server-version" : {
          "description" : "If the option is true, jetty will send the server header with the jetty version information to the client which sends the request. NOTE please make sure there is no any other camel-jetty endpoint is share the same port, otherwise this option may not work as expected.",
          "default" : "true",
          "type" : "boolean"
        },
        "session-support" : {
          "description" : "Specifies whether to enable the session manager on the server side of Jetty.",
          "default" : "false",
          "type" : "boolean"
        },
        "ssl-context-parameters" : {
          "description" : "To configure security using SSLContextParameters",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "trace-enabled" : {
          "description" : "Specifies whether to enable HTTP TRACE for this Servlet consumer. By default TRACE is turned off.",
          "default" : "false",
          "type" : "boolean"
        },
        "transfer-exception" : {
          "description" : "If enabled and an Exchange failed processing on the consumer side, and if the caused Exception was send back serialized in the response as a application/x-java-serialized-object content type. On the producer side the exception will be deserialized and thrown as is, instead of the HttpOperationFailedException. The caused exception is required to be serialized. This is by default turned off. If you enable this then be aware that Java will deserialize the incoming data from the request to Java and that can be a potential security risk.",
          "default" : "false",
          "type" : "boolean"
        },
        "use-continuation" : {
          "description" : "Whether or not to use Jetty continuations for the Jetty Server.",
          "type" : "boolean"
        }
      }
    },
    "jgroups" : {
      "type" : "object",
      "required" : [ "clusterName" ],
      "properties" : {
        "cluster-name" : {
          "description" : "The name of the JGroups cluster the component should connect to.",
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "channel-properties" : {
          "description" : "Specifies configuration properties of the JChannel used by the endpoint.",
          "type" : "string"
        },
        "enable-view-messages" : {
          "description" : "If set to true, the consumer endpoint will receive org.jgroups.View messages as well (not only org.jgroups.Message instances). By default only regular messages are consumed by the endpoint.",
          "default" : "false",
          "type" : "boolean"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "jgroups-raft" : {
      "type" : "object",
      "required" : [ "clusterName" ],
      "properties" : {
        "cluster-name" : {
          "description" : "The name of the JGroupsraft cluster the component should connect to.",
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "enable-role-change-events" : {
          "description" : "If set to true, the consumer endpoint will receive roleChange event as well (not just connecting and/or using the state machine). By default it is set to false.",
          "default" : "false",
          "type" : "boolean"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "jing" : {
      "type" : "object",
      "required" : [ "resourceUri" ],
      "properties" : {
        "resource-uri" : {
          "description" : "URL to a local resource on the classpath or a full URL to a remote resource or resource on the file system which contains the schema to validate against.",
          "type" : "string"
        },
        "compact-syntax" : {
          "description" : "Whether to validate using RelaxNG compact syntax or not. By default this is false for using RelaxNG XML Syntax (rng) And true is for using RelaxNG Compact Syntax (rnc)",
          "default" : "false",
          "type" : "boolean"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "jira" : {
      "type" : "object",
      "required" : [ "type", "jiraUrl" ],
      "properties" : {
        "type" : {
          "description" : "Operation to perform. Consumers: NewIssues, NewComments. Producers: AddIssue, AttachFile, DeleteIssue, TransitionIssue, UpdateIssue, Watchers. See this class javadoc description for more information.",
          "enum" : [ "ADDCOMMENT", "ADDISSUE", "ATTACH", "DELETEISSUE", "NEWISSUES", "NEWCOMMENTS", "WATCHUPDATES", "UPDATEISSUE", "TRANSITIONISSUE", "WATCHERS", "ADDISSUELINK", "ADDWORKLOG", "FETCHISSUE", "FETCHCOMMENTS" ],
          "type" : "string"
        },
        "access-token" : {
          "description" : "(OAuth only) The access token generated by the Jira server.",
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "consumer-key" : {
          "description" : "(OAuth only) The consumer key from Jira settings.",
          "type" : "string"
        },
        "delay" : {
          "description" : "Time in milliseconds to elapse for the next poll.",
          "default" : "6000",
          "type" : "integer"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "jira-url" : {
          "description" : "The Jira server url, example: http://my_jira.com:8081",
          "type" : "string"
        },
        "jql" : {
          "description" : "JQL is the query language from JIRA which allows you to retrieve the data you want. For example jql=project=MyProject Where MyProject is the product key in Jira. It is important to use the RAW() and set the JQL inside it to prevent camel parsing it, example: RAW(project in (MYP, COM) AND resolution = Unresolved)",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "max-results" : {
          "description" : "Max number of issues to search for",
          "default" : "50",
          "type" : "integer"
        },
        "password" : {
          "description" : "(Basic authentication only) The password to authenticate to the Jira server. Use only if username basic authentication is used.",
          "type" : "string"
        },
        "private-key" : {
          "description" : "(OAuth only) The private key generated by the client to encrypt the conversation to the server.",
          "type" : "string"
        },
        "send-only-updated-field" : {
          "description" : "Indicator for sending only changed fields in exchange body or issue object. By default consumer sends only changed fields.",
          "default" : "true",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "username" : {
          "description" : "(Basic authentication only) The username to authenticate to the Jira server. Use only if OAuth is not enabled on the Jira server. Do not set the username and OAuth token parameter, if they are both set, the username basic authentication takes precedence.",
          "type" : "string"
        },
        "verification-code" : {
          "description" : "(OAuth only) The verification code from Jira generated in the first step of the authorization proccess.",
          "type" : "string"
        },
        "watched-fields" : {
          "description" : "Comma separated list of fields to watch for changes. Status,Priority are the defaults.",
          "default" : "Status,Priority",
          "type" : "string"
        }
      }
    },
    "jms" : {
      "type" : "object",
      "required" : [ "destinationName" ],
      "properties" : {
        "destination-name" : {
          "description" : "Name of the queue or topic to use as destination",
          "type" : "string"
        },
        "destination-type" : {
          "description" : "The kind of destination to use",
          "default" : "queue",
          "enum" : [ "queue", "topic", "temp-queue", "temp-topic" ],
          "type" : "string"
        },
        "accept-messages-while-stopping" : {
          "description" : "Specifies whether the consumer accept messages while it is stopping. You may consider enabling this option, if you start and stop JMS routes at runtime, while there are still messages enqueued on the queue. If this option is false, and you stop the JMS route, then messages may be rejected, and the JMS broker would have to attempt redeliveries, which yet again may be rejected, and eventually the message may be moved at a dead letter queue on the JMS broker. To avoid this its recommended to enable this option.",
          "default" : "false",
          "type" : "boolean"
        },
        "acknowledgement-mode-name" : {
          "description" : "The JMS acknowledgement name, which is one of: SESSION_TRANSACTED, CLIENT_ACKNOWLEDGE, AUTO_ACKNOWLEDGE, DUPS_OK_ACKNOWLEDGE",
          "default" : "AUTO_ACKNOWLEDGE",
          "enum" : [ "SESSION_TRANSACTED", "CLIENT_ACKNOWLEDGE", "AUTO_ACKNOWLEDGE", "DUPS_OK_ACKNOWLEDGE" ],
          "type" : "string"
        },
        "allow-additional-headers" : {
          "description" : "This option is used to allow additional headers which may have values that are invalid according to JMS specification. For example some message systems such as WMQ do this with header names using prefix JMS_IBM_MQMD_ containing values with byte array or other invalid types. You can specify multiple header names separated by comma, and use as suffix for wildcard matching.",
          "type" : "string"
        },
        "allow-null-body" : {
          "description" : "Whether to allow sending messages with no body. If this option is false and the message body is null, then an JMSException is thrown.",
          "default" : "true",
          "type" : "boolean"
        },
        "allow-reply-manager-quick-stop" : {
          "description" : "Whether the DefaultMessageListenerContainer used in the reply managers for request-reply messaging allow the DefaultMessageListenerContainer.runningAllowed flag to quick stop in case JmsConfiguration#isAcceptMessagesWhileStopping is enabled, and org.apache.camel.CamelContext is currently being stopped. This quick stop ability is enabled by default in the regular JMS consumers but to enable for reply managers you must enable this flag.",
          "default" : "false",
          "type" : "boolean"
        },
        "allow-serialized-headers" : {
          "description" : "Controls whether or not to include serialized headers. Applies only when transferExchange is true. This requires that the objects are serializable. Camel will exclude any non-serializable objects and log it at WARN level.",
          "default" : "false",
          "type" : "boolean"
        },
        "always-copy-message" : {
          "description" : "If true, Camel will always make a JMS message copy of the message when it is passed to the producer for sending. Copying the message is needed in some situations, such as when a replyToDestinationSelectorName is set (incidentally, Camel will set the alwaysCopyMessage option to true, if a replyToDestinationSelectorName is set)",
          "default" : "false",
          "type" : "boolean"
        },
        "artemis-streaming-enabled" : {
          "description" : "Whether optimizing for Apache Artemis streaming mode.",
          "default" : "true",
          "type" : "boolean"
        },
        "async-consumer" : {
          "description" : "Whether the JmsConsumer processes the Exchange asynchronously. If enabled then the JmsConsumer may pickup the next message from the JMS queue, while the previous message is being processed asynchronously (by the Asynchronous Routing Engine). This means that messages may be processed not 100% strictly in order. If disabled (as default) then the Exchange is fully processed before the JmsConsumer will pickup the next message from the JMS queue. Note if transacted has been enabled, then asyncConsumer=true does not run asynchronously, as transaction must be executed synchronously (Camel 3.0 may support async transactions).",
          "default" : "false",
          "type" : "boolean"
        },
        "async-start-listener" : {
          "description" : "Whether to startup the JmsConsumer message listener asynchronously, when starting a route. For example if a JmsConsumer cannot get a connection to a remote JMS broker, then it may block while retrying and/or failover. This will cause Camel to block while starting routes. By setting this option to true, you will let routes startup, while the JmsConsumer connects to the JMS broker using a dedicated thread in asynchronous mode. If this option is used, then beware that if the connection could not be established, then an exception is logged at WARN level, and the consumer will not be able to receive messages; You can then restart the route to retry.",
          "default" : "false",
          "type" : "boolean"
        },
        "async-stop-listener" : {
          "description" : "Whether to stop the JmsConsumer message listener asynchronously, when stopping a route.",
          "default" : "false",
          "type" : "boolean"
        },
        "auto-startup" : {
          "description" : "Specifies whether the consumer container should auto-startup.",
          "default" : "true",
          "type" : "boolean"
        },
        "cache-level" : {
          "description" : "Sets the cache level by ID for the underlying JMS resources. See cacheLevelName option for more details.",
          "type" : "integer"
        },
        "cache-level-name" : {
          "description" : "Sets the cache level by name for the underlying JMS resources. Possible values are: CACHE_AUTO, CACHE_CONNECTION, CACHE_CONSUMER, CACHE_NONE, and CACHE_SESSION. The default setting is CACHE_AUTO. See the Spring documentation and Transactions Cache Levels for more information.",
          "default" : "CACHE_AUTO",
          "enum" : [ "CACHE_AUTO", "CACHE_CONNECTION", "CACHE_CONSUMER", "CACHE_NONE", "CACHE_SESSION" ],
          "type" : "string"
        },
        "client-id" : {
          "description" : "Sets the JMS client ID to use. Note that this value, if specified, must be unique and can only be used by a single JMS connection instance. It is typically only required for durable topic subscriptions. If using Apache ActiveMQ you may prefer to use Virtual Topics instead.",
          "type" : "string"
        },
        "concurrent-consumers" : {
          "description" : "Specifies the default number of concurrent consumers when consuming from JMS (not for request/reply over JMS). See also the maxMessagesPerTask option to control dynamic scaling up/down of threads. When doing request/reply over JMS then the option replyToConcurrentConsumers is used to control number of concurrent consumers on the reply message listener.",
          "default" : "1",
          "type" : "integer"
        },
        "connection-factory" : {
          "description" : "The connection factory to be use. A connection factory must be configured either on the component or endpoint.",
          "type" : "string"
        },
        "consumer-type" : {
          "description" : "The consumer type to use, which can be one of: Simple, Default, or Custom. The consumer type determines which Spring JMS listener to use. Default will use org.springframework.jms.listener.DefaultMessageListenerContainer, Simple will use org.springframework.jms.listener.SimpleMessageListenerContainer. When Custom is specified, the MessageListenerContainerFactory defined by the messageListenerContainerFactory option will determine what org.springframework.jms.listener.AbstractMessageListenerContainer to use.",
          "default" : "Default",
          "enum" : [ "Simple", "Default", "Custom" ],
          "type" : "string"
        },
        "correlation-property" : {
          "description" : "When using InOut exchange pattern use this JMS property instead of JMSCorrelationID JMS property to correlate messages. If set messages will be correlated solely on the value of this property JMSCorrelationID property will be ignored and not set by Camel.",
          "type" : "string"
        },
        "default-task-executor-type" : {
          "description" : "Specifies what default TaskExecutor type to use in the DefaultMessageListenerContainer, for both consumer endpoints and the ReplyTo consumer of producer endpoints. Possible values: SimpleAsync (uses Spring's SimpleAsyncTaskExecutor) or ThreadPool (uses Spring's ThreadPoolTaskExecutor with optimal values - cached threadpool-like). If not set, it defaults to the previous behaviour, which uses a cached thread pool for consumer endpoints and SimpleAsync for reply consumers. The use of ThreadPool is recommended to reduce thread trash in elastic configurations with dynamically increasing and decreasing concurrent consumers.",
          "enum" : [ "ThreadPool", "SimpleAsync" ],
          "type" : "string"
        },
        "delivery-delay" : {
          "description" : "Sets delivery delay to use for send calls for JMS. This option requires JMS 2.0 compliant broker.",
          "default" : "-1",
          "type" : "integer"
        },
        "delivery-mode" : {
          "description" : "Specifies the delivery mode to be used. Possible values are those defined by javax.jms.DeliveryMode. NON_PERSISTENT = 1 and PERSISTENT = 2.",
          "enum" : [ "1", "2" ],
          "type" : "integer"
        },
        "delivery-persistent" : {
          "description" : "Specifies whether persistent delivery is used by default.",
          "default" : "true",
          "type" : "boolean"
        },
        "destination-resolver" : {
          "description" : "A pluggable org.springframework.jms.support.destination.DestinationResolver that allows you to use your own resolver (for example, to lookup the real destination in a JNDI registry).",
          "type" : "string"
        },
        "disable-reply-to" : {
          "description" : "Specifies whether Camel ignores the JMSReplyTo header in messages. If true, Camel does not send a reply back to the destination specified in the JMSReplyTo header. You can use this option if you want Camel to consume from a route and you do not want Camel to automatically send back a reply message because another component in your code handles the reply message. You can also use this option if you want to use Camel as a proxy between different message brokers and you want to route message from one system to another.",
          "default" : "false",
          "type" : "boolean"
        },
        "disable-time-to-live" : {
          "description" : "Use this option to force disabling time to live. For example when you do request/reply over JMS, then Camel will by default use the requestTimeout value as time to live on the message being sent. The problem is that the sender and receiver systems have to have their clocks synchronized, so they are in sync. This is not always so easy to archive. So you can use disableTimeToLive=true to not set a time to live value on the sent message. Then the message will not expire on the receiver system. See below in section About time to live for more details.",
          "default" : "false",
          "type" : "boolean"
        },
        "durable-subscription-name" : {
          "description" : "The durable subscriber name for specifying durable topic subscriptions. The clientId option must be configured as well.",
          "type" : "string"
        },
        "eager-loading-of-properties" : {
          "description" : "Enables eager loading of JMS properties and payload as soon as a message is loaded which generally is inefficient as the JMS properties may not be required but sometimes can catch early any issues with the underlying JMS provider and the use of JMS properties. See also the option eagerPoisonBody.",
          "default" : "false",
          "type" : "boolean"
        },
        "eager-poison-body" : {
          "description" : "If eagerLoadingOfProperties is enabled and the JMS message payload (JMS body or JMS properties) is poison (cannot be read/mapped), then set this text as the message body instead so the message can be processed (the cause of the poison are already stored as exception on the Exchange). This can be turned off by setting eagerPoisonBody=false. See also the option eagerLoadingOfProperties.",
          "default" : "Poison JMS message due to ${exception.message}",
          "type" : "string"
        },
        "error-handler" : {
          "description" : "Specifies a org.springframework.util.ErrorHandler to be invoked in case of any uncaught exceptions thrown while processing a Message. By default these exceptions will be logged at the WARN level, if no errorHandler has been configured. You can configure logging level and whether stack traces should be logged using errorHandlerLoggingLevel and errorHandlerLogStackTrace options. This makes it much easier to configure, than having to code a custom errorHandler.",
          "type" : "string"
        },
        "error-handler-log-stack-trace" : {
          "description" : "Allows to control whether stacktraces should be logged or not, by the default errorHandler.",
          "default" : "true",
          "type" : "boolean"
        },
        "error-handler-logging-level" : {
          "description" : "Allows to configure the default errorHandler logging level for logging uncaught exceptions.",
          "default" : "WARN",
          "enum" : [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ],
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exception-listener" : {
          "description" : "Specifies the JMS Exception Listener that is to be notified of any underlying JMS exceptions.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "explicit-qos-enabled" : {
          "description" : "Set if the deliveryMode, priority or timeToLive qualities of service should be used when sending messages. This option is based on Spring's JmsTemplate. The deliveryMode, priority and timeToLive options are applied to the current endpoint. This contrasts with the preserveMessageQos option, which operates at message granularity, reading QoS properties exclusively from the Camel In message headers.",
          "default" : "false",
          "type" : "boolean"
        },
        "expose-listener-session" : {
          "description" : "Specifies whether the listener session should be exposed when consuming messages.",
          "default" : "false",
          "type" : "boolean"
        },
        "force-send-original-message" : {
          "description" : "When using mapJmsMessage=false Camel will create a new JMS message to send to a new JMS destination if you touch the headers (get or set) during the route. Set this option to true to force Camel to send the original JMS message that was received.",
          "default" : "false",
          "type" : "boolean"
        },
        "format-date-headers-to-iso8601" : {
          "description" : "Sets whether JMS date properties should be formatted according to the ISO 8601 standard.",
          "default" : "false",
          "type" : "boolean"
        },
        "header-filter-strategy" : {
          "description" : "To use a custom HeaderFilterStrategy to filter header to and from Camel message.",
          "type" : "string"
        },
        "idle-consumer-limit" : {
          "description" : "Specify the limit for the number of consumers that are allowed to be idle at any given time.",
          "default" : "1",
          "type" : "integer"
        },
        "idle-task-execution-limit" : {
          "description" : "Specifies the limit for idle executions of a receive task, not having received any message within its execution. If this limit is reached, the task will shut down and leave receiving to other executing tasks (in the case of dynamic scheduling; see the maxConcurrentConsumers setting). There is additional doc available from Spring.",
          "default" : "1",
          "type" : "integer"
        },
        "include-all-jmsx-properties" : {
          "description" : "Whether to include all JMSXxxx properties when mapping from JMS to Camel Message. Setting this to true will include properties such as JMSXAppID, and JMSXUserID etc. Note: If you are using a custom headerFilterStrategy then this option does not apply.",
          "default" : "false",
          "type" : "boolean"
        },
        "include-sent-jms-message-id" : {
          "description" : "Only applicable when sending to JMS destination using InOnly (eg fire and forget). Enabling this option will enrich the Camel Exchange with the actual JMSMessageID that was used by the JMS client when the message was sent to the JMS destination.",
          "default" : "false",
          "type" : "boolean"
        },
        "jms-key-format-strategy" : {
          "description" : "Pluggable strategy for encoding and decoding JMS keys so they can be compliant with the JMS specification. Camel provides two implementations out of the box: default and passthrough. The default strategy will safely marshal dots and hyphens (. and -). The passthrough strategy leaves the key as is. Can be used for JMS brokers which do not care whether JMS header keys contain illegal characters. You can provide your own implementation of the org.apache.camel.component.jms.JmsKeyFormatStrategy and refer to it using the # notation.",
          "enum" : [ "default", "passthrough" ],
          "type" : "string"
        },
        "jms-message-type" : {
          "description" : "Allows you to force the use of a specific javax.jms.Message implementation for sending JMS messages. Possible values are: Bytes, Map, Object, Stream, Text. By default, Camel would determine which JMS message type to use from the In body type. This option allows you to specify it.",
          "enum" : [ "Bytes", "Map", "Object", "Stream", "Text" ],
          "type" : "string"
        },
        "lazy-create-transaction-manager" : {
          "description" : "If true, Camel will create a JmsTransactionManager, if there is no transactionManager injected when option transacted=true.",
          "default" : "true",
          "type" : "boolean"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "map-jms-message" : {
          "description" : "Specifies whether Camel should auto map the received JMS message to a suited payload type, such as javax.jms.TextMessage to a String etc.",
          "default" : "true",
          "type" : "boolean"
        },
        "max-concurrent-consumers" : {
          "description" : "Specifies the maximum number of concurrent consumers when consuming from JMS (not for request/reply over JMS). See also the maxMessagesPerTask option to control dynamic scaling up/down of threads. When doing request/reply over JMS then the option replyToMaxConcurrentConsumers is used to control number of concurrent consumers on the reply message listener.",
          "type" : "integer"
        },
        "max-messages-per-task" : {
          "description" : "The number of messages per task. -1 is unlimited. If you use a range for concurrent consumers (eg min max), then this option can be used to set a value to eg 100 to control how fast the consumers will shrink when less work is required.",
          "default" : "-1",
          "type" : "integer"
        },
        "message-converter" : {
          "description" : "To use a custom Spring org.springframework.jms.support.converter.MessageConverter so you can be in control how to map to/from a javax.jms.Message.",
          "type" : "string"
        },
        "message-created-strategy" : {
          "description" : "To use the given MessageCreatedStrategy which are invoked when Camel creates new instances of javax.jms.Message objects when Camel is sending a JMS message.",
          "type" : "string"
        },
        "message-id-enabled" : {
          "description" : "When sending, specifies whether message IDs should be added. This is just an hint to the JMS broker. If the JMS provider accepts this hint, these messages must have the message ID set to null; if the provider ignores the hint, the message ID must be set to its normal unique value.",
          "default" : "true",
          "type" : "boolean"
        },
        "message-listener-container-factory" : {
          "description" : "Registry ID of the MessageListenerContainerFactory used to determine what org.springframework.jms.listener.AbstractMessageListenerContainer to use to consume messages. Setting this will automatically set consumerType to Custom.",
          "type" : "string"
        },
        "message-timestamp-enabled" : {
          "description" : "Specifies whether timestamps should be enabled by default on sending messages. This is just an hint to the JMS broker. If the JMS provider accepts this hint, these messages must have the timestamp set to zero; if the provider ignores the hint the timestamp must be set to its normal value.",
          "default" : "true",
          "type" : "boolean"
        },
        "password" : {
          "description" : "Password to use with the ConnectionFactory. You can also configure username/password directly on the ConnectionFactory.",
          "type" : "string"
        },
        "preserve-message-qos" : {
          "description" : "Set to true, if you want to send message using the QoS settings specified on the message, instead of the QoS settings on the JMS endpoint. The following three headers are considered JMSPriority, JMSDeliveryMode, and JMSExpiration. You can provide all or only some of them. If not provided, Camel will fall back to use the values from the endpoint instead. So, when using this option, the headers override the values from the endpoint. The explicitQosEnabled option, by contrast, will only use options set on the endpoint, and not values from the message header.",
          "default" : "false",
          "type" : "boolean"
        },
        "priority" : {
          "description" : "Values greater than 1 specify the message priority when sending (where 0 is the lowest priority and 9 is the highest). The explicitQosEnabled option must also be enabled in order for this option to have any effect.",
          "default" : "4",
          "enum" : [ "1", "2", "3", "4", "5", "6", "7", "8", "9" ],
          "type" : "integer"
        },
        "pub-sub-no-local" : {
          "description" : "Specifies whether to inhibit the delivery of messages published by its own connection.",
          "default" : "false",
          "type" : "boolean"
        },
        "receive-timeout" : {
          "description" : "The timeout for receiving messages (in milliseconds).",
          "default" : "1000",
          "type" : "string"
        },
        "recovery-interval" : {
          "description" : "Specifies the interval between recovery attempts, i.e. when a connection is being refreshed, in milliseconds. The default is 5000 ms, that is, 5 seconds.",
          "default" : "5000",
          "type" : "string"
        },
        "reply-to" : {
          "description" : "Provides an explicit ReplyTo destination (overrides any incoming value of Message.getJMSReplyTo() in consumer).",
          "type" : "string"
        },
        "reply-to-cache-level-name" : {
          "description" : "Sets the cache level by name for the reply consumer when doing request/reply over JMS. This option only applies when using fixed reply queues (not temporary). Camel will by default use: CACHE_CONSUMER for exclusive or shared w/ replyToSelectorName. And CACHE_SESSION for shared without replyToSelectorName. Some JMS brokers such as IBM WebSphere may require to set the replyToCacheLevelName=CACHE_NONE to work. Note: If using temporary queues then CACHE_NONE is not allowed, and you must use a higher value such as CACHE_CONSUMER or CACHE_SESSION.",
          "enum" : [ "CACHE_AUTO", "CACHE_CONNECTION", "CACHE_CONSUMER", "CACHE_NONE", "CACHE_SESSION" ],
          "type" : "string"
        },
        "reply-to-concurrent-consumers" : {
          "description" : "Specifies the default number of concurrent consumers when doing request/reply over JMS. See also the maxMessagesPerTask option to control dynamic scaling up/down of threads.",
          "default" : "1",
          "type" : "integer"
        },
        "reply-to-delivery-persistent" : {
          "description" : "Specifies whether to use persistent delivery by default for replies.",
          "default" : "true",
          "type" : "boolean"
        },
        "reply-to-destination-selector-name" : {
          "description" : "Sets the JMS Selector using the fixed name to be used so you can filter out your own replies from the others when using a shared queue (that is, if you are not using a temporary reply queue).",
          "type" : "string"
        },
        "reply-to-max-concurrent-consumers" : {
          "description" : "Specifies the maximum number of concurrent consumers when using request/reply over JMS. See also the maxMessagesPerTask option to control dynamic scaling up/down of threads.",
          "type" : "integer"
        },
        "reply-to-on-timeout-max-concurrent-consumers" : {
          "description" : "Specifies the maximum number of concurrent consumers for continue routing when timeout occurred when using request/reply over JMS.",
          "default" : "1",
          "type" : "integer"
        },
        "reply-to-override" : {
          "description" : "Provides an explicit ReplyTo destination in the JMS message, which overrides the setting of replyTo. It is useful if you want to forward the message to a remote Queue and receive the reply message from the ReplyTo destination.",
          "type" : "string"
        },
        "reply-to-same-destination-allowed" : {
          "description" : "Whether a JMS consumer is allowed to send a reply message to the same destination that the consumer is using to consume from. This prevents an endless loop by consuming and sending back the same message to itself.",
          "default" : "false",
          "type" : "boolean"
        },
        "reply-to-type" : {
          "description" : "Allows for explicitly specifying which kind of strategy to use for replyTo queues when doing request/reply over JMS. Possible values are: Temporary, Shared, or Exclusive. By default Camel will use temporary queues. However if replyTo has been configured, then Shared is used by default. This option allows you to use exclusive queues instead of shared ones. See Camel JMS documentation for more details, and especially the notes about the implications if running in a clustered environment, and the fact that Shared reply queues has lower performance than its alternatives Temporary and Exclusive.",
          "enum" : [ "Temporary", "Shared", "Exclusive" ],
          "type" : "string"
        },
        "request-timeout" : {
          "description" : "The timeout for waiting for a reply when using the InOut Exchange Pattern (in milliseconds). The default is 20 seconds. You can include the header CamelJmsRequestTimeout to override this endpoint configured timeout value, and thus have per message individual timeout values. See also the requestTimeoutCheckerInterval option.",
          "default" : "20000",
          "type" : "string"
        },
        "request-timeout-checker-interval" : {
          "description" : "Configures how often Camel should check for timed out Exchanges when doing request/reply over JMS. By default Camel checks once per second. But if you must react faster when a timeout occurs, then you can lower this interval, to check more frequently. The timeout is determined by the option requestTimeout.",
          "default" : "1000",
          "type" : "string"
        },
        "selector" : {
          "description" : "Sets the JMS selector to use",
          "type" : "string"
        },
        "stream-message-type-enabled" : {
          "description" : "Sets whether StreamMessage type is enabled or not. Message payloads of streaming kind such as files, InputStream, etc will either by sent as BytesMessage or StreamMessage. This option controls which kind will be used. By default BytesMessage is used which enforces the entire message payload to be read into memory. By enabling this option the message payload is read into memory in chunks and each chunk is then written to the StreamMessage until no more data.",
          "default" : "false",
          "type" : "boolean"
        },
        "subscription-durable" : {
          "description" : "Set whether to make the subscription durable. The durable subscription name to be used can be specified through the subscriptionName property. Default is false. Set this to true to register a durable subscription, typically in combination with a subscriptionName value (unless your message listener class name is good enough as subscription name). Only makes sense when listening to a topic (pub-sub domain), therefore this method switches the pubSubDomain flag as well.",
          "default" : "false",
          "type" : "boolean"
        },
        "subscription-name" : {
          "description" : "Set the name of a subscription to create. To be applied in case of a topic (pub-sub domain) with a shared or durable subscription. The subscription name needs to be unique within this client's JMS client id. Default is the class name of the specified message listener. Note: Only 1 concurrent consumer (which is the default of this message listener container) is allowed for each subscription, except for a shared subscription (which requires JMS 2.0).",
          "type" : "string"
        },
        "subscription-shared" : {
          "description" : "Set whether to make the subscription shared. The shared subscription name to be used can be specified through the subscriptionName property. Default is false. Set this to true to register a shared subscription, typically in combination with a subscriptionName value (unless your message listener class name is good enough as subscription name). Note that shared subscriptions may also be durable, so this flag can (and often will) be combined with subscriptionDurable as well. Only makes sense when listening to a topic (pub-sub domain), therefore this method switches the pubSubDomain flag as well. Requires a JMS 2.0 compatible message broker.",
          "default" : "false",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "task-executor" : {
          "description" : "Allows you to specify a custom task executor for consuming messages.",
          "type" : "string"
        },
        "test-connection-on-startup" : {
          "description" : "Specifies whether to test the connection on startup. This ensures that when Camel starts that all the JMS consumers have a valid connection to the JMS broker. If a connection cannot be granted then Camel throws an exception on startup. This ensures that Camel is not started with failed connections. The JMS producers is tested as well.",
          "default" : "false",
          "type" : "boolean"
        },
        "time-to-live" : {
          "description" : "When sending messages, specifies the time-to-live of the message (in milliseconds).",
          "default" : "-1",
          "type" : "integer"
        },
        "transacted" : {
          "description" : "Specifies whether to use transacted mode",
          "default" : "false",
          "type" : "boolean"
        },
        "transacted-in-out" : {
          "description" : "Specifies whether InOut operations (request reply) default to using transacted mode If this flag is set to true, then Spring JmsTemplate will have sessionTransacted set to true, and the acknowledgeMode as transacted on the JmsTemplate used for InOut operations. Note from Spring JMS: that within a JTA transaction, the parameters passed to createQueue, createTopic methods are not taken into account. Depending on the Java EE transaction context, the container makes its own decisions on these values. Analogously, these parameters are not taken into account within a locally managed transaction either, since Spring JMS operates on an existing JMS Session in this case. Setting this flag to true will use a short local JMS transaction when running outside of a managed transaction, and a synchronized local JMS transaction in case of a managed transaction (other than an XA transaction) being present. This has the effect of a local JMS transaction being managed alongside the main transaction (which might be a native JDBC transaction), with the JMS transaction committing right after the main transaction.",
          "default" : "false",
          "type" : "boolean"
        },
        "transaction-manager" : {
          "description" : "The Spring transaction manager to use.",
          "type" : "string"
        },
        "transaction-name" : {
          "description" : "The name of the transaction to use.",
          "type" : "string"
        },
        "transaction-timeout" : {
          "description" : "The timeout value of the transaction (in seconds), if using transacted mode.",
          "default" : "-1",
          "type" : "integer"
        },
        "transfer-exception" : {
          "description" : "If enabled and you are using Request Reply messaging (InOut) and an Exchange failed on the consumer side, then the caused Exception will be send back in response as a javax.jms.ObjectMessage. If the client is Camel, the returned Exception is rethrown. This allows you to use Camel JMS as a bridge in your routing - for example, using persistent queues to enable robust routing. Notice that if you also have transferExchange enabled, this option takes precedence. The caught exception is required to be serializable. The original Exception on the consumer side can be wrapped in an outer exception such as org.apache.camel.RuntimeCamelException when returned to the producer. Use this with caution as the data is using Java Object serialization and requires the received to be able to deserialize the data at Class level, which forces a strong coupling between the producers and consumer!",
          "default" : "false",
          "type" : "boolean"
        },
        "transfer-exchange" : {
          "description" : "You can transfer the exchange over the wire instead of just the body and headers. The following fields are transferred: In body, Out body, Fault body, In headers, Out headers, Fault headers, exchange properties, exchange exception. This requires that the objects are serializable. Camel will exclude any non-serializable objects and log it at WARN level. You must enable this option on both the producer and consumer side, so Camel knows the payloads is an Exchange and not a regular payload. Use this with caution as the data is using Java Object serialization and requires the received to be able to deserialize the data at Class level, which forces a strong coupling between the producers and consumer having to use compatible Camel versions!",
          "default" : "false",
          "type" : "boolean"
        },
        "use-message-id-as-correlation-id" : {
          "description" : "Specifies whether JMSMessageID should always be used as JMSCorrelationID for InOut messages.",
          "default" : "false",
          "type" : "boolean"
        },
        "username" : {
          "description" : "Username to use with the ConnectionFactory. You can also configure username/password directly on the ConnectionFactory.",
          "type" : "string"
        },
        "wait-for-provision-correlation-to-be-updated-counter" : {
          "description" : "Number of times to wait for provisional correlation id to be updated to the actual correlation id when doing request/reply over JMS and when the option useMessageIDAsCorrelationID is enabled.",
          "default" : "50",
          "type" : "integer"
        },
        "wait-for-provision-correlation-to-be-updated-thread-sleeping-time" : {
          "description" : "Interval in millis to sleep each time while waiting for provisional correlation id to be updated.",
          "default" : "100",
          "type" : "string"
        }
      }
    },
    "jmx" : {
      "type" : "object",
      "properties" : {
        "server-url" : {
          "description" : "Server url comes from the remaining endpoint. Use platform to connect to local JVM.",
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "difference-mode" : {
          "description" : "If true, then the value reported in the notification is the difference from the threshold as opposed to the value itself (counter and gauge monitor only).",
          "default" : "false",
          "type" : "boolean"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "executor-service" : {
          "description" : "To use a custom shared thread pool for the consumers. By default each consume has their own thread-pool to process and route notifications.",
          "type" : "string"
        },
        "format" : {
          "description" : "Format for the message body. Either xml or raw. If xml, the notification is serialized to xml. If raw, then the raw java object is set as the body.",
          "default" : "xml",
          "enum" : [ "xml", "raw" ],
          "type" : "string"
        },
        "granularity-period" : {
          "description" : "The frequency to poll the bean to check the monitor (monitor types only).",
          "default" : "10000",
          "type" : "string"
        },
        "handback" : {
          "description" : "Value to handback to the listener when a notification is received. This value will be put in the message header with the key jmx.handback",
          "type" : "string"
        },
        "init-threshold" : {
          "description" : "Initial threshold for the monitor. The value must exceed this before notifications are fired (counter monitor only).",
          "type" : "integer"
        },
        "modulus" : {
          "description" : "The value at which the counter is reset to zero (counter monitor only).",
          "type" : "integer"
        },
        "monitor-type" : {
          "description" : "The type of monitor to create. One of string, gauge, counter (monitor types only).",
          "enum" : [ "counter", "gauge", "string" ],
          "type" : "string"
        },
        "notification-filter" : {
          "description" : "Reference to a bean that implements the NotificationFilter.",
          "type" : "string"
        },
        "notify-differ" : {
          "description" : "If true, will fire a notification when the string attribute differs from the string to compare (string monitor or consumer). By default the consumer will notify match if observed attribute and string to compare has been configured.",
          "default" : "false",
          "type" : "boolean"
        },
        "notify-high" : {
          "description" : "If true, the gauge will fire a notification when the high threshold is exceeded (gauge monitor only).",
          "default" : "false",
          "type" : "boolean"
        },
        "notify-low" : {
          "description" : "If true, the gauge will fire a notification when the low threshold is exceeded (gauge monitor only).",
          "default" : "false",
          "type" : "boolean"
        },
        "notify-match" : {
          "description" : "If true, will fire a notification when the string attribute matches the string to compare (string monitor or consumer). By default the consumer will notify match if observed attribute and string to compare has been configured.",
          "default" : "false",
          "type" : "boolean"
        },
        "object-domain" : {
          "description" : "The domain for the mbean you're connecting to",
          "type" : "string"
        },
        "object-name" : {
          "description" : "The name key for the mbean you're connecting to. This value is mutually exclusive with the object properties that get passed.",
          "type" : "string"
        },
        "object-properties" : {
          "description" : "Properties for the object name. These values will be used if the objectName param is not set",
          "type" : "string"
        },
        "observed-attribute" : {
          "description" : "The attribute to observe for the monitor bean or consumer.",
          "type" : "string"
        },
        "offset" : {
          "description" : "The amount to increment the threshold after it's been exceeded (counter monitor only).",
          "type" : "integer"
        },
        "password" : {
          "description" : "Credentials for making a remote connection",
          "type" : "string"
        },
        "reconnect-delay" : {
          "description" : "The number of seconds to wait before attempting to retry establishment of the initial connection or attempt to reconnect a lost connection",
          "default" : "10",
          "type" : "integer"
        },
        "reconnect-on-connection-failure" : {
          "description" : "If true the consumer will attempt to reconnect to the JMX server when any connection failure occurs. The consumer will attempt to re-establish the JMX connection every 'x' seconds until the connection is made-- where 'x' is the configured reconnectionDelay",
          "default" : "false",
          "type" : "boolean"
        },
        "string-to-compare" : {
          "description" : "Value for attribute to compare (string monitor or consumer). By default the consumer will notify match if observed attribute and string to compare has been configured.",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "test-connection-on-startup" : {
          "description" : "If true the consumer will throw an exception if unable to establish the JMX connection upon startup. If false, the consumer will attempt to establish the JMX connection every 'x' seconds until the connection is made -- where 'x' is the configured reconnectionDelay",
          "default" : "true",
          "type" : "boolean"
        },
        "threshold-high" : {
          "description" : "Value for the gauge's high threshold (gauge monitor only).",
          "type" : "number"
        },
        "threshold-low" : {
          "description" : "Value for the gauge's low threshold (gauge monitor only).",
          "type" : "number"
        },
        "user" : {
          "description" : "Credentials for making a remote connection",
          "type" : "string"
        }
      },
      "required" : [ "objectDomain" ]
    },
    "jolt" : {
      "type" : "object",
      "required" : [ "resourceUri" ],
      "properties" : {
        "resource-uri" : {
          "description" : "Path to the resource. You can prefix with: classpath, file, http, ref, or bean. classpath, file and http loads the resource using these protocols (classpath is default). ref will lookup the resource in the registry. bean will call a method on a bean to be used as the resource. For bean you can specify the method name after dot, eg bean:myBean.myMethod.",
          "type" : "string"
        },
        "allow-context-map-all" : {
          "description" : "Sets whether the context map should allow access to all details. By default only the message body and headers can be accessed. This option can be enabled for full access to the current Exchange and CamelContext. Doing so impose a potential security risk as this opens access to the full power of CamelContext API.",
          "default" : "false",
          "type" : "boolean"
        },
        "allow-template-from-header" : {
          "description" : "Whether to allow to use resource template from header or not (default false). Enabling this allows to specify dynamic templates via message header. However this can be seen as a potential security vulnerability if the header is coming from a malicious user, so use this with care.",
          "default" : "false",
          "type" : "boolean"
        },
        "content-cache" : {
          "description" : "Sets whether to use resource content cache or not",
          "default" : "false",
          "type" : "boolean"
        },
        "input-type" : {
          "description" : "Specifies if the input is hydrated JSON or a JSON String.",
          "default" : "Hydrated",
          "enum" : [ "Hydrated", "JsonString" ],
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "output-type" : {
          "description" : "Specifies if the output should be hydrated JSON or a JSON String.",
          "default" : "Hydrated",
          "enum" : [ "Hydrated", "JsonString" ],
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "transform-dsl" : {
          "description" : "Specifies the Transform DSL of the endpoint resource. If none is specified Chainr will be used.",
          "default" : "Chainr",
          "enum" : [ "Chainr", "Shiftr", "Defaultr", "Removr", "Sortr" ],
          "type" : "string"
        }
      }
    },
    "jooq" : {
      "type" : "object",
      "properties" : {
        "entity-type" : {
          "description" : "JOOQ entity class",
          "type" : "string"
        },
        "backoff-error-threshold" : {
          "description" : "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-idle-threshold" : {
          "description" : "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-multiplier" : {
          "description" : "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
          "type" : "integer"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "consume-delete" : {
          "description" : "Delete entity after it is consumed",
          "default" : "true",
          "type" : "boolean"
        },
        "database-configuration" : {
          "description" : "To use a specific database configuration",
          "type" : "string"
        },
        "delay" : {
          "description" : "Milliseconds before the next poll.",
          "default" : "500",
          "type" : "integer"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "greedy" : {
          "description" : "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
          "default" : "false",
          "type" : "boolean"
        },
        "initial-delay" : {
          "description" : "Milliseconds before the first poll starts.",
          "default" : "1000",
          "type" : "integer"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "operation" : {
          "description" : "Type of operation to execute on query",
          "default" : "NONE",
          "enum" : [ "EXECUTE", "FETCH", "NONE" ],
          "type" : "string"
        },
        "poll-strategy" : {
          "description" : "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
          "type" : "string"
        },
        "query" : {
          "description" : "To execute plain SQL query",
          "type" : "string"
        },
        "repeat-count" : {
          "description" : "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
          "default" : "0",
          "type" : "integer"
        },
        "run-logging-level" : {
          "description" : "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
          "default" : "TRACE",
          "enum" : [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ],
          "type" : "string"
        },
        "scheduled-executor-service" : {
          "description" : "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
          "type" : "string"
        },
        "scheduler" : {
          "description" : "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
          "default" : "none",
          "type" : "string"
        },
        "scheduler-properties" : {
          "description" : "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
          "type" : "string"
        },
        "send-empty-message-when-idle" : {
          "description" : "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
          "default" : "false",
          "type" : "boolean"
        },
        "start-scheduler" : {
          "description" : "Whether the scheduler should be auto started.",
          "default" : "true",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "time-unit" : {
          "description" : "Time unit for initialDelay and delay options.",
          "default" : "MILLISECONDS",
          "enum" : [ "NANOSECONDS", "MICROSECONDS", "MILLISECONDS", "SECONDS", "MINUTES", "HOURS", "DAYS" ],
          "type" : "string"
        },
        "use-fixed-delay" : {
          "description" : "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
          "default" : "true",
          "type" : "boolean"
        }
      }
    },
    "jpa" : {
      "type" : "object",
      "required" : [ "entityType", "persistenceUnit" ],
      "properties" : {
        "entity-type" : {
          "description" : "Entity class name",
          "type" : "string"
        },
        "backoff-error-threshold" : {
          "description" : "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-idle-threshold" : {
          "description" : "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-multiplier" : {
          "description" : "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
          "type" : "integer"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "consume-delete" : {
          "description" : "If true, the entity is deleted after it is consumed; if false, the entity is not deleted.",
          "default" : "true",
          "type" : "boolean"
        },
        "consume-lock-entity" : {
          "description" : "Specifies whether or not to set an exclusive lock on each entity bean while processing the results from polling.",
          "default" : "true",
          "type" : "boolean"
        },
        "delay" : {
          "description" : "Milliseconds before the next poll.",
          "default" : "500",
          "type" : "integer"
        },
        "delete-handler" : {
          "description" : "To use a custom DeleteHandler to delete the row after the consumer is done processing the exchange",
          "type" : "string"
        },
        "entity-manager-properties" : {
          "description" : "Additional properties for the entity manager to use.",
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "find-entity" : {
          "description" : "If enabled then the producer will find a single entity by using the message body as key and entityType as the class type. This can be used instead of a query to find a single entity.",
          "default" : "false",
          "type" : "boolean"
        },
        "flush-on-send" : {
          "description" : "Flushes the EntityManager after the entity bean has been persisted.",
          "default" : "true",
          "type" : "boolean"
        },
        "greedy" : {
          "description" : "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
          "default" : "false",
          "type" : "boolean"
        },
        "initial-delay" : {
          "description" : "Milliseconds before the first poll starts.",
          "default" : "1000",
          "type" : "integer"
        },
        "join-transaction" : {
          "description" : "The camel-jpa component will join transaction by default. You can use this option to turn this off, for example if you use LOCAL_RESOURCE and join transaction doesn't work with your JPA provider. This option can also be set globally on the JpaComponent, instead of having to set it on all endpoints.",
          "default" : "true",
          "type" : "boolean"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "lock-mode-type" : {
          "description" : "To configure the lock mode on the consumer.",
          "default" : "PESSIMISTIC_WRITE",
          "enum" : [ "READ", "WRITE", "OPTIMISTIC", "OPTIMISTIC_FORCE_INCREMENT", "PESSIMISTIC_READ", "PESSIMISTIC_WRITE", "PESSIMISTIC_FORCE_INCREMENT", "NONE" ],
          "type" : "string"
        },
        "max-messages-per-poll" : {
          "description" : "An integer value to define the maximum number of messages to gather per poll. By default, no maximum is set. Can be used to avoid polling many thousands of messages when starting up the server. Set a value of 0 or negative to disable.",
          "type" : "integer"
        },
        "maximum-results" : {
          "description" : "Set the maximum number of results to retrieve on the Query.",
          "default" : "-1",
          "type" : "integer"
        },
        "named-query" : {
          "description" : "To use a named query.",
          "type" : "string"
        },
        "native-query" : {
          "description" : "To use a custom native query. You may want to use the option resultClass also when using native queries.",
          "type" : "string"
        },
        "parameters" : {
          "description" : "This key/value mapping is used for building the query parameters. It is expected to be of the generic type java.util.Map where the keys are the named parameters of a given JPA query and the values are their corresponding effective values you want to select for. When it's used for producer, Simple expression can be used as a parameter value. It allows you to retrieve parameter values from the message body, header and etc.",
          "type" : "string"
        },
        "persistence-unit" : {
          "description" : "The JPA persistence unit used by default.",
          "default" : "camel",
          "type" : "string"
        },
        "poll-strategy" : {
          "description" : "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
          "type" : "string"
        },
        "pre-delete-handler" : {
          "description" : "To use a custom Pre-DeleteHandler to delete the row after the consumer has read the entity.",
          "type" : "string"
        },
        "query" : {
          "description" : "To use a custom query.",
          "type" : "string"
        },
        "remove" : {
          "description" : "Indicates to use entityManager.remove(entity).",
          "default" : "false",
          "type" : "boolean"
        },
        "repeat-count" : {
          "description" : "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
          "default" : "0",
          "type" : "integer"
        },
        "result-class" : {
          "description" : "Defines the type of the returned payload (we will call entityManager.createNativeQuery(nativeQuery, resultClass) instead of entityManager.createNativeQuery(nativeQuery)). Without this option, we will return an object array. Only has an affect when using in conjunction with native query when consuming data.",
          "type" : "string"
        },
        "run-logging-level" : {
          "description" : "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
          "default" : "TRACE",
          "enum" : [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ],
          "type" : "string"
        },
        "scheduled-executor-service" : {
          "description" : "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
          "type" : "string"
        },
        "scheduler" : {
          "description" : "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
          "default" : "none",
          "type" : "string"
        },
        "scheduler-properties" : {
          "description" : "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
          "type" : "string"
        },
        "send-empty-message-when-idle" : {
          "description" : "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
          "default" : "false",
          "type" : "boolean"
        },
        "shared-entity-manager" : {
          "description" : "Whether to use Spring's SharedEntityManager for the consumer/producer. Note in most cases joinTransaction should be set to false as this is not an EXTENDED EntityManager.",
          "default" : "false",
          "type" : "boolean"
        },
        "skip-locked-entity" : {
          "description" : "To configure whether to use NOWAIT on lock and silently skip the entity.",
          "default" : "false",
          "type" : "boolean"
        },
        "start-scheduler" : {
          "description" : "Whether the scheduler should be auto started.",
          "default" : "true",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "time-unit" : {
          "description" : "Time unit for initialDelay and delay options.",
          "default" : "MILLISECONDS",
          "enum" : [ "NANOSECONDS", "MICROSECONDS", "MILLISECONDS", "SECONDS", "MINUTES", "HOURS", "DAYS" ],
          "type" : "string"
        },
        "transacted" : {
          "description" : "Whether to run the consumer in transacted mode, by which all messages will either commit or rollback, when the entire batch has been processed. The default behavior (false) is to commit all the previously successfully processed messages, and only rollback the last failed message.",
          "default" : "false",
          "type" : "boolean"
        },
        "use-execute-update" : {
          "description" : "To configure whether to use executeUpdate() when producer executes a query. When you use INSERT, UPDATE or DELETE statement as a named query, you need to specify this option to 'true'.",
          "type" : "boolean"
        },
        "use-fixed-delay" : {
          "description" : "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
          "default" : "true",
          "type" : "boolean"
        },
        "use-passed-in-entity-manager" : {
          "description" : "If set to true, then Camel will use the EntityManager from the header JpaConstants.ENTITY_MANAGER instead of the configured entity manager on the component/endpoint. This allows end users to control which entity manager will be in use.",
          "default" : "false",
          "type" : "boolean"
        },
        "use-persist" : {
          "description" : "Indicates to use entityManager.persist(entity) instead of entityManager.merge(entity). Note: entityManager.persist(entity) doesn't work for detached entities (where the EntityManager has to execute an UPDATE instead of an INSERT query)!",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "jslt" : {
      "type" : "object",
      "required" : [ "resourceUri" ],
      "properties" : {
        "resource-uri" : {
          "description" : "Path to the resource. You can prefix with: classpath, file, http, ref, or bean. classpath, file and http loads the resource using these protocols (classpath is default). ref will lookup the resource in the registry. bean will call a method on a bean to be used as the resource. For bean you can specify the method name after dot, eg bean:myBean.myMethod.",
          "type" : "string"
        },
        "allow-context-map-all" : {
          "description" : "Sets whether the context map should allow access to all details. By default only the message body and headers can be accessed. This option can be enabled for full access to the current Exchange and CamelContext. Doing so impose a potential security risk as this opens access to the full power of CamelContext API.",
          "default" : "false",
          "type" : "boolean"
        },
        "allow-template-from-header" : {
          "description" : "Whether to allow to use resource template from header or not (default false). Enabling this allows to specify dynamic templates via message header. However this can be seen as a potential security vulnerability if the header is coming from a malicious user, so use this with care.",
          "default" : "false",
          "type" : "boolean"
        },
        "content-cache" : {
          "description" : "Sets whether to use resource content cache or not",
          "default" : "false",
          "type" : "boolean"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "pretty-print" : {
          "description" : "If true, JSON in output message is pretty printed.",
          "default" : "false",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "json-validator" : {
      "type" : "object",
      "required" : [ "resourceUri" ],
      "properties" : {
        "resource-uri" : {
          "description" : "Path to the resource. You can prefix with: classpath, file, http, ref, or bean. classpath, file and http loads the resource using these protocols (classpath is default). ref will lookup the resource in the registry. bean will call a method on a bean to be used as the resource. For bean you can specify the method name after dot, eg bean:myBean.myMethod.",
          "type" : "string"
        },
        "allow-context-map-all" : {
          "description" : "Sets whether the context map should allow access to all details. By default only the message body and headers can be accessed. This option can be enabled for full access to the current Exchange and CamelContext. Doing so impose a potential security risk as this opens access to the full power of CamelContext API.",
          "default" : "false",
          "type" : "boolean"
        },
        "content-cache" : {
          "description" : "Sets whether to use resource content cache or not",
          "default" : "false",
          "type" : "boolean"
        },
        "error-handler" : {
          "description" : "To use a custom ValidatorErrorHandler. The default error handler captures the errors and throws an exception.",
          "type" : "string"
        },
        "fail-on-null-body" : {
          "description" : "Whether to fail if no body exists.",
          "default" : "true",
          "type" : "boolean"
        },
        "fail-on-null-header" : {
          "description" : "Whether to fail if no header exists when validating against a header.",
          "default" : "true",
          "type" : "boolean"
        },
        "header-name" : {
          "description" : "To validate against a header instead of the message body.",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "schema-loader" : {
          "description" : "To use a custom schema loader allowing for adding custom format validation. The default implementation will create a schema loader with draft v4 support.",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "jsonata" : {
      "type" : "object",
      "required" : [ "resourceUri" ],
      "properties" : {
        "resource-uri" : {
          "description" : "Path to the resource. You can prefix with: classpath, file, http, ref, or bean. classpath, file and http loads the resource using these protocols (classpath is default). ref will lookup the resource in the registry. bean will call a method on a bean to be used as the resource. For bean you can specify the method name after dot, eg bean:myBean.myMethod.",
          "type" : "string"
        },
        "allow-context-map-all" : {
          "description" : "Sets whether the context map should allow access to all details. By default only the message body and headers can be accessed. This option can be enabled for full access to the current Exchange and CamelContext. Doing so impose a potential security risk as this opens access to the full power of CamelContext API.",
          "default" : "false",
          "type" : "boolean"
        },
        "content-cache" : {
          "description" : "Sets whether to use resource content cache or not",
          "default" : "false",
          "type" : "boolean"
        },
        "input-type" : {
          "description" : "Specifies if the output should be Jackson JsonNode or a JSON String.",
          "default" : "Jackson",
          "enum" : [ "Jackson", "JsonString" ],
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "output-type" : {
          "description" : "Specifies if the output should be Jackson JsonNode or a JSON String.",
          "default" : "Jackson",
          "enum" : [ "Jackson", "JsonString" ],
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "jt400" : {
      "type" : "object",
      "required" : [ "objectPath", "password", "systemName", "type", "userID" ],
      "properties" : {
        "object-path" : {
          "description" : "Returns the fully qualified integrated file system path name of the target object of this endpoint.",
          "type" : "string"
        },
        "password" : {
          "description" : "Returns the password of the IBM i user.",
          "type" : "string"
        },
        "system-name" : {
          "description" : "Returns the name of the IBM i system.",
          "type" : "string"
        },
        "type" : {
          "description" : "Whether to work with data queues or remote program call",
          "enum" : [ "DTAQ", "PGM", "SRVPGM", "MSGQ" ],
          "type" : "string"
        },
        "user-id" : {
          "description" : "Returns the ID of the IBM i user.",
          "type" : "string"
        },
        "backoff-error-threshold" : {
          "description" : "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-idle-threshold" : {
          "description" : "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-multiplier" : {
          "description" : "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
          "type" : "integer"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "ccsid" : {
          "description" : "Sets the CCSID to use for the connection with the IBM i system.",
          "type" : "integer"
        },
        "delay" : {
          "description" : "Milliseconds before the next poll.",
          "default" : "500",
          "type" : "integer"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "format" : {
          "description" : "Sets the data format for sending messages.",
          "default" : "text",
          "enum" : [ "text", "binary" ],
          "type" : "string"
        },
        "greedy" : {
          "description" : "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
          "default" : "false",
          "type" : "boolean"
        },
        "gui-available" : {
          "description" : "Sets whether IBM i prompting is enabled in the environment running Camel.",
          "default" : "false",
          "type" : "boolean"
        },
        "initial-delay" : {
          "description" : "Milliseconds before the first poll starts.",
          "default" : "1000",
          "type" : "integer"
        },
        "keyed" : {
          "description" : "Whether to use keyed or non-keyed data queues.",
          "default" : "false",
          "type" : "boolean"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "message-action" : {
          "description" : "Action to be taken on messages when read from a message queue. Messages can be marked as old (OLD), removed from the queue (REMOVE), or neither (SAME).",
          "default" : "OLD",
          "enum" : [ "OLD", "REMOVE", "SAME" ],
          "type" : "string"
        },
        "output-fields-idx-array" : {
          "description" : "Specifies which fields (program parameters) are output parameters.",
          "type" : "string"
        },
        "output-fields-length-array" : {
          "description" : "Specifies the fields (program parameters) length as in the IBM i program definition.",
          "type" : "string"
        },
        "poll-strategy" : {
          "description" : "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
          "type" : "string"
        },
        "procedure-name" : {
          "description" : "Procedure name from a service program to call",
          "type" : "string"
        },
        "read-timeout" : {
          "description" : "Timeout in millis the consumer will wait while trying to read a new message of the data queue.",
          "default" : "30000",
          "type" : "integer"
        },
        "repeat-count" : {
          "description" : "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
          "default" : "0",
          "type" : "integer"
        },
        "run-logging-level" : {
          "description" : "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
          "default" : "TRACE",
          "enum" : [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ],
          "type" : "string"
        },
        "scheduled-executor-service" : {
          "description" : "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
          "type" : "string"
        },
        "scheduler" : {
          "description" : "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
          "default" : "none",
          "type" : "string"
        },
        "scheduler-properties" : {
          "description" : "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
          "type" : "string"
        },
        "search-key" : {
          "description" : "Search key for keyed data queues.",
          "type" : "string"
        },
        "search-type" : {
          "description" : "Search type such as EQ for equal etc.",
          "default" : "EQ",
          "enum" : [ "EQ", "NE", "LT", "LE", "GT", "GE" ],
          "type" : "string"
        },
        "secured" : {
          "description" : "Whether connections to IBM i are secured with SSL.",
          "default" : "false",
          "type" : "boolean"
        },
        "send-empty-message-when-idle" : {
          "description" : "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
          "default" : "false",
          "type" : "boolean"
        },
        "start-scheduler" : {
          "description" : "Whether the scheduler should be auto started.",
          "default" : "true",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "time-unit" : {
          "description" : "Time unit for initialDelay and delay options.",
          "default" : "MILLISECONDS",
          "enum" : [ "NANOSECONDS", "MICROSECONDS", "MILLISECONDS", "SECONDS", "MINUTES", "HOURS", "DAYS" ],
          "type" : "string"
        },
        "use-fixed-delay" : {
          "description" : "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
          "default" : "true",
          "type" : "boolean"
        }
      }
    },
    "kafka" : {
      "type" : "object",
      "required" : [ "topic" ],
      "properties" : {
        "topic" : {
          "description" : "Name of the topic to use. On the consumer you can use comma to separate multiple topics. A producer can only send a message to a single topic.",
          "type" : "string"
        },
        "additional-properties" : {
          "description" : "Sets additional properties for either kafka consumer or kafka producer in case they can't be set directly on the camel configurations (e.g: new Kafka properties that are not reflected yet in Camel configurations), the properties have to be prefixed with additionalProperties.. E.g: additionalProperties.transactional.id=12345&additionalProperties.schema.registry.url=http://localhost:8811/avro",
          "type" : "string"
        },
        "allow-manual-commit" : {
          "description" : "Whether to allow doing manual commits via KafkaManualCommit. If this option is enabled then an instance of KafkaManualCommit is stored on the Exchange message header, which allows end users to access this API and perform manual offset commits via the Kafka consumer.",
          "default" : "false",
          "type" : "boolean"
        },
        "auto-commit-enable" : {
          "description" : "If true, periodically commit to ZooKeeper the offset of messages already fetched by the consumer. This committed offset will be used when the process fails as the position from which the new consumer will begin.",
          "default" : "true",
          "type" : "boolean"
        },
        "auto-commit-interval-ms" : {
          "description" : "The frequency in ms that the consumer offsets are committed to zookeeper.",
          "default" : "5000",
          "type" : "integer"
        },
        "auto-commit-on-stop" : {
          "description" : "Whether to perform an explicit auto commit when the consumer stops to ensure the broker has a commit from the last consumed message. This requires the option autoCommitEnable is turned on. The possible values are: sync, async, or none. And sync is the default value.",
          "default" : "sync",
          "enum" : [ "sync", "async", "none" ],
          "type" : "string"
        },
        "auto-offset-reset" : {
          "description" : "What to do when there is no initial offset in ZooKeeper or if an offset is out of range: earliest : automatically reset the offset to the earliest offset latest : automatically reset the offset to the latest offset fail: throw exception to the consumer",
          "default" : "latest",
          "enum" : [ "latest", "earliest", "none" ],
          "type" : "string"
        },
        "break-on-first-error" : {
          "description" : "This options controls what happens when a consumer is processing an exchange and it fails. If the option is false then the consumer continues to the next message and processes it. If the option is true then the consumer breaks out, and will seek back to offset of the message that caused a failure, and then re-attempt to process this message. However this can lead to endless processing of the same message if its bound to fail every time, eg a poison message. Therefore its recommended to deal with that for example by using Camel's error handler.",
          "default" : "false",
          "type" : "boolean"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "brokers" : {
          "description" : "URL of the Kafka brokers to use. The format is host1:port1,host2:port2, and the list can be a subset of brokers or a VIP pointing to a subset of brokers. This option is known as bootstrap.servers in the Kafka documentation.",
          "type" : "string"
        },
        "buffer-memory-size" : {
          "description" : "The total bytes of memory the producer can use to buffer records waiting to be sent to the server. If records are sent faster than they can be delivered to the server the producer will either block or throw an exception based on the preference specified by block.on.buffer.full.This setting should correspond roughly to the total memory the producer will use, but is not a hard bound since not all memory the producer uses is used for buffering. Some additional memory will be used for compression (if compression is enabled) as well as for maintaining in-flight requests.",
          "default" : "33554432",
          "type" : "integer"
        },
        "check-crcs" : {
          "description" : "Automatically check the CRC32 of the records consumed. This ensures no on-the-wire or on-disk corruption to the messages occurred. This check adds some overhead, so it may be disabled in cases seeking extreme performance.",
          "default" : "true",
          "type" : "boolean"
        },
        "client-id" : {
          "description" : "The client id is a user-specified string sent in each request to help trace calls. It should logically identify the application making the request.",
          "type" : "string"
        },
        "compression-codec" : {
          "description" : "This parameter allows you to specify the compression codec for all data generated by this producer. Valid values are none, gzip and snappy.",
          "default" : "none",
          "enum" : [ "none", "gzip", "snappy", "lz4" ],
          "type" : "string"
        },
        "connection-max-idle-ms" : {
          "description" : "Close idle connections after the number of milliseconds specified by this config.",
          "default" : "540000",
          "type" : "integer"
        },
        "consumer-request-timeout-ms" : {
          "description" : "The configuration controls the maximum amount of time the client will wait for the response of a request. If the response is not received before the timeout elapses the client will resend the request if necessary or fail the request if retries are exhausted.",
          "default" : "40000",
          "type" : "integer"
        },
        "consumer-streams" : {
          "description" : "Number of concurrent consumers on the consumer",
          "default" : "10",
          "type" : "integer"
        },
        "consumers-count" : {
          "description" : "The number of consumers that connect to kafka server",
          "default" : "1",
          "type" : "integer"
        },
        "enable-idempotence" : {
          "description" : "If set to 'true' the producer will ensure that exactly one copy of each message is written in the stream. If 'false', producer retries may write duplicates of the retried message in the stream. If set to true this option will require max.in.flight.requests.per.connection to be set to 1 and retries cannot be zero and additionally acks must be set to 'all'.",
          "default" : "false",
          "type" : "boolean"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "fetch-max-bytes" : {
          "description" : "The maximum amount of data the server should return for a fetch request This is not an absolute maximum, if the first message in the first non-empty partition of the fetch is larger than this value, the message will still be returned to ensure that the consumer can make progress. The maximum message size accepted by the broker is defined via message.max.bytes (broker config) or max.message.bytes (topic config). Note that the consumer performs multiple fetches in parallel.",
          "default" : "52428800",
          "type" : "integer"
        },
        "fetch-min-bytes" : {
          "description" : "The minimum amount of data the server should return for a fetch request. If insufficient data is available the request will wait for that much data to accumulate before answering the request.",
          "default" : "1",
          "type" : "integer"
        },
        "fetch-wait-max-ms" : {
          "description" : "The maximum amount of time the server will block before answering the fetch request if there isn't sufficient data to immediately satisfy fetch.min.bytes",
          "default" : "500",
          "type" : "integer"
        },
        "group-id" : {
          "description" : "A string that uniquely identifies the group of consumer processes to which this consumer belongs. By setting the same group id multiple processes indicate that they are all part of the same consumer group. This option is required for consumers.",
          "type" : "string"
        },
        "header-deserializer" : {
          "description" : "To use a custom KafkaHeaderDeserializer to deserialize kafka headers values",
          "type" : "string"
        },
        "header-filter-strategy" : {
          "description" : "To use a custom HeaderFilterStrategy to filter header to and from Camel message.",
          "type" : "string"
        },
        "header-serializer" : {
          "description" : "To use a custom KafkaHeaderSerializer to serialize kafka headers values",
          "type" : "string"
        },
        "heartbeat-interval-ms" : {
          "description" : "The expected time between heartbeats to the consumer coordinator when using Kafka's group management facilities. Heartbeats are used to ensure that the consumer's session stays active and to facilitate rebalancing when new consumers join or leave the group. The value must be set lower than session.timeout.ms, but typically should be set no higher than 1/3 of that value. It can be adjusted even lower to control the expected time for normal rebalances.",
          "default" : "3000",
          "type" : "integer"
        },
        "interceptor-classes" : {
          "description" : "Sets interceptors for producer or consumers. Producer interceptors have to be classes implementing org.apache.kafka.clients.producer.ProducerInterceptor Consumer interceptors have to be classes implementing org.apache.kafka.clients.consumer.ConsumerInterceptor Note that if you use Producer interceptor on a consumer it will throw a class cast exception in runtime",
          "type" : "string"
        },
        "kerberos-before-relogin-min-time" : {
          "description" : "Login thread sleep time between refresh attempts.",
          "default" : "60000",
          "type" : "integer"
        },
        "kerberos-init-cmd" : {
          "description" : "Kerberos kinit command path. Default is /usr/bin/kinit",
          "default" : "/usr/bin/kinit",
          "type" : "string"
        },
        "kerberos-principal-to-local-rules" : {
          "description" : "A list of rules for mapping from principal names to short names (typically operating system usernames). The rules are evaluated in order and the first rule that matches a principal name is used to map it to a short name. Any later rules in the list are ignored. By default, principal names of the form {username}/{hostname}{REALM} are mapped to {username}. For more details on the format please see the security authorization and acls documentation.. Multiple values can be separated by comma",
          "default" : "DEFAULT",
          "type" : "string"
        },
        "kerberos-renew-jitter" : {
          "description" : "Percentage of random jitter added to the renewal time.",
          "default" : "0.05",
          "type" : "number"
        },
        "kerberos-renew-window-factor" : {
          "description" : "Login thread will sleep until the specified window factor of time from last refresh to ticket's expiry has been reached, at which time it will try to renew the ticket.",
          "default" : "0.8",
          "type" : "number"
        },
        "key" : {
          "description" : "The record key (or null if no key is specified). If this option has been configured then it take precedence over header KafkaConstants#KEY",
          "type" : "string"
        },
        "key-deserializer" : {
          "description" : "Deserializer class for key that implements the Deserializer interface.",
          "default" : "org.apache.kafka.common.serialization.StringDeserializer",
          "type" : "string"
        },
        "key-serializer" : {
          "description" : "The serializer class for keys (defaults to the same as for messages if nothing is given).",
          "default" : "org.apache.kafka.common.serialization.StringSerializer",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "linger-ms" : {
          "description" : "The producer groups together any records that arrive in between request transmissions into a single batched request. Normally this occurs only under load when records arrive faster than they can be sent out. However in some circumstances the client may want to reduce the number of requests even under moderate load. This setting accomplishes this by adding a small amount of artificial delay that is, rather than immediately sending out a record the producer will wait for up to the given delay to allow other records to be sent so that the sends can be batched together. This can be thought of as analogous to Nagle's algorithm in TCP. This setting gives the upper bound on the delay for batching: once we get batch.size worth of records for a partition it will be sent immediately regardless of this setting, however if we have fewer than this many bytes accumulated for this partition we will 'linger' for the specified time waiting for more records to show up. This setting defaults to 0 (i.e. no delay). Setting linger.ms=5, for example, would have the effect of reducing the number of requests sent but would add up to 5ms of latency to records sent in the absense of load.",
          "default" : "0",
          "type" : "integer"
        },
        "max-block-ms" : {
          "description" : "The configuration controls how long sending to kafka will block. These methods can be blocked for multiple reasons. For e.g: buffer full, metadata unavailable.This configuration imposes maximum limit on the total time spent in fetching metadata, serialization of key and value, partitioning and allocation of buffer memory when doing a send(). In case of partitionsFor(), this configuration imposes a maximum time threshold on waiting for metadata",
          "default" : "60000",
          "type" : "integer"
        },
        "max-in-flight-request" : {
          "description" : "The maximum number of unacknowledged requests the client will send on a single connection before blocking. Note that if this setting is set to be greater than 1 and there are failed sends, there is a risk of message re-ordering due to retries (i.e., if retries are enabled).",
          "default" : "5",
          "type" : "integer"
        },
        "max-partition-fetch-bytes" : {
          "description" : "The maximum amount of data per-partition the server will return. The maximum total memory used for a request will be #partitions max.partition.fetch.bytes. This size must be at least as large as the maximum message size the server allows or else it is possible for the producer to send messages larger than the consumer can fetch. If that happens, the consumer can get stuck trying to fetch a large message on a certain partition.",
          "default" : "1048576",
          "type" : "integer"
        },
        "max-poll-interval-ms" : {
          "description" : "The maximum delay between invocations of poll() when using consumer group management. This places an upper bound on the amount of time that the consumer can be idle before fetching more records. If poll() is not called before expiration of this timeout, then the consumer is considered failed and the group will rebalance in order to reassign the partitions to another member.",
          "type" : "string"
        },
        "max-poll-records" : {
          "description" : "The maximum number of records returned in a single call to poll()",
          "default" : "500",
          "type" : "integer"
        },
        "max-request-size" : {
          "description" : "The maximum size of a request. This is also effectively a cap on the maximum record size. Note that the server has its own cap on record size which may be different from this. This setting will limit the number of record batches the producer will send in a single request to avoid sending huge requests.",
          "default" : "1048576",
          "type" : "integer"
        },
        "metadata-max-age-ms" : {
          "description" : "The period of time in milliseconds after which we force a refresh of metadata even if we haven't seen any partition leadership changes to proactively discover any new brokers or partitions.",
          "default" : "300000",
          "type" : "integer"
        },
        "metric-reporters" : {
          "description" : "A list of classes to use as metrics reporters. Implementing the MetricReporter interface allows plugging in classes that will be notified of new metric creation. The JmxReporter is always included to register JMX statistics.",
          "type" : "string"
        },
        "metrics-sample-window-ms" : {
          "description" : "The number of samples maintained to compute metrics.",
          "default" : "30000",
          "type" : "integer"
        },
        "no-of-metrics-sample" : {
          "description" : "The number of samples maintained to compute metrics.",
          "default" : "2",
          "type" : "integer"
        },
        "offset-repository" : {
          "description" : "The offset repository to use in order to locally store the offset of each partition of the topic. Defining one will disable the autocommit.",
          "type" : "string"
        },
        "partition-assignor" : {
          "description" : "The class name of the partition assignment strategy that the client will use to distribute partition ownership amongst consumer instances when group management is used",
          "default" : "org.apache.kafka.clients.consumer.RangeAssignor",
          "type" : "string"
        },
        "partition-key" : {
          "description" : "The partition to which the record will be sent (or null if no partition was specified). If this option has been configured then it take precedence over header KafkaConstants#PARTITION_KEY",
          "type" : "integer"
        },
        "partitioner" : {
          "description" : "The partitioner class for partitioning messages amongst sub-topics. The default partitioner is based on the hash of the key.",
          "default" : "org.apache.kafka.clients.producer.internals.DefaultPartitioner",
          "type" : "string"
        },
        "poll-timeout-ms" : {
          "description" : "The timeout used when polling the KafkaConsumer.",
          "default" : "5000",
          "type" : "string"
        },
        "producer-batch-size" : {
          "description" : "The producer will attempt to batch records together into fewer requests whenever multiple records are being sent to the same partition. This helps performance on both the client and the server. This configuration controls the default batch size in bytes. No attempt will be made to batch records larger than this size.Requests sent to brokers will contain multiple batches, one for each partition with data available to be sent.A small batch size will make batching less common and may reduce throughput (a batch size of zero will disable batching entirely). A very large batch size may use memory a bit more wastefully as we will always allocate a buffer of the specified batch size in anticipation of additional records.",
          "default" : "16384",
          "type" : "integer"
        },
        "queue-buffering-max-messages" : {
          "description" : "The maximum number of unsent messages that can be queued up the producer when using async mode before either the producer must be blocked or data must be dropped.",
          "default" : "10000",
          "type" : "integer"
        },
        "receive-buffer-bytes" : {
          "description" : "The size of the TCP receive buffer (SO_RCVBUF) to use when reading data.",
          "default" : "65536",
          "type" : "integer"
        },
        "reconnect-backoff-max-ms" : {
          "description" : "The maximum amount of time in milliseconds to wait when reconnecting to a broker that has repeatedly failed to connect. If provided, the backoff per host will increase exponentially for each consecutive connection failure, up to this maximum. After calculating the backoff increase, 20% random jitter is added to avoid connection storms.",
          "default" : "1000",
          "type" : "integer"
        },
        "reconnect-backoff-ms" : {
          "description" : "The amount of time to wait before attempting to reconnect to a given host. This avoids repeatedly connecting to a host in a tight loop. This backoff applies to all requests sent by the consumer to the broker.",
          "default" : "50",
          "type" : "integer"
        },
        "record-metadata" : {
          "description" : "Whether the producer should store the RecordMetadata results from sending to Kafka. The results are stored in a List containing the RecordMetadata metadata's. The list is stored on a header with the key KafkaConstants#KAFKA_RECORDMETA",
          "default" : "true",
          "type" : "boolean"
        },
        "request-required-acks" : {
          "description" : "The number of acknowledgments the producer requires the leader to have received before considering a request complete. This controls the durability of records that are sent. The following settings are common: acks=0 If set to zero then the producer will not wait for any acknowledgment from the server at all. The record will be immediately added to the socket buffer and considered sent. No guarantee can be made that the server has received the record in this case, and the retries configuration will not take effect (as the client won't generally know of any failures). The offset given back for each record will always be set to -1. acks=1 This will mean the leader will write the record to its local log but will respond without awaiting full acknowledgement from all followers. In this case should the leader fail immediately after acknowledging the record but before the followers have replicated it then the record will be lost. acks=all This means the leader will wait for the full set of in-sync replicas to acknowledge the record. This guarantees that the record will not be lost as long as at least one in-sync replica remains alive. This is the strongest available guarantee.",
          "default" : "1",
          "enum" : [ "-1", "0", "1", "all" ],
          "type" : "string"
        },
        "request-timeout-ms" : {
          "description" : "The amount of time the broker will wait trying to meet the request.required.acks requirement before sending back an error to the client.",
          "default" : "30000",
          "type" : "integer"
        },
        "retries" : {
          "description" : "Setting a value greater than zero will cause the client to resend any record whose send fails with a potentially transient error. Note that this retry is no different than if the client resent the record upon receiving the error. Allowing retries will potentially change the ordering of records because if two records are sent to a single partition, and the first fails and is retried but the second succeeds, then the second record may appear first.",
          "default" : "0",
          "type" : "integer"
        },
        "retry-backoff-ms" : {
          "description" : "Before each retry, the producer refreshes the metadata of relevant topics to see if a new leader has been elected. Since leader election takes a bit of time, this property specifies the amount of time that the producer waits before refreshing the metadata.",
          "default" : "100",
          "type" : "integer"
        },
        "sasl-jaas-config" : {
          "description" : "Expose the kafka sasl.jaas.config parameter Example: org.apache.kafka.common.security.plain.PlainLoginModule required username=USERNAME password=PASSWORD;",
          "type" : "string"
        },
        "sasl-kerberos-service-name" : {
          "description" : "The Kerberos principal name that Kafka runs as. This can be defined either in Kafka's JAAS config or in Kafka's config.",
          "type" : "string"
        },
        "sasl-mechanism" : {
          "description" : "The Simple Authentication and Security Layer (SASL) Mechanism used. For the valid values see http://www.iana.org/assignments/sasl-mechanisms/sasl-mechanisms.xhtml",
          "default" : "GSSAPI",
          "type" : "string"
        },
        "schema-registry-url" : {
          "description" : "URL of the Confluent Platform schema registry servers to use. The format is host1:port1,host2:port2. This is known as schema.registry.url in the Confluent Platform documentation. This option is only available in the Confluent Platform (not standard Apache Kafka)",
          "type" : "string"
        },
        "security-protocol" : {
          "description" : "Protocol used to communicate with brokers. SASL_PLAINTEXT, PLAINTEXT and SSL are supported",
          "default" : "PLAINTEXT",
          "type" : "string"
        },
        "seek-to" : {
          "description" : "Set if KafkaConsumer will read from beginning or end on startup: beginning : read from beginning end : read from end This is replacing the earlier property seekToBeginning",
          "enum" : [ "beginning", "end" ],
          "type" : "string"
        },
        "send-buffer-bytes" : {
          "description" : "Socket write buffer size",
          "default" : "131072",
          "type" : "integer"
        },
        "session-timeout-ms" : {
          "description" : "The timeout used to detect failures when using Kafka's group management facilities.",
          "default" : "10000",
          "type" : "integer"
        },
        "shutdown-timeout" : {
          "description" : "Timeout in milli seconds to wait gracefully for the consumer or producer to shutdown and terminate its worker threads.",
          "default" : "30000",
          "type" : "integer"
        },
        "specific-avro-reader" : {
          "description" : "This enables the use of a specific Avro reader for use with the Confluent Platform schema registry and the io.confluent.kafka.serializers.KafkaAvroDeserializer. This option is only available in the Confluent Platform (not standard Apache Kafka)",
          "default" : "false",
          "type" : "boolean"
        },
        "ssl-cipher-suites" : {
          "description" : "A list of cipher suites. This is a named combination of authentication, encryption, MAC and key exchange algorithm used to negotiate the security settings for a network connection using TLS or SSL network protocol.By default all the available cipher suites are supported.",
          "type" : "string"
        },
        "ssl-context-parameters" : {
          "description" : "SSL configuration using a Camel SSLContextParameters object. If configured it's applied before the other SSL endpoint parameters. NOTE: Kafka only supports loading keystore from file locations, so prefix the location with file: in the KeyStoreParameters.resource option.",
          "type" : "string"
        },
        "ssl-enabled-protocols" : {
          "description" : "The list of protocols enabled for SSL connections. TLSv1.2, TLSv1.1 and TLSv1 are enabled by default.",
          "type" : "string"
        },
        "ssl-endpoint-algorithm" : {
          "description" : "The endpoint identification algorithm to validate server hostname using server certificate.",
          "default" : "https",
          "type" : "string"
        },
        "ssl-key-password" : {
          "description" : "The password of the private key in the key store file. This is optional for client.",
          "type" : "string"
        },
        "ssl-keymanager-algorithm" : {
          "description" : "The algorithm used by key manager factory for SSL connections. Default value is the key manager factory algorithm configured for the Java Virtual Machine.",
          "default" : "SunX509",
          "type" : "string"
        },
        "ssl-keystore-location" : {
          "description" : "The location of the key store file. This is optional for client and can be used for two-way authentication for client.",
          "type" : "string"
        },
        "ssl-keystore-password" : {
          "description" : "The store password for the key store file.This is optional for client and only needed if ssl.keystore.location is configured.",
          "type" : "string"
        },
        "ssl-keystore-type" : {
          "description" : "The file format of the key store file. This is optional for client. Default value is JKS",
          "default" : "JKS",
          "type" : "string"
        },
        "ssl-protocol" : {
          "description" : "The SSL protocol used to generate the SSLContext. Default setting is TLS, which is fine for most cases. Allowed values in recent JVMs are TLS, TLSv1.1 and TLSv1.2. SSL, SSLv2 and SSLv3 may be supported in older JVMs, but their usage is discouraged due to known security vulnerabilities.",
          "type" : "string"
        },
        "ssl-provider" : {
          "description" : "The name of the security provider used for SSL connections. Default value is the default security provider of the JVM.",
          "type" : "string"
        },
        "ssl-trustmanager-algorithm" : {
          "description" : "The algorithm used by trust manager factory for SSL connections. Default value is the trust manager factory algorithm configured for the Java Virtual Machine.",
          "default" : "PKIX",
          "type" : "string"
        },
        "ssl-truststore-location" : {
          "description" : "The location of the trust store file.",
          "type" : "string"
        },
        "ssl-truststore-password" : {
          "description" : "The password for the trust store file.",
          "type" : "string"
        },
        "ssl-truststore-type" : {
          "description" : "The file format of the trust store file. Default value is JKS.",
          "default" : "JKS",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "topic-is-pattern" : {
          "description" : "Whether the topic is a pattern (regular expression). This can be used to subscribe to dynamic number of topics matching the pattern.",
          "default" : "false",
          "type" : "boolean"
        },
        "value-deserializer" : {
          "description" : "Deserializer class for value that implements the Deserializer interface.",
          "default" : "org.apache.kafka.common.serialization.StringDeserializer",
          "type" : "string"
        },
        "value-serializer" : {
          "description" : "The serializer class for messages.",
          "default" : "org.apache.kafka.common.serialization.StringSerializer",
          "type" : "string"
        },
        "worker-pool" : {
          "description" : "To use a custom worker pool for continue routing Exchange after kafka server has acknowledge the message that was sent to it from KafkaProducer using asynchronous non-blocking processing. If using this option then you must handle the lifecycle of the thread pool to shut the pool down when no longer needed.",
          "type" : "string"
        },
        "worker-pool-core-size" : {
          "description" : "Number of core threads for the worker pool for continue routing Exchange after kafka server has acknowledge the message that was sent to it from KafkaProducer using asynchronous non-blocking processing.",
          "default" : "10",
          "type" : "integer"
        },
        "worker-pool-max-size" : {
          "description" : "Maximum number of threads for the worker pool for continue routing Exchange after kafka server has acknowledge the message that was sent to it from KafkaProducer using asynchronous non-blocking processing.",
          "default" : "20",
          "type" : "integer"
        }
      }
    },
    "kubernetes-config-maps" : {
      "type" : "object",
      "required" : [ "masterUrl" ],
      "properties" : {
        "master-url" : {
          "description" : "Kubernetes Master url",
          "type" : "string"
        },
        "api-version" : {
          "description" : "The Kubernetes API Version to use",
          "type" : "string"
        },
        "ca-cert-data" : {
          "description" : "The CA Cert Data",
          "type" : "string"
        },
        "ca-cert-file" : {
          "description" : "The CA Cert File",
          "type" : "string"
        },
        "client-cert-data" : {
          "description" : "The Client Cert Data",
          "type" : "string"
        },
        "client-cert-file" : {
          "description" : "The Client Cert File",
          "type" : "string"
        },
        "client-key-algo" : {
          "description" : "The Key Algorithm used by the client",
          "type" : "string"
        },
        "client-key-data" : {
          "description" : "The Client Key data",
          "type" : "string"
        },
        "client-key-file" : {
          "description" : "The Client Key file",
          "type" : "string"
        },
        "client-key-passphrase" : {
          "description" : "The Client Key Passphrase",
          "type" : "string"
        },
        "connection-timeout" : {
          "description" : "Connection timeout in milliseconds to use when making requests to the Kubernetes API server.",
          "type" : "integer"
        },
        "dns-domain" : {
          "description" : "The dns domain, used for ServiceCall EIP",
          "type" : "string"
        },
        "kubernetes-client" : {
          "description" : "Default KubernetesClient to use if provided",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "oauth-token" : {
          "description" : "The Auth Token",
          "type" : "string"
        },
        "operation" : {
          "description" : "Producer operation to do on Kubernetes",
          "type" : "string"
        },
        "password" : {
          "description" : "Password to connect to Kubernetes",
          "type" : "string"
        },
        "port-name" : {
          "description" : "The port name, used for ServiceCall EIP",
          "type" : "string"
        },
        "port-protocol" : {
          "description" : "The port protocol, used for ServiceCall EIP",
          "default" : "tcp",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "trust-certs" : {
          "description" : "Define if the certs we used are trusted anyway or not",
          "type" : "boolean"
        },
        "username" : {
          "description" : "Username to connect to Kubernetes",
          "type" : "string"
        }
      }
    },
    "kubernetes-custom-resources" : {
      "type" : "object",
      "required" : [ "masterUrl" ],
      "properties" : {
        "master-url" : {
          "description" : "Kubernetes Master url",
          "type" : "string"
        },
        "api-version" : {
          "description" : "The Kubernetes API Version to use",
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "ca-cert-data" : {
          "description" : "The CA Cert Data",
          "type" : "string"
        },
        "ca-cert-file" : {
          "description" : "The CA Cert File",
          "type" : "string"
        },
        "client-cert-data" : {
          "description" : "The Client Cert Data",
          "type" : "string"
        },
        "client-cert-file" : {
          "description" : "The Client Cert File",
          "type" : "string"
        },
        "client-key-algo" : {
          "description" : "The Key Algorithm used by the client",
          "type" : "string"
        },
        "client-key-data" : {
          "description" : "The Client Key data",
          "type" : "string"
        },
        "client-key-file" : {
          "description" : "The Client Key file",
          "type" : "string"
        },
        "client-key-passphrase" : {
          "description" : "The Client Key Passphrase",
          "type" : "string"
        },
        "connection-timeout" : {
          "description" : "Connection timeout in milliseconds to use when making requests to the Kubernetes API server.",
          "type" : "integer"
        },
        "crd-group" : {
          "description" : "The Consumer CRD Resource Group we would like to watch",
          "type" : "string"
        },
        "crd-name" : {
          "description" : "The Consumer CRD Resource name we would like to watch",
          "type" : "string"
        },
        "crd-plural" : {
          "description" : "The Consumer CRD Resource Plural we would like to watch",
          "type" : "string"
        },
        "crd-scope" : {
          "description" : "The Consumer CRD Resource Scope we would like to watch",
          "type" : "string"
        },
        "crd-version" : {
          "description" : "The Consumer CRD Resource Version we would like to watch",
          "type" : "string"
        },
        "dns-domain" : {
          "description" : "The dns domain, used for ServiceCall EIP",
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "kubernetes-client" : {
          "description" : "Default KubernetesClient to use if provided",
          "type" : "string"
        },
        "label-key" : {
          "description" : "The Consumer Label key when watching at some resources",
          "type" : "string"
        },
        "label-value" : {
          "description" : "The Consumer Label value when watching at some resources",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "namespace" : {
          "description" : "The namespace",
          "type" : "string"
        },
        "oauth-token" : {
          "description" : "The Auth Token",
          "type" : "string"
        },
        "operation" : {
          "description" : "Producer operation to do on Kubernetes",
          "type" : "string"
        },
        "password" : {
          "description" : "Password to connect to Kubernetes",
          "type" : "string"
        },
        "pool-size" : {
          "description" : "The Consumer pool size",
          "default" : "1",
          "type" : "integer"
        },
        "port-name" : {
          "description" : "The port name, used for ServiceCall EIP",
          "type" : "string"
        },
        "port-protocol" : {
          "description" : "The port protocol, used for ServiceCall EIP",
          "default" : "tcp",
          "type" : "string"
        },
        "resource-name" : {
          "description" : "The Consumer Resource Name we would like to watch",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "trust-certs" : {
          "description" : "Define if the certs we used are trusted anyway or not",
          "type" : "boolean"
        },
        "username" : {
          "description" : "Username to connect to Kubernetes",
          "type" : "string"
        }
      }
    },
    "kubernetes-deployments" : {
      "type" : "object",
      "required" : [ "masterUrl" ],
      "properties" : {
        "master-url" : {
          "description" : "Kubernetes Master url",
          "type" : "string"
        },
        "api-version" : {
          "description" : "The Kubernetes API Version to use",
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "ca-cert-data" : {
          "description" : "The CA Cert Data",
          "type" : "string"
        },
        "ca-cert-file" : {
          "description" : "The CA Cert File",
          "type" : "string"
        },
        "client-cert-data" : {
          "description" : "The Client Cert Data",
          "type" : "string"
        },
        "client-cert-file" : {
          "description" : "The Client Cert File",
          "type" : "string"
        },
        "client-key-algo" : {
          "description" : "The Key Algorithm used by the client",
          "type" : "string"
        },
        "client-key-data" : {
          "description" : "The Client Key data",
          "type" : "string"
        },
        "client-key-file" : {
          "description" : "The Client Key file",
          "type" : "string"
        },
        "client-key-passphrase" : {
          "description" : "The Client Key Passphrase",
          "type" : "string"
        },
        "connection-timeout" : {
          "description" : "Connection timeout in milliseconds to use when making requests to the Kubernetes API server.",
          "type" : "integer"
        },
        "crd-group" : {
          "description" : "The Consumer CRD Resource Group we would like to watch",
          "type" : "string"
        },
        "crd-name" : {
          "description" : "The Consumer CRD Resource name we would like to watch",
          "type" : "string"
        },
        "crd-plural" : {
          "description" : "The Consumer CRD Resource Plural we would like to watch",
          "type" : "string"
        },
        "crd-scope" : {
          "description" : "The Consumer CRD Resource Scope we would like to watch",
          "type" : "string"
        },
        "crd-version" : {
          "description" : "The Consumer CRD Resource Version we would like to watch",
          "type" : "string"
        },
        "dns-domain" : {
          "description" : "The dns domain, used for ServiceCall EIP",
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "kubernetes-client" : {
          "description" : "Default KubernetesClient to use if provided",
          "type" : "string"
        },
        "label-key" : {
          "description" : "The Consumer Label key when watching at some resources",
          "type" : "string"
        },
        "label-value" : {
          "description" : "The Consumer Label value when watching at some resources",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "namespace" : {
          "description" : "The namespace",
          "type" : "string"
        },
        "oauth-token" : {
          "description" : "The Auth Token",
          "type" : "string"
        },
        "operation" : {
          "description" : "Producer operation to do on Kubernetes",
          "type" : "string"
        },
        "password" : {
          "description" : "Password to connect to Kubernetes",
          "type" : "string"
        },
        "pool-size" : {
          "description" : "The Consumer pool size",
          "default" : "1",
          "type" : "integer"
        },
        "port-name" : {
          "description" : "The port name, used for ServiceCall EIP",
          "type" : "string"
        },
        "port-protocol" : {
          "description" : "The port protocol, used for ServiceCall EIP",
          "default" : "tcp",
          "type" : "string"
        },
        "resource-name" : {
          "description" : "The Consumer Resource Name we would like to watch",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "trust-certs" : {
          "description" : "Define if the certs we used are trusted anyway or not",
          "type" : "boolean"
        },
        "username" : {
          "description" : "Username to connect to Kubernetes",
          "type" : "string"
        }
      }
    },
    "kubernetes-hpa" : {
      "type" : "object",
      "required" : [ "masterUrl" ],
      "properties" : {
        "master-url" : {
          "description" : "Kubernetes Master url",
          "type" : "string"
        },
        "api-version" : {
          "description" : "The Kubernetes API Version to use",
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "ca-cert-data" : {
          "description" : "The CA Cert Data",
          "type" : "string"
        },
        "ca-cert-file" : {
          "description" : "The CA Cert File",
          "type" : "string"
        },
        "client-cert-data" : {
          "description" : "The Client Cert Data",
          "type" : "string"
        },
        "client-cert-file" : {
          "description" : "The Client Cert File",
          "type" : "string"
        },
        "client-key-algo" : {
          "description" : "The Key Algorithm used by the client",
          "type" : "string"
        },
        "client-key-data" : {
          "description" : "The Client Key data",
          "type" : "string"
        },
        "client-key-file" : {
          "description" : "The Client Key file",
          "type" : "string"
        },
        "client-key-passphrase" : {
          "description" : "The Client Key Passphrase",
          "type" : "string"
        },
        "connection-timeout" : {
          "description" : "Connection timeout in milliseconds to use when making requests to the Kubernetes API server.",
          "type" : "integer"
        },
        "crd-group" : {
          "description" : "The Consumer CRD Resource Group we would like to watch",
          "type" : "string"
        },
        "crd-name" : {
          "description" : "The Consumer CRD Resource name we would like to watch",
          "type" : "string"
        },
        "crd-plural" : {
          "description" : "The Consumer CRD Resource Plural we would like to watch",
          "type" : "string"
        },
        "crd-scope" : {
          "description" : "The Consumer CRD Resource Scope we would like to watch",
          "type" : "string"
        },
        "crd-version" : {
          "description" : "The Consumer CRD Resource Version we would like to watch",
          "type" : "string"
        },
        "dns-domain" : {
          "description" : "The dns domain, used for ServiceCall EIP",
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "kubernetes-client" : {
          "description" : "Default KubernetesClient to use if provided",
          "type" : "string"
        },
        "label-key" : {
          "description" : "The Consumer Label key when watching at some resources",
          "type" : "string"
        },
        "label-value" : {
          "description" : "The Consumer Label value when watching at some resources",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "namespace" : {
          "description" : "The namespace",
          "type" : "string"
        },
        "oauth-token" : {
          "description" : "The Auth Token",
          "type" : "string"
        },
        "operation" : {
          "description" : "Producer operation to do on Kubernetes",
          "type" : "string"
        },
        "password" : {
          "description" : "Password to connect to Kubernetes",
          "type" : "string"
        },
        "pool-size" : {
          "description" : "The Consumer pool size",
          "default" : "1",
          "type" : "integer"
        },
        "port-name" : {
          "description" : "The port name, used for ServiceCall EIP",
          "type" : "string"
        },
        "port-protocol" : {
          "description" : "The port protocol, used for ServiceCall EIP",
          "default" : "tcp",
          "type" : "string"
        },
        "resource-name" : {
          "description" : "The Consumer Resource Name we would like to watch",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "trust-certs" : {
          "description" : "Define if the certs we used are trusted anyway or not",
          "type" : "boolean"
        },
        "username" : {
          "description" : "Username to connect to Kubernetes",
          "type" : "string"
        }
      }
    },
    "kubernetes-job" : {
      "type" : "object",
      "required" : [ "masterUrl" ],
      "properties" : {
        "master-url" : {
          "description" : "Kubernetes Master url",
          "type" : "string"
        },
        "api-version" : {
          "description" : "The Kubernetes API Version to use",
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "ca-cert-data" : {
          "description" : "The CA Cert Data",
          "type" : "string"
        },
        "ca-cert-file" : {
          "description" : "The CA Cert File",
          "type" : "string"
        },
        "client-cert-data" : {
          "description" : "The Client Cert Data",
          "type" : "string"
        },
        "client-cert-file" : {
          "description" : "The Client Cert File",
          "type" : "string"
        },
        "client-key-algo" : {
          "description" : "The Key Algorithm used by the client",
          "type" : "string"
        },
        "client-key-data" : {
          "description" : "The Client Key data",
          "type" : "string"
        },
        "client-key-file" : {
          "description" : "The Client Key file",
          "type" : "string"
        },
        "client-key-passphrase" : {
          "description" : "The Client Key Passphrase",
          "type" : "string"
        },
        "connection-timeout" : {
          "description" : "Connection timeout in milliseconds to use when making requests to the Kubernetes API server.",
          "type" : "integer"
        },
        "crd-group" : {
          "description" : "The Consumer CRD Resource Group we would like to watch",
          "type" : "string"
        },
        "crd-name" : {
          "description" : "The Consumer CRD Resource name we would like to watch",
          "type" : "string"
        },
        "crd-plural" : {
          "description" : "The Consumer CRD Resource Plural we would like to watch",
          "type" : "string"
        },
        "crd-scope" : {
          "description" : "The Consumer CRD Resource Scope we would like to watch",
          "type" : "string"
        },
        "crd-version" : {
          "description" : "The Consumer CRD Resource Version we would like to watch",
          "type" : "string"
        },
        "dns-domain" : {
          "description" : "The dns domain, used for ServiceCall EIP",
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "kubernetes-client" : {
          "description" : "Default KubernetesClient to use if provided",
          "type" : "string"
        },
        "label-key" : {
          "description" : "The Consumer Label key when watching at some resources",
          "type" : "string"
        },
        "label-value" : {
          "description" : "The Consumer Label value when watching at some resources",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "namespace" : {
          "description" : "The namespace",
          "type" : "string"
        },
        "oauth-token" : {
          "description" : "The Auth Token",
          "type" : "string"
        },
        "operation" : {
          "description" : "Producer operation to do on Kubernetes",
          "type" : "string"
        },
        "password" : {
          "description" : "Password to connect to Kubernetes",
          "type" : "string"
        },
        "pool-size" : {
          "description" : "The Consumer pool size",
          "default" : "1",
          "type" : "integer"
        },
        "port-name" : {
          "description" : "The port name, used for ServiceCall EIP",
          "type" : "string"
        },
        "port-protocol" : {
          "description" : "The port protocol, used for ServiceCall EIP",
          "default" : "tcp",
          "type" : "string"
        },
        "resource-name" : {
          "description" : "The Consumer Resource Name we would like to watch",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "trust-certs" : {
          "description" : "Define if the certs we used are trusted anyway or not",
          "type" : "boolean"
        },
        "username" : {
          "description" : "Username to connect to Kubernetes",
          "type" : "string"
        }
      }
    },
    "kubernetes-namespaces" : {
      "type" : "object",
      "required" : [ "masterUrl" ],
      "properties" : {
        "master-url" : {
          "description" : "Kubernetes Master url",
          "type" : "string"
        },
        "api-version" : {
          "description" : "The Kubernetes API Version to use",
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "ca-cert-data" : {
          "description" : "The CA Cert Data",
          "type" : "string"
        },
        "ca-cert-file" : {
          "description" : "The CA Cert File",
          "type" : "string"
        },
        "client-cert-data" : {
          "description" : "The Client Cert Data",
          "type" : "string"
        },
        "client-cert-file" : {
          "description" : "The Client Cert File",
          "type" : "string"
        },
        "client-key-algo" : {
          "description" : "The Key Algorithm used by the client",
          "type" : "string"
        },
        "client-key-data" : {
          "description" : "The Client Key data",
          "type" : "string"
        },
        "client-key-file" : {
          "description" : "The Client Key file",
          "type" : "string"
        },
        "client-key-passphrase" : {
          "description" : "The Client Key Passphrase",
          "type" : "string"
        },
        "connection-timeout" : {
          "description" : "Connection timeout in milliseconds to use when making requests to the Kubernetes API server.",
          "type" : "integer"
        },
        "crd-group" : {
          "description" : "The Consumer CRD Resource Group we would like to watch",
          "type" : "string"
        },
        "crd-name" : {
          "description" : "The Consumer CRD Resource name we would like to watch",
          "type" : "string"
        },
        "crd-plural" : {
          "description" : "The Consumer CRD Resource Plural we would like to watch",
          "type" : "string"
        },
        "crd-scope" : {
          "description" : "The Consumer CRD Resource Scope we would like to watch",
          "type" : "string"
        },
        "crd-version" : {
          "description" : "The Consumer CRD Resource Version we would like to watch",
          "type" : "string"
        },
        "dns-domain" : {
          "description" : "The dns domain, used for ServiceCall EIP",
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "kubernetes-client" : {
          "description" : "Default KubernetesClient to use if provided",
          "type" : "string"
        },
        "label-key" : {
          "description" : "The Consumer Label key when watching at some resources",
          "type" : "string"
        },
        "label-value" : {
          "description" : "The Consumer Label value when watching at some resources",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "namespace" : {
          "description" : "The namespace",
          "type" : "string"
        },
        "oauth-token" : {
          "description" : "The Auth Token",
          "type" : "string"
        },
        "operation" : {
          "description" : "Producer operation to do on Kubernetes",
          "type" : "string"
        },
        "password" : {
          "description" : "Password to connect to Kubernetes",
          "type" : "string"
        },
        "pool-size" : {
          "description" : "The Consumer pool size",
          "default" : "1",
          "type" : "integer"
        },
        "port-name" : {
          "description" : "The port name, used for ServiceCall EIP",
          "type" : "string"
        },
        "port-protocol" : {
          "description" : "The port protocol, used for ServiceCall EIP",
          "default" : "tcp",
          "type" : "string"
        },
        "resource-name" : {
          "description" : "The Consumer Resource Name we would like to watch",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "trust-certs" : {
          "description" : "Define if the certs we used are trusted anyway or not",
          "type" : "boolean"
        },
        "username" : {
          "description" : "Username to connect to Kubernetes",
          "type" : "string"
        }
      }
    },
    "kubernetes-nodes" : {
      "type" : "object",
      "required" : [ "masterUrl" ],
      "properties" : {
        "master-url" : {
          "description" : "Kubernetes Master url",
          "type" : "string"
        },
        "api-version" : {
          "description" : "The Kubernetes API Version to use",
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "ca-cert-data" : {
          "description" : "The CA Cert Data",
          "type" : "string"
        },
        "ca-cert-file" : {
          "description" : "The CA Cert File",
          "type" : "string"
        },
        "client-cert-data" : {
          "description" : "The Client Cert Data",
          "type" : "string"
        },
        "client-cert-file" : {
          "description" : "The Client Cert File",
          "type" : "string"
        },
        "client-key-algo" : {
          "description" : "The Key Algorithm used by the client",
          "type" : "string"
        },
        "client-key-data" : {
          "description" : "The Client Key data",
          "type" : "string"
        },
        "client-key-file" : {
          "description" : "The Client Key file",
          "type" : "string"
        },
        "client-key-passphrase" : {
          "description" : "The Client Key Passphrase",
          "type" : "string"
        },
        "connection-timeout" : {
          "description" : "Connection timeout in milliseconds to use when making requests to the Kubernetes API server.",
          "type" : "integer"
        },
        "crd-group" : {
          "description" : "The Consumer CRD Resource Group we would like to watch",
          "type" : "string"
        },
        "crd-name" : {
          "description" : "The Consumer CRD Resource name we would like to watch",
          "type" : "string"
        },
        "crd-plural" : {
          "description" : "The Consumer CRD Resource Plural we would like to watch",
          "type" : "string"
        },
        "crd-scope" : {
          "description" : "The Consumer CRD Resource Scope we would like to watch",
          "type" : "string"
        },
        "crd-version" : {
          "description" : "The Consumer CRD Resource Version we would like to watch",
          "type" : "string"
        },
        "dns-domain" : {
          "description" : "The dns domain, used for ServiceCall EIP",
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "kubernetes-client" : {
          "description" : "Default KubernetesClient to use if provided",
          "type" : "string"
        },
        "label-key" : {
          "description" : "The Consumer Label key when watching at some resources",
          "type" : "string"
        },
        "label-value" : {
          "description" : "The Consumer Label value when watching at some resources",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "namespace" : {
          "description" : "The namespace",
          "type" : "string"
        },
        "oauth-token" : {
          "description" : "The Auth Token",
          "type" : "string"
        },
        "operation" : {
          "description" : "Producer operation to do on Kubernetes",
          "type" : "string"
        },
        "password" : {
          "description" : "Password to connect to Kubernetes",
          "type" : "string"
        },
        "pool-size" : {
          "description" : "The Consumer pool size",
          "default" : "1",
          "type" : "integer"
        },
        "port-name" : {
          "description" : "The port name, used for ServiceCall EIP",
          "type" : "string"
        },
        "port-protocol" : {
          "description" : "The port protocol, used for ServiceCall EIP",
          "default" : "tcp",
          "type" : "string"
        },
        "resource-name" : {
          "description" : "The Consumer Resource Name we would like to watch",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "trust-certs" : {
          "description" : "Define if the certs we used are trusted anyway or not",
          "type" : "boolean"
        },
        "username" : {
          "description" : "Username to connect to Kubernetes",
          "type" : "string"
        }
      }
    },
    "kubernetes-persistent-volumes" : {
      "type" : "object",
      "required" : [ "masterUrl" ],
      "properties" : {
        "master-url" : {
          "description" : "Kubernetes Master url",
          "type" : "string"
        },
        "api-version" : {
          "description" : "The Kubernetes API Version to use",
          "type" : "string"
        },
        "ca-cert-data" : {
          "description" : "The CA Cert Data",
          "type" : "string"
        },
        "ca-cert-file" : {
          "description" : "The CA Cert File",
          "type" : "string"
        },
        "client-cert-data" : {
          "description" : "The Client Cert Data",
          "type" : "string"
        },
        "client-cert-file" : {
          "description" : "The Client Cert File",
          "type" : "string"
        },
        "client-key-algo" : {
          "description" : "The Key Algorithm used by the client",
          "type" : "string"
        },
        "client-key-data" : {
          "description" : "The Client Key data",
          "type" : "string"
        },
        "client-key-file" : {
          "description" : "The Client Key file",
          "type" : "string"
        },
        "client-key-passphrase" : {
          "description" : "The Client Key Passphrase",
          "type" : "string"
        },
        "connection-timeout" : {
          "description" : "Connection timeout in milliseconds to use when making requests to the Kubernetes API server.",
          "type" : "integer"
        },
        "dns-domain" : {
          "description" : "The dns domain, used for ServiceCall EIP",
          "type" : "string"
        },
        "kubernetes-client" : {
          "description" : "Default KubernetesClient to use if provided",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "oauth-token" : {
          "description" : "The Auth Token",
          "type" : "string"
        },
        "operation" : {
          "description" : "Producer operation to do on Kubernetes",
          "type" : "string"
        },
        "password" : {
          "description" : "Password to connect to Kubernetes",
          "type" : "string"
        },
        "port-name" : {
          "description" : "The port name, used for ServiceCall EIP",
          "type" : "string"
        },
        "port-protocol" : {
          "description" : "The port protocol, used for ServiceCall EIP",
          "default" : "tcp",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "trust-certs" : {
          "description" : "Define if the certs we used are trusted anyway or not",
          "type" : "boolean"
        },
        "username" : {
          "description" : "Username to connect to Kubernetes",
          "type" : "string"
        }
      }
    },
    "kubernetes-persistent-volumes-claims" : {
      "type" : "object",
      "required" : [ "masterUrl" ],
      "properties" : {
        "master-url" : {
          "description" : "Kubernetes Master url",
          "type" : "string"
        },
        "api-version" : {
          "description" : "The Kubernetes API Version to use",
          "type" : "string"
        },
        "ca-cert-data" : {
          "description" : "The CA Cert Data",
          "type" : "string"
        },
        "ca-cert-file" : {
          "description" : "The CA Cert File",
          "type" : "string"
        },
        "client-cert-data" : {
          "description" : "The Client Cert Data",
          "type" : "string"
        },
        "client-cert-file" : {
          "description" : "The Client Cert File",
          "type" : "string"
        },
        "client-key-algo" : {
          "description" : "The Key Algorithm used by the client",
          "type" : "string"
        },
        "client-key-data" : {
          "description" : "The Client Key data",
          "type" : "string"
        },
        "client-key-file" : {
          "description" : "The Client Key file",
          "type" : "string"
        },
        "client-key-passphrase" : {
          "description" : "The Client Key Passphrase",
          "type" : "string"
        },
        "connection-timeout" : {
          "description" : "Connection timeout in milliseconds to use when making requests to the Kubernetes API server.",
          "type" : "integer"
        },
        "dns-domain" : {
          "description" : "The dns domain, used for ServiceCall EIP",
          "type" : "string"
        },
        "kubernetes-client" : {
          "description" : "Default KubernetesClient to use if provided",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "oauth-token" : {
          "description" : "The Auth Token",
          "type" : "string"
        },
        "operation" : {
          "description" : "Producer operation to do on Kubernetes",
          "type" : "string"
        },
        "password" : {
          "description" : "Password to connect to Kubernetes",
          "type" : "string"
        },
        "port-name" : {
          "description" : "The port name, used for ServiceCall EIP",
          "type" : "string"
        },
        "port-protocol" : {
          "description" : "The port protocol, used for ServiceCall EIP",
          "default" : "tcp",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "trust-certs" : {
          "description" : "Define if the certs we used are trusted anyway or not",
          "type" : "boolean"
        },
        "username" : {
          "description" : "Username to connect to Kubernetes",
          "type" : "string"
        }
      }
    },
    "kubernetes-pods" : {
      "type" : "object",
      "required" : [ "masterUrl" ],
      "properties" : {
        "master-url" : {
          "description" : "Kubernetes Master url",
          "type" : "string"
        },
        "api-version" : {
          "description" : "The Kubernetes API Version to use",
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "ca-cert-data" : {
          "description" : "The CA Cert Data",
          "type" : "string"
        },
        "ca-cert-file" : {
          "description" : "The CA Cert File",
          "type" : "string"
        },
        "client-cert-data" : {
          "description" : "The Client Cert Data",
          "type" : "string"
        },
        "client-cert-file" : {
          "description" : "The Client Cert File",
          "type" : "string"
        },
        "client-key-algo" : {
          "description" : "The Key Algorithm used by the client",
          "type" : "string"
        },
        "client-key-data" : {
          "description" : "The Client Key data",
          "type" : "string"
        },
        "client-key-file" : {
          "description" : "The Client Key file",
          "type" : "string"
        },
        "client-key-passphrase" : {
          "description" : "The Client Key Passphrase",
          "type" : "string"
        },
        "connection-timeout" : {
          "description" : "Connection timeout in milliseconds to use when making requests to the Kubernetes API server.",
          "type" : "integer"
        },
        "crd-group" : {
          "description" : "The Consumer CRD Resource Group we would like to watch",
          "type" : "string"
        },
        "crd-name" : {
          "description" : "The Consumer CRD Resource name we would like to watch",
          "type" : "string"
        },
        "crd-plural" : {
          "description" : "The Consumer CRD Resource Plural we would like to watch",
          "type" : "string"
        },
        "crd-scope" : {
          "description" : "The Consumer CRD Resource Scope we would like to watch",
          "type" : "string"
        },
        "crd-version" : {
          "description" : "The Consumer CRD Resource Version we would like to watch",
          "type" : "string"
        },
        "dns-domain" : {
          "description" : "The dns domain, used for ServiceCall EIP",
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "kubernetes-client" : {
          "description" : "Default KubernetesClient to use if provided",
          "type" : "string"
        },
        "label-key" : {
          "description" : "The Consumer Label key when watching at some resources",
          "type" : "string"
        },
        "label-value" : {
          "description" : "The Consumer Label value when watching at some resources",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "namespace" : {
          "description" : "The namespace",
          "type" : "string"
        },
        "oauth-token" : {
          "description" : "The Auth Token",
          "type" : "string"
        },
        "operation" : {
          "description" : "Producer operation to do on Kubernetes",
          "type" : "string"
        },
        "password" : {
          "description" : "Password to connect to Kubernetes",
          "type" : "string"
        },
        "pool-size" : {
          "description" : "The Consumer pool size",
          "default" : "1",
          "type" : "integer"
        },
        "port-name" : {
          "description" : "The port name, used for ServiceCall EIP",
          "type" : "string"
        },
        "port-protocol" : {
          "description" : "The port protocol, used for ServiceCall EIP",
          "default" : "tcp",
          "type" : "string"
        },
        "resource-name" : {
          "description" : "The Consumer Resource Name we would like to watch",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "trust-certs" : {
          "description" : "Define if the certs we used are trusted anyway or not",
          "type" : "boolean"
        },
        "username" : {
          "description" : "Username to connect to Kubernetes",
          "type" : "string"
        }
      }
    },
    "kubernetes-replication-controllers" : {
      "type" : "object",
      "required" : [ "masterUrl" ],
      "properties" : {
        "master-url" : {
          "description" : "Kubernetes Master url",
          "type" : "string"
        },
        "api-version" : {
          "description" : "The Kubernetes API Version to use",
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "ca-cert-data" : {
          "description" : "The CA Cert Data",
          "type" : "string"
        },
        "ca-cert-file" : {
          "description" : "The CA Cert File",
          "type" : "string"
        },
        "client-cert-data" : {
          "description" : "The Client Cert Data",
          "type" : "string"
        },
        "client-cert-file" : {
          "description" : "The Client Cert File",
          "type" : "string"
        },
        "client-key-algo" : {
          "description" : "The Key Algorithm used by the client",
          "type" : "string"
        },
        "client-key-data" : {
          "description" : "The Client Key data",
          "type" : "string"
        },
        "client-key-file" : {
          "description" : "The Client Key file",
          "type" : "string"
        },
        "client-key-passphrase" : {
          "description" : "The Client Key Passphrase",
          "type" : "string"
        },
        "connection-timeout" : {
          "description" : "Connection timeout in milliseconds to use when making requests to the Kubernetes API server.",
          "type" : "integer"
        },
        "crd-group" : {
          "description" : "The Consumer CRD Resource Group we would like to watch",
          "type" : "string"
        },
        "crd-name" : {
          "description" : "The Consumer CRD Resource name we would like to watch",
          "type" : "string"
        },
        "crd-plural" : {
          "description" : "The Consumer CRD Resource Plural we would like to watch",
          "type" : "string"
        },
        "crd-scope" : {
          "description" : "The Consumer CRD Resource Scope we would like to watch",
          "type" : "string"
        },
        "crd-version" : {
          "description" : "The Consumer CRD Resource Version we would like to watch",
          "type" : "string"
        },
        "dns-domain" : {
          "description" : "The dns domain, used for ServiceCall EIP",
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "kubernetes-client" : {
          "description" : "Default KubernetesClient to use if provided",
          "type" : "string"
        },
        "label-key" : {
          "description" : "The Consumer Label key when watching at some resources",
          "type" : "string"
        },
        "label-value" : {
          "description" : "The Consumer Label value when watching at some resources",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "namespace" : {
          "description" : "The namespace",
          "type" : "string"
        },
        "oauth-token" : {
          "description" : "The Auth Token",
          "type" : "string"
        },
        "operation" : {
          "description" : "Producer operation to do on Kubernetes",
          "type" : "string"
        },
        "password" : {
          "description" : "Password to connect to Kubernetes",
          "type" : "string"
        },
        "pool-size" : {
          "description" : "The Consumer pool size",
          "default" : "1",
          "type" : "integer"
        },
        "port-name" : {
          "description" : "The port name, used for ServiceCall EIP",
          "type" : "string"
        },
        "port-protocol" : {
          "description" : "The port protocol, used for ServiceCall EIP",
          "default" : "tcp",
          "type" : "string"
        },
        "resource-name" : {
          "description" : "The Consumer Resource Name we would like to watch",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "trust-certs" : {
          "description" : "Define if the certs we used are trusted anyway or not",
          "type" : "boolean"
        },
        "username" : {
          "description" : "Username to connect to Kubernetes",
          "type" : "string"
        }
      }
    },
    "kubernetes-resources-quota" : {
      "type" : "object",
      "required" : [ "masterUrl" ],
      "properties" : {
        "master-url" : {
          "description" : "Kubernetes Master url",
          "type" : "string"
        },
        "api-version" : {
          "description" : "The Kubernetes API Version to use",
          "type" : "string"
        },
        "ca-cert-data" : {
          "description" : "The CA Cert Data",
          "type" : "string"
        },
        "ca-cert-file" : {
          "description" : "The CA Cert File",
          "type" : "string"
        },
        "client-cert-data" : {
          "description" : "The Client Cert Data",
          "type" : "string"
        },
        "client-cert-file" : {
          "description" : "The Client Cert File",
          "type" : "string"
        },
        "client-key-algo" : {
          "description" : "The Key Algorithm used by the client",
          "type" : "string"
        },
        "client-key-data" : {
          "description" : "The Client Key data",
          "type" : "string"
        },
        "client-key-file" : {
          "description" : "The Client Key file",
          "type" : "string"
        },
        "client-key-passphrase" : {
          "description" : "The Client Key Passphrase",
          "type" : "string"
        },
        "connection-timeout" : {
          "description" : "Connection timeout in milliseconds to use when making requests to the Kubernetes API server.",
          "type" : "integer"
        },
        "dns-domain" : {
          "description" : "The dns domain, used for ServiceCall EIP",
          "type" : "string"
        },
        "kubernetes-client" : {
          "description" : "Default KubernetesClient to use if provided",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "oauth-token" : {
          "description" : "The Auth Token",
          "type" : "string"
        },
        "operation" : {
          "description" : "Producer operation to do on Kubernetes",
          "type" : "string"
        },
        "password" : {
          "description" : "Password to connect to Kubernetes",
          "type" : "string"
        },
        "port-name" : {
          "description" : "The port name, used for ServiceCall EIP",
          "type" : "string"
        },
        "port-protocol" : {
          "description" : "The port protocol, used for ServiceCall EIP",
          "default" : "tcp",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "trust-certs" : {
          "description" : "Define if the certs we used are trusted anyway or not",
          "type" : "boolean"
        },
        "username" : {
          "description" : "Username to connect to Kubernetes",
          "type" : "string"
        }
      }
    },
    "kubernetes-secrets" : {
      "type" : "object",
      "required" : [ "masterUrl" ],
      "properties" : {
        "master-url" : {
          "description" : "Kubernetes Master url",
          "type" : "string"
        },
        "api-version" : {
          "description" : "The Kubernetes API Version to use",
          "type" : "string"
        },
        "ca-cert-data" : {
          "description" : "The CA Cert Data",
          "type" : "string"
        },
        "ca-cert-file" : {
          "description" : "The CA Cert File",
          "type" : "string"
        },
        "client-cert-data" : {
          "description" : "The Client Cert Data",
          "type" : "string"
        },
        "client-cert-file" : {
          "description" : "The Client Cert File",
          "type" : "string"
        },
        "client-key-algo" : {
          "description" : "The Key Algorithm used by the client",
          "type" : "string"
        },
        "client-key-data" : {
          "description" : "The Client Key data",
          "type" : "string"
        },
        "client-key-file" : {
          "description" : "The Client Key file",
          "type" : "string"
        },
        "client-key-passphrase" : {
          "description" : "The Client Key Passphrase",
          "type" : "string"
        },
        "connection-timeout" : {
          "description" : "Connection timeout in milliseconds to use when making requests to the Kubernetes API server.",
          "type" : "integer"
        },
        "dns-domain" : {
          "description" : "The dns domain, used for ServiceCall EIP",
          "type" : "string"
        },
        "kubernetes-client" : {
          "description" : "Default KubernetesClient to use if provided",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "oauth-token" : {
          "description" : "The Auth Token",
          "type" : "string"
        },
        "operation" : {
          "description" : "Producer operation to do on Kubernetes",
          "type" : "string"
        },
        "password" : {
          "description" : "Password to connect to Kubernetes",
          "type" : "string"
        },
        "port-name" : {
          "description" : "The port name, used for ServiceCall EIP",
          "type" : "string"
        },
        "port-protocol" : {
          "description" : "The port protocol, used for ServiceCall EIP",
          "default" : "tcp",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "trust-certs" : {
          "description" : "Define if the certs we used are trusted anyway or not",
          "type" : "boolean"
        },
        "username" : {
          "description" : "Username to connect to Kubernetes",
          "type" : "string"
        }
      }
    },
    "kubernetes-service-accounts" : {
      "type" : "object",
      "required" : [ "masterUrl" ],
      "properties" : {
        "master-url" : {
          "description" : "Kubernetes Master url",
          "type" : "string"
        },
        "api-version" : {
          "description" : "The Kubernetes API Version to use",
          "type" : "string"
        },
        "ca-cert-data" : {
          "description" : "The CA Cert Data",
          "type" : "string"
        },
        "ca-cert-file" : {
          "description" : "The CA Cert File",
          "type" : "string"
        },
        "client-cert-data" : {
          "description" : "The Client Cert Data",
          "type" : "string"
        },
        "client-cert-file" : {
          "description" : "The Client Cert File",
          "type" : "string"
        },
        "client-key-algo" : {
          "description" : "The Key Algorithm used by the client",
          "type" : "string"
        },
        "client-key-data" : {
          "description" : "The Client Key data",
          "type" : "string"
        },
        "client-key-file" : {
          "description" : "The Client Key file",
          "type" : "string"
        },
        "client-key-passphrase" : {
          "description" : "The Client Key Passphrase",
          "type" : "string"
        },
        "connection-timeout" : {
          "description" : "Connection timeout in milliseconds to use when making requests to the Kubernetes API server.",
          "type" : "integer"
        },
        "dns-domain" : {
          "description" : "The dns domain, used for ServiceCall EIP",
          "type" : "string"
        },
        "kubernetes-client" : {
          "description" : "Default KubernetesClient to use if provided",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "oauth-token" : {
          "description" : "The Auth Token",
          "type" : "string"
        },
        "operation" : {
          "description" : "Producer operation to do on Kubernetes",
          "type" : "string"
        },
        "password" : {
          "description" : "Password to connect to Kubernetes",
          "type" : "string"
        },
        "port-name" : {
          "description" : "The port name, used for ServiceCall EIP",
          "type" : "string"
        },
        "port-protocol" : {
          "description" : "The port protocol, used for ServiceCall EIP",
          "default" : "tcp",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "trust-certs" : {
          "description" : "Define if the certs we used are trusted anyway or not",
          "type" : "boolean"
        },
        "username" : {
          "description" : "Username to connect to Kubernetes",
          "type" : "string"
        }
      }
    },
    "kubernetes-services" : {
      "type" : "object",
      "required" : [ "masterUrl" ],
      "properties" : {
        "master-url" : {
          "description" : "Kubernetes Master url",
          "type" : "string"
        },
        "api-version" : {
          "description" : "The Kubernetes API Version to use",
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "ca-cert-data" : {
          "description" : "The CA Cert Data",
          "type" : "string"
        },
        "ca-cert-file" : {
          "description" : "The CA Cert File",
          "type" : "string"
        },
        "client-cert-data" : {
          "description" : "The Client Cert Data",
          "type" : "string"
        },
        "client-cert-file" : {
          "description" : "The Client Cert File",
          "type" : "string"
        },
        "client-key-algo" : {
          "description" : "The Key Algorithm used by the client",
          "type" : "string"
        },
        "client-key-data" : {
          "description" : "The Client Key data",
          "type" : "string"
        },
        "client-key-file" : {
          "description" : "The Client Key file",
          "type" : "string"
        },
        "client-key-passphrase" : {
          "description" : "The Client Key Passphrase",
          "type" : "string"
        },
        "connection-timeout" : {
          "description" : "Connection timeout in milliseconds to use when making requests to the Kubernetes API server.",
          "type" : "integer"
        },
        "crd-group" : {
          "description" : "The Consumer CRD Resource Group we would like to watch",
          "type" : "string"
        },
        "crd-name" : {
          "description" : "The Consumer CRD Resource name we would like to watch",
          "type" : "string"
        },
        "crd-plural" : {
          "description" : "The Consumer CRD Resource Plural we would like to watch",
          "type" : "string"
        },
        "crd-scope" : {
          "description" : "The Consumer CRD Resource Scope we would like to watch",
          "type" : "string"
        },
        "crd-version" : {
          "description" : "The Consumer CRD Resource Version we would like to watch",
          "type" : "string"
        },
        "dns-domain" : {
          "description" : "The dns domain, used for ServiceCall EIP",
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "kubernetes-client" : {
          "description" : "Default KubernetesClient to use if provided",
          "type" : "string"
        },
        "label-key" : {
          "description" : "The Consumer Label key when watching at some resources",
          "type" : "string"
        },
        "label-value" : {
          "description" : "The Consumer Label value when watching at some resources",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "namespace" : {
          "description" : "The namespace",
          "type" : "string"
        },
        "oauth-token" : {
          "description" : "The Auth Token",
          "type" : "string"
        },
        "operation" : {
          "description" : "Producer operation to do on Kubernetes",
          "type" : "string"
        },
        "password" : {
          "description" : "Password to connect to Kubernetes",
          "type" : "string"
        },
        "pool-size" : {
          "description" : "The Consumer pool size",
          "default" : "1",
          "type" : "integer"
        },
        "port-name" : {
          "description" : "The port name, used for ServiceCall EIP",
          "type" : "string"
        },
        "port-protocol" : {
          "description" : "The port protocol, used for ServiceCall EIP",
          "default" : "tcp",
          "type" : "string"
        },
        "resource-name" : {
          "description" : "The Consumer Resource Name we would like to watch",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "trust-certs" : {
          "description" : "Define if the certs we used are trusted anyway or not",
          "type" : "boolean"
        },
        "username" : {
          "description" : "Username to connect to Kubernetes",
          "type" : "string"
        }
      }
    },
    "kudu" : {
      "type" : "object",
      "properties" : {
        "host" : {
          "description" : "Host of the server to connect to",
          "type" : "string"
        },
        "port" : {
          "description" : "Port of the server to connect to",
          "type" : "string"
        },
        "table-name" : {
          "description" : "Table to connect to",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "operation" : {
          "description" : "Operation to perform",
          "enum" : [ "INSERT", "CREATE_TABLE", "SCAN" ],
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "language" : {
      "type" : "object",
      "required" : [ "languageName" ],
      "properties" : {
        "language-name" : {
          "description" : "Sets the name of the language to use",
          "enum" : [ "bean", "constant", "exchangeProperty", "file", "groovy", "header", "javascript", "jsonpath", "mvel", "ognl", "", "ref", "simple", "spel", "sql", "terser", "tokenize", "xpath", "xquery", "xtokenize" ],
          "type" : "string"
        },
        "resource-uri" : {
          "description" : "Path to the resource, or a reference to lookup a bean in the Registry to use as the resource",
          "type" : "string"
        },
        "allow-context-map-all" : {
          "description" : "Sets whether the context map should allow access to all details. By default only the message body and headers can be accessed. This option can be enabled for full access to the current Exchange and CamelContext. Doing so impose a potential security risk as this opens access to the full power of CamelContext API.",
          "default" : "false",
          "type" : "boolean"
        },
        "binary" : {
          "description" : "Whether the script is binary content or text content. By default the script is read as text content (eg java.lang.String)",
          "default" : "false",
          "type" : "boolean"
        },
        "cache-script" : {
          "description" : "Whether to cache the compiled script and reuse Notice reusing the script can cause side effects from processing one Camel org.apache.camel.Exchange to the next org.apache.camel.Exchange.",
          "default" : "false",
          "type" : "boolean"
        },
        "content-cache" : {
          "description" : "Sets whether to use resource content cache or not",
          "default" : "true",
          "type" : "boolean"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "script" : {
          "description" : "Sets the script to execute",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "transform" : {
          "description" : "Whether or not the result of the script should be used as message body. This options is default true.",
          "default" : "true",
          "type" : "boolean"
        }
      }
    },
    "ldap" : {
      "type" : "object",
      "required" : [ "dirContextName" ],
      "properties" : {
        "dir-context-name" : {
          "description" : "Name of either a javax.naming.directory.DirContext, or java.util.Hashtable, or Map bean to lookup in the registry. If the bean is either a Hashtable or Map then a new javax.naming.directory.DirContext instance is created for each use. If the bean is a javax.naming.directory.DirContext then the bean is used as given. The latter may not be possible in all situations where the javax.naming.directory.DirContext must not be shared, and in those situations it can be better to use java.util.Hashtable or Map instead.",
          "type" : "string"
        },
        "base" : {
          "description" : "The base DN for searches.",
          "default" : "ou=system",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "page-size" : {
          "description" : "When specified the ldap module uses paging to retrieve all results (most LDAP Servers throw an exception when trying to retrieve more than 1000 entries in one query). To be able to use this a LdapContext (subclass of DirContext) has to be passed in as ldapServerBean (otherwise an exception is thrown)",
          "type" : "integer"
        },
        "returned-attributes" : {
          "description" : "Comma-separated list of attributes that should be set in each entry of the result",
          "type" : "string"
        },
        "scope" : {
          "description" : "Specifies how deeply to search the tree of entries, starting at the base DN.",
          "default" : "subtree",
          "enum" : [ "object", "onelevel", "subtree" ],
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "ldif" : {
      "type" : "object",
      "required" : [ "ldapConnectionName" ],
      "properties" : {
        "ldap-connection-name" : {
          "description" : "The name of the LdapConnection bean to pull from the registry. Note that this must be of scope prototype to avoid it being shared among threads or using a connection that has timed out.",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "log" : {
      "type" : "object",
      "required" : [ "loggerName" ],
      "properties" : {
        "logger-name" : {
          "description" : "Name of the logging category to use",
          "type" : "string"
        },
        "exchange-formatter" : {
          "description" : "To use a custom exchange formatter",
          "type" : "string"
        },
        "group-active-only" : {
          "description" : "If true, will hide stats when no new messages have been received for a time interval, if false, show stats regardless of message traffic.",
          "default" : "true",
          "type" : "boolean"
        },
        "group-delay" : {
          "description" : "Set the initial delay for stats (in millis)",
          "type" : "integer"
        },
        "group-interval" : {
          "description" : "If specified will group message stats by this time interval (in millis)",
          "type" : "integer"
        },
        "group-size" : {
          "description" : "An integer that specifies a group size for throughput logging.",
          "type" : "integer"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "level" : {
          "description" : "Logging level to use. The default value is INFO.",
          "default" : "INFO",
          "enum" : [ "ERROR", "WARN", "INFO", "DEBUG", "TRACE", "OFF" ],
          "type" : "string"
        },
        "log-mask" : {
          "description" : "If true, mask sensitive information like password or passphrase in the log.",
          "type" : "boolean"
        },
        "marker" : {
          "description" : "An optional Marker name to use.",
          "type" : "string"
        },
        "max-chars" : {
          "description" : "Limits the number of characters logged per line.",
          "default" : "10000",
          "type" : "integer"
        },
        "multiline" : {
          "description" : "If enabled then each information is outputted on a newline.",
          "default" : "false",
          "type" : "boolean"
        },
        "show-all" : {
          "description" : "Quick option for turning all options on. (multiline, maxChars has to be manually set if to be used)",
          "default" : "false",
          "type" : "boolean"
        },
        "show-body" : {
          "description" : "Show the message body.",
          "default" : "true",
          "type" : "boolean"
        },
        "show-body-type" : {
          "description" : "Show the body Java type.",
          "default" : "true",
          "type" : "boolean"
        },
        "show-caught-exception" : {
          "description" : "If the exchange has a caught exception, show the exception message (no stack trace). A caught exception is stored as a property on the exchange (using the key org.apache.camel.Exchange#EXCEPTION_CAUGHT) and for instance a doCatch can catch exceptions.",
          "default" : "false",
          "type" : "boolean"
        },
        "show-exception" : {
          "description" : "If the exchange has an exception, show the exception message (no stacktrace)",
          "default" : "false",
          "type" : "boolean"
        },
        "show-exchange-id" : {
          "description" : "Show the unique exchange ID.",
          "default" : "false",
          "type" : "boolean"
        },
        "show-exchange-pattern" : {
          "description" : "Shows the Message Exchange Pattern (or MEP for short).",
          "default" : "true",
          "type" : "boolean"
        },
        "show-files" : {
          "description" : "If enabled Camel will output files",
          "default" : "false",
          "type" : "boolean"
        },
        "show-future" : {
          "description" : "If enabled Camel will on Future objects wait for it to complete to obtain the payload to be logged.",
          "default" : "false",
          "type" : "boolean"
        },
        "show-headers" : {
          "description" : "Show the message headers.",
          "default" : "false",
          "type" : "boolean"
        },
        "show-properties" : {
          "description" : "Show the exchange properties.",
          "default" : "false",
          "type" : "boolean"
        },
        "show-stack-trace" : {
          "description" : "Show the stack trace, if an exchange has an exception. Only effective if one of showAll, showException or showCaughtException are enabled.",
          "default" : "false",
          "type" : "boolean"
        },
        "show-streams" : {
          "description" : "Whether Camel should show stream bodies or not (eg such as java.io.InputStream). Beware if you enable this option then you may not be able later to access the message body as the stream have already been read by this logger. To remedy this you will have to use Stream Caching.",
          "default" : "false",
          "type" : "boolean"
        },
        "skip-body-line-separator" : {
          "description" : "Whether to skip line separators when logging the message body. This allows to log the message body in one line, setting this option to false will preserve any line separators from the body, which then will log the body as is.",
          "default" : "true",
          "type" : "boolean"
        },
        "style" : {
          "description" : "Sets the outputs style to use.",
          "default" : "Default",
          "enum" : [ "Default", "Tab", "Fixed" ],
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "lpr" : {
      "type" : "object",
      "required" : [ "hostname" ],
      "properties" : {
        "hostname" : {
          "description" : "Hostname of the printer",
          "type" : "string"
        },
        "port" : {
          "description" : "Port number of the printer",
          "type" : "integer"
        },
        "printername" : {
          "description" : "Name of the printer",
          "type" : "string"
        },
        "copies" : {
          "description" : "Number of copies to print",
          "default" : "1",
          "type" : "integer"
        },
        "doc-flavor" : {
          "description" : "Sets DocFlavor to use.",
          "type" : "string"
        },
        "flavor" : {
          "description" : "Sets DocFlavor to use.",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "media-size" : {
          "description" : "Sets the stationary as defined by enumeration names in the javax.print.attribute.standard.MediaSizeName API. The default setting is to use North American Letter sized stationary. The value's case is ignored, e.g. values of iso_a4 and ISO_A4 may be used.",
          "default" : "na-letter",
          "type" : "string"
        },
        "media-tray" : {
          "description" : "Sets MediaTray supported by the javax.print.DocFlavor API, for example upper,middle etc.",
          "type" : "string"
        },
        "mime-type" : {
          "description" : "Sets mimeTypes supported by the javax.print.DocFlavor API",
          "type" : "string"
        },
        "orientation" : {
          "description" : "Sets the page orientation.",
          "default" : "portrait",
          "enum" : [ "portrait", "landscape", "reverse-portrait", "reverse-landscape" ],
          "type" : "string"
        },
        "printer-prefix" : {
          "description" : "Sets the prefix name of the printer, it is useful when the printer name does not start with //hostname/printer",
          "type" : "string"
        },
        "send-to-printer" : {
          "description" : "etting this option to false prevents sending of the print data to the printer",
          "default" : "true",
          "type" : "boolean"
        },
        "sides" : {
          "description" : "Sets one sided or two sided printing based on the javax.print.attribute.standard.Sides API",
          "default" : "one-sided",
          "enum" : [ "one-sided", "duplex", "tumble", "two-sided-short-edge", "two-sided-long-edge" ],
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "lucene" : {
      "type" : "object",
      "required" : [ "host", "operation" ],
      "properties" : {
        "host" : {
          "description" : "The URL to the lucene server",
          "type" : "string"
        },
        "operation" : {
          "description" : "Operation to do such as insert or query.",
          "enum" : [ "insert", "query" ],
          "type" : "string"
        },
        "analyzer" : {
          "description" : "An Analyzer builds TokenStreams, which analyze text. It thus represents a policy for extracting index terms from text. The value for analyzer can be any class that extends the abstract class org.apache.lucene.analysis.Analyzer. Lucene also offers a rich set of analyzers out of the box",
          "type" : "string"
        },
        "index-dir" : {
          "description" : "A file system directory in which index files are created upon analysis of the document by the specified analyzer",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "max-hits" : {
          "description" : "An integer value that limits the result set of the search operation",
          "type" : "integer"
        },
        "src-dir" : {
          "description" : "An optional directory containing files to be used to be analyzed and added to the index at producer startup.",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "lumberjack" : {
      "type" : "object",
      "required" : [ "host" ],
      "properties" : {
        "host" : {
          "description" : "Network interface on which to listen for Lumberjack",
          "type" : "string"
        },
        "port" : {
          "description" : "Network port on which to listen for Lumberjack",
          "default" : "5044",
          "type" : "integer"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "ssl-context-parameters" : {
          "description" : "SSL configuration",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "master" : {
      "type" : "object",
      "required" : [ "delegateUri", "namespace" ],
      "properties" : {
        "delegate-uri" : {
          "description" : "The endpoint uri to use in master/slave mode",
          "type" : "string"
        },
        "namespace" : {
          "description" : "The name of the cluster namespace to use",
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "metrics" : {
      "type" : "object",
      "required" : [ "metricsName", "metricsType" ],
      "properties" : {
        "metrics-name" : {
          "description" : "Name of metrics",
          "type" : "string"
        },
        "metrics-type" : {
          "description" : "Type of metrics",
          "enum" : [ "gauge", "counter", "histogram", "meter", "timer" ],
          "type" : "string"
        },
        "action" : {
          "description" : "Action when using timer type",
          "enum" : [ "start", "stop" ],
          "type" : "string"
        },
        "decrement" : {
          "description" : "Decrement value when using counter type",
          "type" : "integer"
        },
        "increment" : {
          "description" : "Increment value when using counter type",
          "type" : "integer"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "mark" : {
          "description" : "Mark when using meter type",
          "type" : "integer"
        },
        "subject" : {
          "description" : "Subject value when using gauge type",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "value" : {
          "description" : "Value value when using histogram type",
          "type" : "integer"
        }
      }
    },
    "micrometer" : {
      "type" : "object",
      "required" : [ "metricsName", "metricsType" ],
      "properties" : {
        "metrics-name" : {
          "description" : "Name of metrics",
          "type" : "string"
        },
        "metrics-type" : {
          "description" : "Type of metrics",
          "enum" : [ "COUNTER", "GAUGE", "LONG_TASK_TIMER", "TIMER", "DISTRIBUTION_SUMMARY", "OTHER" ],
          "type" : "string"
        },
        "tags" : {
          "description" : "Tags of metrics",
          "type" : "string"
        },
        "action" : {
          "description" : "Action expression when using timer type",
          "type" : "string"
        },
        "decrement" : {
          "description" : "Decrement value expression when using counter type",
          "type" : "string"
        },
        "increment" : {
          "description" : "Increment value expression when using counter type",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "value" : {
          "description" : "Value expression when using histogram type",
          "type" : "string"
        }
      }
    },
    "microprofile-metrics" : {
      "type" : "object",
      "required" : [ "metricName", "metricType" ],
      "properties" : {
        "metric-name" : {
          "description" : "Metric name",
          "type" : "string"
        },
        "metric-type" : {
          "description" : "Metric type",
          "enum" : [ "concurrent gauge", "counter", "gauge", "meter", "histogram", "timer", "simple timer", "invalid" ],
          "type" : "string"
        },
        "action" : {
          "description" : "Action to use when using the timer type",
          "type" : "string"
        },
        "counter-increment" : {
          "description" : "Increment value when using the counter type",
          "type" : "integer"
        },
        "description" : {
          "description" : "Metric description",
          "type" : "string"
        },
        "display-name" : {
          "description" : "Metric display name",
          "type" : "string"
        },
        "gauge-decrement" : {
          "description" : "Decrement metric value when using concurrent gauge type",
          "type" : "boolean"
        },
        "gauge-increment" : {
          "description" : "Increment metric value when using the concurrent gauge type",
          "type" : "boolean"
        },
        "gauge-value" : {
          "description" : "Decrement metric value when using concurrent gauge type",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "mark" : {
          "description" : "Mark value to set when using the meter type",
          "type" : "integer"
        },
        "metric-unit" : {
          "description" : "Metric unit. See org.eclipse.microprofile.metrics.MetricUnits",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "tags" : {
          "description" : "Comma delimited list of tags associated with the metric in the format tagName=tagValue",
          "type" : "string"
        },
        "value" : {
          "description" : "Value to set when using the histogram type",
          "type" : "integer"
        }
      }
    },
    "milo-client" : {
      "type" : "object",
      "required" : [ "endpointUri" ],
      "properties" : {
        "endpoint-uri" : {
          "description" : "The OPC UA server endpoint",
          "type" : "string"
        },
        "allowed-security-policies" : {
          "description" : "A set of allowed security policy URIs. Default is to accept all and use the highest.",
          "type" : "string"
        },
        "application-name" : {
          "description" : "The application name",
          "default" : "Apache Camel adapter for Eclipse Milo",
          "type" : "string"
        },
        "application-uri" : {
          "description" : "The application URI",
          "default" : "http://camel.apache.org/EclipseMilo/Client",
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "channel-lifetime" : {
          "description" : "Channel lifetime in milliseconds",
          "type" : "integer"
        },
        "client-id" : {
          "description" : "A virtual client id to force the creation of a new connection instance",
          "type" : "string"
        },
        "default-await-writes" : {
          "description" : "Default await setting for writes",
          "default" : "false",
          "type" : "boolean"
        },
        "discovery-endpoint-suffix" : {
          "description" : "A suffix for endpoint URI when discovering",
          "type" : "string"
        },
        "discovery-endpoint-uri" : {
          "description" : "An alternative discovery URI",
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "key-alias" : {
          "description" : "The name of the key in the keystore file",
          "type" : "string"
        },
        "key-password" : {
          "description" : "The key password",
          "type" : "string"
        },
        "key-store-password" : {
          "description" : "The keystore password",
          "type" : "string"
        },
        "key-store-type" : {
          "description" : "The key store type",
          "type" : "string"
        },
        "key-store-url" : {
          "description" : "The URL where the key should be loaded from",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "max-pending-publish-requests" : {
          "description" : "The maximum number of pending publish requests",
          "type" : "integer"
        },
        "max-response-message-size" : {
          "description" : "The maximum number of bytes a response message may have",
          "type" : "integer"
        },
        "method" : {
          "description" : "The method definition (see Method ID)",
          "type" : "string"
        },
        "node" : {
          "description" : "The node definition (see Node ID)",
          "type" : "string"
        },
        "override-host" : {
          "description" : "Override the server reported endpoint host with the host from the endpoint URI.",
          "default" : "false",
          "type" : "boolean"
        },
        "product-uri" : {
          "description" : "The product URI",
          "default" : "http://camel.apache.org/EclipseMilo",
          "type" : "string"
        },
        "request-timeout" : {
          "description" : "Request timeout in milliseconds",
          "type" : "integer"
        },
        "requested-publishing-interval" : {
          "description" : "The requested publishing interval in milliseconds",
          "default" : "1_000.0",
          "type" : "number"
        },
        "sampling-interval" : {
          "description" : "The sampling interval in milliseconds",
          "default" : "0.0",
          "type" : "number"
        },
        "session-name" : {
          "description" : "Session name",
          "type" : "string"
        },
        "session-timeout" : {
          "description" : "Session timeout in milliseconds",
          "type" : "integer"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "milo-server" : {
      "type" : "object",
      "required" : [ "itemId" ],
      "properties" : {
        "item-id" : {
          "description" : "ID of the item",
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "mina" : {
      "type" : "object",
      "required" : [ "host", "port", "protocol" ],
      "properties" : {
        "host" : {
          "description" : "Hostname to use. Use localhost or 0.0.0.0 for local server as consumer. For producer use the hostname or ip address of the remote server.",
          "type" : "string"
        },
        "port" : {
          "description" : "Port number",
          "type" : "integer"
        },
        "protocol" : {
          "description" : "Protocol to use",
          "type" : "string"
        },
        "allow-default-codec" : {
          "description" : "The mina component installs a default codec if both, codec is null and textline is false. Setting allowDefaultCodec to false prevents the mina component from installing a default codec as the first element in the filter chain. This is useful in scenarios where another filter must be the first in the filter chain, like the SSL filter.",
          "default" : "true",
          "type" : "boolean"
        },
        "auto-start-tls" : {
          "description" : "Whether to auto start SSL handshake.",
          "default" : "true",
          "type" : "boolean"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "cached-address" : {
          "description" : "Whether to create the InetAddress once and reuse. Setting this to false allows to pickup DNS changes in the network.",
          "default" : "true",
          "type" : "boolean"
        },
        "client-mode" : {
          "description" : "If the clientMode is true, mina consumer will connect the address as a TCP client.",
          "default" : "false",
          "type" : "boolean"
        },
        "codec" : {
          "description" : "To use a custom minda codec implementation.",
          "type" : "string"
        },
        "decoder-max-line-length" : {
          "description" : "To set the textline protocol decoder max line length. By default the default value of Mina itself is used which are 1024.",
          "default" : "1024",
          "type" : "integer"
        },
        "disconnect" : {
          "description" : "Whether or not to disconnect(close) from Mina session right after use. Can be used for both consumer and producer.",
          "default" : "false",
          "type" : "boolean"
        },
        "disconnect-on-no-reply" : {
          "description" : "If sync is enabled then this option dictates MinaConsumer if it should disconnect where there is no reply to send back.",
          "default" : "true",
          "type" : "boolean"
        },
        "encoder-max-line-length" : {
          "description" : "To set the textline protocol encoder max line length. By default the default value of Mina itself is used which are Integer.MAX_VALUE.",
          "default" : "-1",
          "type" : "integer"
        },
        "encoding" : {
          "description" : "You can configure the encoding (a charset name) to use for the TCP textline codec and the UDP protocol. If not provided, Camel will use the JVM default Charset",
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "filters" : {
          "description" : "You can set a list of Mina IoFilters to use.",
          "type" : "string"
        },
        "lazy-session-creation" : {
          "description" : "Sessions can be lazily created to avoid exceptions, if the remote server is not up and running when the Camel producer is started.",
          "default" : "true",
          "type" : "boolean"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "maximum-pool-size" : {
          "description" : "Number of worker threads in the worker pool for TCP and UDP",
          "default" : "16",
          "type" : "integer"
        },
        "mina-logger" : {
          "description" : "You can enable the Apache MINA logging filter. Apache MINA uses slf4j logging at INFO level to log all input and output.",
          "default" : "false",
          "type" : "boolean"
        },
        "no-reply-log-level" : {
          "description" : "If sync is enabled this option dictates MinaConsumer which logging level to use when logging a there is no reply to send back.",
          "default" : "WARN",
          "enum" : [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ],
          "type" : "string"
        },
        "ordered-thread-pool-executor" : {
          "description" : "Whether to use ordered thread pool, to ensure events are processed orderly on the same channel.",
          "default" : "true",
          "type" : "boolean"
        },
        "ssl-context-parameters" : {
          "description" : "To configure SSL security.",
          "type" : "string"
        },
        "sync" : {
          "description" : "Setting to set endpoint as one-way or request-response.",
          "default" : "true",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "textline" : {
          "description" : "Only used for TCP. If no codec is specified, you can use this flag to indicate a text line based codec; if not specified or the value is false, then Object Serialization is assumed over TCP.",
          "default" : "false",
          "type" : "boolean"
        },
        "textline-delimiter" : {
          "description" : "Only used for TCP and if textline=true. Sets the text line delimiter to use. If none provided, Camel will use DEFAULT. This delimiter is used to mark the end of text.",
          "enum" : [ "DEFAULT", "AUTO", "UNIX", "WINDOWS", "MAC" ],
          "type" : "string"
        },
        "timeout" : {
          "description" : "You can configure the timeout that specifies how long to wait for a response from a remote server. The timeout unit is in milliseconds, so 60000 is 60 seconds.",
          "default" : "30000",
          "type" : "integer"
        },
        "transfer-exchange" : {
          "description" : "Only used for TCP. You can transfer the exchange over the wire instead of just the body. The following fields are transferred: In body, Out body, fault body, In headers, Out headers, fault headers, exchange properties, exchange exception. This requires that the objects are serializable. Camel will exclude any non-serializable objects and log it at WARN level.",
          "default" : "false",
          "type" : "boolean"
        },
        "write-timeout" : {
          "description" : "Maximum amount of time it should take to send data to the MINA session. Default is 10000 milliseconds.",
          "default" : "10000",
          "type" : "integer"
        }
      }
    },
    "minio" : {
      "type" : "object",
      "required" : [ "bucketName" ],
      "properties" : {
        "bucket-name" : {
          "description" : "Bucket name",
          "type" : "string"
        },
        "access-key" : {
          "description" : "Amazon AWS Secret Access Key or Minio Access Key. If not set camel will connect to service for anonymous access.",
          "type" : "string"
        },
        "auto-close-body" : {
          "description" : "If this option is true and includeBody is true, then the MinioObject.close() method will be called on exchange completion. This option is strongly related to includeBody option. In case of setting includeBody to true and autocloseBody to false, it will be up to the caller to close the MinioObject stream. Setting autocloseBody to true, will close the MinioObject stream automatically.",
          "default" : "true",
          "type" : "boolean"
        },
        "auto-create-bucket" : {
          "description" : "Setting the autocreation of the bucket if bucket name not exist.",
          "default" : "true",
          "type" : "boolean"
        },
        "backoff-error-threshold" : {
          "description" : "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-idle-threshold" : {
          "description" : "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-multiplier" : {
          "description" : "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
          "type" : "integer"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "bypass-governance-mode" : {
          "description" : "Set this flag if you want to bypassGovernanceMode when deleting a particular object.",
          "default" : "false",
          "type" : "boolean"
        },
        "custom-http-client" : {
          "description" : "Set custom HTTP client for authenticated access.",
          "type" : "string"
        },
        "delay" : {
          "description" : "Milliseconds before the next poll.",
          "default" : "500",
          "type" : "integer"
        },
        "delete-after-read" : {
          "description" : "Delete objects from Minio after they have been retrieved. The delete is only performed if the Exchange is committed. If a rollback occurs, the object is not deleted. If this option is false, then the same objects will be retrieve over and over again on the polls. Therefore you need to use the Idempotent Consumer EIP in the route to filter out duplicates. You can filter using the MinioConstants#BUCKET_NAME and MinioConstants#OBJECT_NAME headers, or only the MinioConstants#OBJECT_NAME header.",
          "default" : "true",
          "type" : "boolean"
        },
        "delete-after-write" : {
          "description" : "Delete file object after the Minio file has been uploaded.",
          "default" : "false",
          "type" : "boolean"
        },
        "delimiter" : {
          "description" : "The delimiter which is used in the ListObjectsRequest to only consume objects we are interested in.",
          "type" : "string"
        },
        "destination-bucket-name" : {
          "description" : "Source bucket name.",
          "type" : "string"
        },
        "destination-object-name" : {
          "description" : "Source object name.",
          "type" : "string"
        },
        "endpoint" : {
          "description" : "Endpoint can be an URL, domain name, IPv4 address or IPv6 address.",
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "greedy" : {
          "description" : "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
          "default" : "false",
          "type" : "boolean"
        },
        "include-body" : {
          "description" : "If it is true, the exchange body will be set to a stream to the contents of the file. If false, the headers will be set with the Minio object metadata, but the body will be null. This option is strongly related to autocloseBody option. In case of setting includeBody to true and autocloseBody to false, it will be up to the caller to close the MinioObject stream. Setting autocloseBody to true, will close the MinioObject stream automatically.",
          "default" : "true",
          "type" : "boolean"
        },
        "include-folders" : {
          "description" : "The flag which is used in the ListObjectsRequest to set include folders.",
          "default" : "false",
          "type" : "boolean"
        },
        "include-user-metadata" : {
          "description" : "The flag which is used in the ListObjectsRequest to get objects with user meta data.",
          "default" : "false",
          "type" : "boolean"
        },
        "include-versions" : {
          "description" : "The flag which is used in the ListObjectsRequest to get objects with versioning.",
          "default" : "false",
          "type" : "boolean"
        },
        "initial-delay" : {
          "description" : "Milliseconds before the first poll starts.",
          "default" : "1000",
          "type" : "integer"
        },
        "key-name" : {
          "description" : "Setting the key name for an element in the bucket through endpoint parameter.",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "length" : {
          "description" : "Number of bytes of object data from offset.",
          "type" : "integer"
        },
        "match-e-tag" : {
          "description" : "Set match ETag parameter for get object(s).",
          "type" : "string"
        },
        "max-connections" : {
          "description" : "Set the maxConnections parameter in the minio client configuration",
          "default" : "60",
          "type" : "integer"
        },
        "max-messages-per-poll" : {
          "description" : "Gets the maximum number of messages as a limit to poll at each polling. Gets the maximum number of messages as a limit to poll at each polling. The default value is 10. Use 0 or a negative number to set it as unlimited.",
          "default" : "10",
          "type" : "integer"
        },
        "minio-client" : {
          "description" : "Reference to a Minio Client object in the registry.",
          "type" : "string"
        },
        "modified-since" : {
          "description" : "Set modified since parameter for get object(s).",
          "type" : "string"
        },
        "move-after-read" : {
          "description" : "Move objects from bucket to a different bucket after they have been retrieved. To accomplish the operation the destinationBucket option must be set. The copy bucket operation is only performed if the Exchange is committed. If a rollback occurs, the object is not moved.",
          "default" : "false",
          "type" : "boolean"
        },
        "not-match-e-tag" : {
          "description" : "Set not match ETag parameter for get object(s).",
          "type" : "string"
        },
        "object-lock" : {
          "description" : "Set when creating new bucket.",
          "default" : "false",
          "type" : "boolean"
        },
        "object-name" : {
          "description" : "To get the object from the bucket with the given object name.",
          "type" : "string"
        },
        "offset" : {
          "description" : "Start byte position of object data.",
          "type" : "integer"
        },
        "operation" : {
          "description" : "The operation to do in case the user don't want to do only an upload.",
          "enum" : [ "copyObject", "listObjects", "deleteObject", "deleteObjects", "deleteBucket", "listBuckets", "getObject", "getObjectRange" ],
          "type" : "string"
        },
        "pojo-request" : {
          "description" : "If we want to use a POJO request as body or not.",
          "default" : "false",
          "type" : "boolean"
        },
        "policy" : {
          "description" : "The policy for this queue to set in the method.",
          "type" : "string"
        },
        "poll-strategy" : {
          "description" : "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
          "type" : "string"
        },
        "prefix" : {
          "description" : "Object name starts with prefix.",
          "type" : "string"
        },
        "proxy-port" : {
          "description" : "TCP/IP port number. 80 and 443 are used as defaults for HTTP and HTTPS.",
          "type" : "integer"
        },
        "recursive" : {
          "description" : "List recursively than directory structure emulation.",
          "default" : "false",
          "type" : "boolean"
        },
        "region" : {
          "description" : "The region in which Minio client needs to work. When using this parameter, the configuration will expect the lowercase name of the region (for example ap-east-1). You'll need to use the name Region.EU_WEST_1.id()",
          "type" : "string"
        },
        "repeat-count" : {
          "description" : "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
          "default" : "0",
          "type" : "integer"
        },
        "run-logging-level" : {
          "description" : "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
          "default" : "TRACE",
          "enum" : [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ],
          "type" : "string"
        },
        "scheduled-executor-service" : {
          "description" : "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
          "type" : "string"
        },
        "scheduler" : {
          "description" : "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
          "default" : "none",
          "type" : "string"
        },
        "scheduler-properties" : {
          "description" : "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
          "type" : "string"
        },
        "secret-key" : {
          "description" : "Amazon AWS Access Key Id or Minio Secret Key. If not set camel will connect to service for anonymous access.",
          "type" : "string"
        },
        "secure" : {
          "description" : "Flag to indicate to use secure connection to minio service or not.",
          "default" : "false",
          "type" : "boolean"
        },
        "send-empty-message-when-idle" : {
          "description" : "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
          "default" : "false",
          "type" : "boolean"
        },
        "server-side-encryption" : {
          "description" : "Server-side encryption.",
          "type" : "string"
        },
        "server-side-encryption-customer-key" : {
          "description" : "Server-side encryption for source object while copy/move objects.",
          "type" : "string"
        },
        "start-after" : {
          "description" : "list objects in bucket after this object name.",
          "type" : "string"
        },
        "start-scheduler" : {
          "description" : "Whether the scheduler should be auto started.",
          "default" : "true",
          "type" : "boolean"
        },
        "storage-class" : {
          "description" : "The storage class to set in the request.",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "time-unit" : {
          "description" : "Time unit for initialDelay and delay options.",
          "default" : "MILLISECONDS",
          "enum" : [ "NANOSECONDS", "MICROSECONDS", "MILLISECONDS", "SECONDS", "MINUTES", "HOURS", "DAYS" ],
          "type" : "string"
        },
        "un-modified-since" : {
          "description" : "Set un modified since parameter for get object(s).",
          "type" : "string"
        },
        "use-fixed-delay" : {
          "description" : "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
          "default" : "true",
          "type" : "boolean"
        },
        "use-version1" : {
          "description" : "when true, version 1 of REST API is used.",
          "default" : "false",
          "type" : "boolean"
        },
        "version-id" : {
          "description" : "Set specific version_ID of a object when deleting the object.",
          "type" : "string"
        }
      }
    },
    "mllp" : {
      "type" : "object",
      "required" : [ "hostname", "port" ],
      "properties" : {
        "hostname" : {
          "description" : "Hostname or IP for connection for the TCP connection. The default value is null, which means any local IP address",
          "type" : "string"
        },
        "port" : {
          "description" : "Port number for the TCP connection",
          "type" : "integer"
        },
        "accept-timeout" : {
          "description" : "Timeout (in milliseconds) while waiting for a TCP connection TCP Server Only",
          "default" : "60000",
          "type" : "integer"
        },
        "auto-ack" : {
          "description" : "Enable/Disable the automatic generation of a MLLP Acknowledgement MLLP Consumers only",
          "default" : "true",
          "type" : "boolean"
        },
        "backlog" : {
          "description" : "The maximum queue length for incoming connection indications (a request to connect) is set to the backlog parameter. If a connection indication arrives when the queue is full, the connection is refused.",
          "default" : "5",
          "type" : "integer"
        },
        "bind-retry-interval" : {
          "description" : "TCP Server Only - The number of milliseconds to wait between bind attempts",
          "default" : "5000",
          "type" : "integer"
        },
        "bind-timeout" : {
          "description" : "TCP Server Only - The number of milliseconds to retry binding to a server port",
          "default" : "30000",
          "type" : "integer"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to receive incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. If disabled, the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions by logging them at WARN or ERROR level and ignored.",
          "default" : "true",
          "type" : "boolean"
        },
        "buffer-writes" : {
          "description" : "Enable/Disable the buffering of HL7 payloads before writing to the socket.",
          "default" : "false",
          "type" : "boolean"
        },
        "charset-name" : {
          "description" : "Set the CamelCharsetName property on the exchange",
          "type" : "string"
        },
        "connect-timeout" : {
          "description" : "Timeout (in milliseconds) for establishing for a TCP connection TCP Client only",
          "default" : "30000",
          "type" : "integer"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "default" : "InOut",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "hl7-headers" : {
          "description" : "Enable/Disable the automatic generation of message headers from the HL7 Message MLLP Consumers only",
          "default" : "true",
          "type" : "boolean"
        },
        "idle-timeout" : {
          "description" : "The approximate idle time allowed before the Client TCP Connection will be reset. A null value or a value less than or equal to zero will disable the idle timeout.",
          "type" : "integer"
        },
        "keep-alive" : {
          "description" : "Enable/disable the SO_KEEPALIVE socket option.",
          "default" : "true",
          "type" : "boolean"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "lenient-bind" : {
          "description" : "TCP Server Only - Allow the endpoint to start before the TCP ServerSocket is bound. In some environments, it may be desirable to allow the endpoint to start before the TCP ServerSocket is bound.",
          "default" : "false",
          "type" : "boolean"
        },
        "max-concurrent-consumers" : {
          "description" : "The maximum number of concurrent MLLP Consumer connections that will be allowed. If a new connection is received and the maximum is number are already established, the new connection will be reset immediately.",
          "default" : "5",
          "type" : "integer"
        },
        "max-receive-timeouts" : {
          "description" : "The maximum number of timeouts (specified by receiveTimeout) allowed before the TCP Connection will be reset.",
          "type" : "integer"
        },
        "read-timeout" : {
          "description" : "The SO_TIMEOUT value (in milliseconds) used after the start of an MLLP frame has been received",
          "default" : "5000",
          "type" : "integer"
        },
        "receive-buffer-size" : {
          "description" : "Sets the SO_RCVBUF option to the specified value (in bytes)",
          "default" : "8192",
          "type" : "integer"
        },
        "receive-timeout" : {
          "description" : "The SO_TIMEOUT value (in milliseconds) used when waiting for the start of an MLLP frame",
          "default" : "15000",
          "type" : "integer"
        },
        "require-end-of-data" : {
          "description" : "Enable/Disable strict compliance to the MLLP standard. The MLLP standard specifies START_OF_BLOCKhl7 payloadEND_OF_BLOCKEND_OF_DATA, however, some systems do not send the final END_OF_DATA byte. This setting controls whether or not the final END_OF_DATA byte is required or optional.",
          "default" : "true",
          "type" : "boolean"
        },
        "reuse-address" : {
          "description" : "Enable/disable the SO_REUSEADDR socket option.",
          "default" : "false",
          "type" : "boolean"
        },
        "send-buffer-size" : {
          "description" : "Sets the SO_SNDBUF option to the specified value (in bytes)",
          "default" : "8192",
          "type" : "integer"
        },
        "string-payload" : {
          "description" : "Enable/Disable converting the payload to a String. If enabled, HL7 Payloads received from external systems will be validated converted to a String. If the charsetName property is set, that character set will be used for the conversion. If the charsetName property is not set, the value of MSH-18 will be used to determine th appropriate character set. If MSH-18 is not set, then the default ISO-8859-1 character set will be use.",
          "default" : "true",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used (this component only supports synchronous operations).",
          "default" : "true",
          "type" : "boolean"
        },
        "tcp-no-delay" : {
          "description" : "Enable/disable the TCP_NODELAY socket option.",
          "default" : "true",
          "type" : "boolean"
        },
        "validate-payload" : {
          "description" : "Enable/Disable the validation of HL7 Payloads If enabled, HL7 Payloads received from external systems will be validated (see Hl7Util.generateInvalidPayloadExceptionMessage for details on the validation). If and invalid payload is detected, a MllpInvalidMessageException (for consumers) or a MllpInvalidAcknowledgementException will be thrown.",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "mock" : {
      "type" : "object",
      "required" : [ "name" ],
      "properties" : {
        "name" : {
          "description" : "Name of mock endpoint",
          "type" : "string"
        },
        "assert-period" : {
          "description" : "Sets a grace period after which the mock endpoint will re-assert to ensure the preliminary assertion is still valid. This is used for example to assert that exactly a number of messages arrives. For example if expectedMessageCount(int) was set to 5, then the assertion is satisfied when 5 or more message arrives. To ensure that exactly 5 messages arrives, then you would need to wait a little period to ensure no further message arrives. This is what you can use this method for. By default this period is disabled.",
          "default" : "0",
          "type" : "string"
        },
        "copy-on-exchange" : {
          "description" : "Sets whether to make a deep copy of the incoming Exchange when received at this mock endpoint. Is by default true.",
          "default" : "true",
          "type" : "boolean"
        },
        "expected-count" : {
          "description" : "Specifies the expected number of message exchanges that should be received by this endpoint. Beware: If you want to expect that 0 messages, then take extra care, as 0 matches when the tests starts, so you need to set a assert period time to let the test run for a while to make sure there are still no messages arrived; for that use setAssertPeriod(long). An alternative is to use NotifyBuilder, and use the notifier to know when Camel is done routing some messages, before you call the assertIsSatisfied() method on the mocks. This allows you to not use a fixed assert period, to speedup testing times. If you want to assert that exactly n'th message arrives to this mock endpoint, then see also the setAssertPeriod(long) method for further details.",
          "default" : "-1",
          "type" : "integer"
        },
        "fail-fast" : {
          "description" : "Sets whether assertIsSatisfied() should fail fast at the first detected failed expectation while it may otherwise wait for all expected messages to arrive before performing expectations verifications. Is by default true. Set to false to use behavior as in Camel 2.x.",
          "default" : "false",
          "type" : "boolean"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "report-group" : {
          "description" : "A number that is used to turn on throughput logging based on groups of the size.",
          "type" : "integer"
        },
        "result-minimum-wait-time" : {
          "description" : "Sets the minimum expected amount of time (in millis) the assertIsSatisfied() will wait on a latch until it is satisfied",
          "default" : "0",
          "type" : "string"
        },
        "result-wait-time" : {
          "description" : "Sets the maximum amount of time (in millis) the assertIsSatisfied() will wait on a latch until it is satisfied",
          "default" : "0",
          "type" : "string"
        },
        "retain-first" : {
          "description" : "Specifies to only retain the first n'th number of received Exchanges. This is used when testing with big data, to reduce memory consumption by not storing copies of every Exchange this mock endpoint receives. Important: When using this limitation, then the getReceivedCounter() will still return the actual number of received Exchanges. For example if we have received 5000 Exchanges, and have configured to only retain the first 10 Exchanges, then the getReceivedCounter() will still return 5000 but there is only the first 10 Exchanges in the getExchanges() and getReceivedExchanges() methods. When using this method, then some of the other expectation methods is not supported, for example the expectedBodiesReceived(Object...) sets a expectation on the first number of bodies received. You can configure both setRetainFirst(int) and setRetainLast(int) methods, to limit both the first and last received.",
          "default" : "-1",
          "type" : "integer"
        },
        "retain-last" : {
          "description" : "Specifies to only retain the last n'th number of received Exchanges. This is used when testing with big data, to reduce memory consumption by not storing copies of every Exchange this mock endpoint receives. Important: When using this limitation, then the getReceivedCounter() will still return the actual number of received Exchanges. For example if we have received 5000 Exchanges, and have configured to only retain the last 20 Exchanges, then the getReceivedCounter() will still return 5000 but there is only the last 20 Exchanges in the getExchanges() and getReceivedExchanges() methods. When using this method, then some of the other expectation methods is not supported, for example the expectedBodiesReceived(Object...) sets a expectation on the first number of bodies received. You can configure both setRetainFirst(int) and setRetainLast(int) methods, to limit both the first and last received.",
          "default" : "-1",
          "type" : "integer"
        },
        "sleep-for-empty-test" : {
          "description" : "Allows a sleep to be specified to wait to check that this endpoint really is empty when expectedMessageCount(int) is called with zero",
          "default" : "0",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "mongodb" : {
      "type" : "object",
      "required" : [ "connectionBean" ],
      "properties" : {
        "connection-bean" : {
          "description" : "Sets the connection bean reference used to lookup a client for connecting to a database.",
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "collection" : {
          "description" : "Sets the name of the MongoDB collection to bind to this endpoint",
          "type" : "string"
        },
        "collection-index" : {
          "description" : "Sets the collection index (JSON FORMAT : { field1 : order1, field2 : order2})",
          "type" : "string"
        },
        "consumer-type" : {
          "description" : "Consumer type.",
          "type" : "string"
        },
        "create-collection" : {
          "description" : "Create collection during initialisation if it doesn't exist. Default is true.",
          "default" : "true",
          "type" : "boolean"
        },
        "cursor-regeneration-delay" : {
          "description" : "MongoDB tailable cursors will block until new data arrives. If no new data is inserted, after some time the cursor will be automatically freed and closed by the MongoDB server. The client is expected to regenerate the cursor if needed. This value specifies the time to wait before attempting to fetch a new cursor, and if the attempt fails, how long before the next attempt is made. Default value is 1000ms.",
          "default" : "1000",
          "type" : "string"
        },
        "database" : {
          "description" : "Sets the name of the MongoDB database to target",
          "type" : "string"
        },
        "dynamicity" : {
          "description" : "Sets whether this endpoint will attempt to dynamically resolve the target database and collection from the incoming Exchange properties. Can be used to override at runtime the database and collection specified on the otherwise static endpoint URI. It is disabled by default to boost performance. Enabling it will take a minimal performance hit.",
          "default" : "false",
          "type" : "boolean"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "mongo-connection" : {
          "description" : "Sets the connection bean used as a client for connecting to a database.",
          "type" : "string"
        },
        "operation" : {
          "description" : "Sets the operation this endpoint will execute against MongoDB.",
          "enum" : [ "findById", "findOneByQuery", "findAll", "findDistinct", "insert", "save", "update", "remove", "bulkWrite", "aggregate", "getDbStats", "getColStats", "count", "command" ],
          "type" : "string"
        },
        "output-type" : {
          "description" : "Convert the output of the producer to the selected type : DocumentList Document or MongoIterable. DocumentList or MongoIterable applies to findAll and aggregate. Document applies to all other operations.",
          "enum" : [ "DocumentList", "Document", "MongoIterable" ],
          "type" : "string"
        },
        "persistent-id" : {
          "description" : "One tail tracking collection can host many trackers for several tailable consumers. To keep them separate, each tracker should have its own unique persistentId.",
          "type" : "string"
        },
        "persistent-tail-tracking" : {
          "description" : "Enable persistent tail tracking, which is a mechanism to keep track of the last consumed message across system restarts. The next time the system is up, the endpoint will recover the cursor from the point where it last stopped slurping records.",
          "default" : "false",
          "type" : "boolean"
        },
        "read-preference" : {
          "description" : "Configure how MongoDB clients route read operations to the members of a replica set. Possible values are PRIMARY, PRIMARY_PREFERRED, SECONDARY, SECONDARY_PREFERRED or NEAREST",
          "default" : "PRIMARY",
          "enum" : [ "PRIMARY", "PRIMARY_PREFERRED", "SECONDARY", "SECONDARY_PREFERRED", "NEAREST" ],
          "type" : "string"
        },
        "stream-filter" : {
          "description" : "Filter condition for change streams consumer.",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "tail-track-collection" : {
          "description" : "Collection where tail tracking information will be persisted. If not specified, MongoDbTailTrackingConfig#DEFAULT_COLLECTION will be used by default.",
          "type" : "string"
        },
        "tail-track-db" : {
          "description" : "Indicates what database the tail tracking mechanism will persist to. If not specified, the current database will be picked by default. Dynamicity will not be taken into account even if enabled, i.e. the tail tracking database will not vary past endpoint initialisation.",
          "type" : "string"
        },
        "tail-track-field" : {
          "description" : "Field where the last tracked value will be placed. If not specified, MongoDbTailTrackingConfig#DEFAULT_FIELD will be used by default.",
          "type" : "string"
        },
        "tail-track-increasing-field" : {
          "description" : "Correlation field in the incoming record which is of increasing nature and will be used to position the tailing cursor every time it is generated. The cursor will be (re)created with a query of type: tailTrackIncreasingField greater than lastValue (possibly recovered from persistent tail tracking). Can be of type Integer, Date, String, etc. NOTE: No support for dot notation at the current time, so the field should be at the top level of the document.",
          "type" : "string"
        },
        "write-concern" : {
          "description" : "Configure the connection bean with the level of acknowledgment requested from MongoDB for write operations to a standalone mongod, replicaset or cluster. Possible values are ACKNOWLEDGED, W1, W2, W3, UNACKNOWLEDGED, JOURNALED or MAJORITY.",
          "default" : "ACKNOWLEDGED",
          "enum" : [ "ACKNOWLEDGED", "W1", "W2", "W3", "UNACKNOWLEDGED", "JOURNALED", "MAJORITY" ],
          "type" : "string"
        },
        "write-result-as-header" : {
          "description" : "In write operations, it determines whether instead of returning WriteResult as the body of the OUT message, we transfer the IN message to the OUT and attach the WriteResult as a header.",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "mongodb-gridfs" : {
      "type" : "object",
      "required" : [ "connectionBean", "database" ],
      "properties" : {
        "connection-bean" : {
          "description" : "Name of com.mongodb.client.MongoClient to use.",
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "bucket" : {
          "description" : "Sets the name of the GridFS bucket within the database. Default is fs.",
          "default" : "fs",
          "type" : "string"
        },
        "database" : {
          "description" : "Sets the name of the MongoDB database to target",
          "type" : "string"
        },
        "delay" : {
          "description" : "Sets the delay between polls within the Consumer. Default is 500ms",
          "default" : "500",
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "file-attribute-name" : {
          "description" : "If the QueryType uses a FileAttribute, this sets the name of the attribute that is used. Default is camel-processed.",
          "default" : "camel-processed",
          "type" : "string"
        },
        "initial-delay" : {
          "description" : "Sets the initialDelay before the consumer will start polling. Default is 1000ms",
          "default" : "1000",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "operation" : {
          "description" : "Sets the operation this endpoint will execute against GridFs.",
          "type" : "string"
        },
        "persistent-ts-collection" : {
          "description" : "If the QueryType uses a persistent timestamp, this sets the name of the collection within the DB to store the timestamp.",
          "default" : "camel-timestamps",
          "type" : "string"
        },
        "persistent-ts-object" : {
          "description" : "If the QueryType uses a persistent timestamp, this is the ID of the object in the collection to store the timestamp.",
          "default" : "camel-timestamp",
          "type" : "string"
        },
        "query" : {
          "description" : "Additional query parameters (in JSON) that are used to configure the query used for finding files in the GridFsConsumer",
          "type" : "string"
        },
        "query-strategy" : {
          "description" : "Sets the QueryStrategy that is used for polling for new files. Default is Timestamp",
          "default" : "TimeStamp",
          "enum" : [ "TimeStamp", "PersistentTimestamp", "FileAttribute", "TimeStampAndFileAttribute", "PersistentTimestampAndFileAttribute" ],
          "type" : "string"
        },
        "read-preference" : {
          "description" : "Sets a MongoDB ReadPreference on the Mongo connection. Read preferences set directly on the connection will be overridden by this setting. The com.mongodb.ReadPreference#valueOf(String) utility method is used to resolve the passed readPreference value. Some examples for the possible values are nearest, primary or secondary etc.",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "write-concern" : {
          "description" : "Set the WriteConcern for write operations on MongoDB using the standard ones. Resolved from the fields of the WriteConcern class by calling the WriteConcern#valueOf(String) method.",
          "enum" : [ "ACKNOWLEDGED", "W1", "W2", "W3", "UNACKNOWLEDGED", "JOURNALED", "MAJORITY" ],
          "type" : "string"
        }
      }
    },
    "msv" : {
      "type" : "object",
      "required" : [ "resourceUri" ],
      "properties" : {
        "resource-uri" : {
          "description" : "URL to a local resource on the classpath, or a reference to lookup a bean in the Registry, or a full URL to a remote resource or resource on the file system which contains the XSD to validate against.",
          "type" : "string"
        },
        "error-handler" : {
          "description" : "To use a custom org.apache.camel.processor.validation.ValidatorErrorHandler. The default error handler captures the errors and throws an exception.",
          "type" : "string"
        },
        "fail-on-null-body" : {
          "description" : "Whether to fail if no body exists.",
          "default" : "true",
          "type" : "boolean"
        },
        "fail-on-null-header" : {
          "description" : "Whether to fail if no header exists when validating against a header.",
          "default" : "true",
          "type" : "boolean"
        },
        "header-name" : {
          "description" : "To validate against a header instead of the message body.",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "resource-resolver" : {
          "description" : "To use a custom LSResourceResolver. Do not use together with resourceResolverFactory",
          "type" : "string"
        },
        "resource-resolver-factory" : {
          "description" : "To use a custom LSResourceResolver which depends on a dynamic endpoint resource URI. The default resource resolver factory resturns a resource resolver which can read files from the class path and file system. Do not use together with resourceResolver.",
          "type" : "string"
        },
        "schema-factory" : {
          "description" : "To use a custom javax.xml.validation.SchemaFactory",
          "type" : "string"
        },
        "schema-language" : {
          "description" : "Configures the W3C XML Schema Namespace URI.",
          "default" : "http://www.w3.org/2001/XMLSchema",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "use-shared-schema" : {
          "description" : "Whether the Schema instance should be shared or not. This option is introduced to work around a JDK 1.6.x bug. Xerces should not have this issue.",
          "default" : "true",
          "type" : "boolean"
        }
      }
    },
    "mustache" : {
      "type" : "object",
      "required" : [ "resourceUri" ],
      "properties" : {
        "resource-uri" : {
          "description" : "Path to the resource. You can prefix with: classpath, file, http, ref, or bean. classpath, file and http loads the resource using these protocols (classpath is default). ref will lookup the resource in the registry. bean will call a method on a bean to be used as the resource. For bean you can specify the method name after dot, eg bean:myBean.myMethod.",
          "type" : "string"
        },
        "allow-context-map-all" : {
          "description" : "Sets whether the context map should allow access to all details. By default only the message body and headers can be accessed. This option can be enabled for full access to the current Exchange and CamelContext. Doing so impose a potential security risk as this opens access to the full power of CamelContext API.",
          "default" : "false",
          "type" : "boolean"
        },
        "allow-template-from-header" : {
          "description" : "Whether to allow to use resource template from header or not (default false). Enabling this allows to specify dynamic templates via message header. However this can be seen as a potential security vulnerability if the header is coming from a malicious user, so use this with care.",
          "default" : "false",
          "type" : "boolean"
        },
        "content-cache" : {
          "description" : "Sets whether to use resource content cache or not",
          "default" : "false",
          "type" : "boolean"
        },
        "encoding" : {
          "description" : "Character encoding of the resource content.",
          "type" : "string"
        },
        "end-delimiter" : {
          "description" : "Characters used to mark template code end.",
          "default" : "}}",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "start-delimiter" : {
          "description" : "Characters used to mark template code beginning.",
          "default" : "{{",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "mvel" : {
      "type" : "object",
      "required" : [ "resourceUri" ],
      "properties" : {
        "resource-uri" : {
          "description" : "Path to the resource. You can prefix with: classpath, file, http, ref, or bean. classpath, file and http loads the resource using these protocols (classpath is default). ref will lookup the resource in the registry. bean will call a method on a bean to be used as the resource. For bean you can specify the method name after dot, eg bean:myBean.myMethod.",
          "type" : "string"
        },
        "allow-context-map-all" : {
          "description" : "Sets whether the context map should allow access to all details. By default only the message body and headers can be accessed. This option can be enabled for full access to the current Exchange and CamelContext. Doing so impose a potential security risk as this opens access to the full power of CamelContext API.",
          "default" : "false",
          "type" : "boolean"
        },
        "allow-template-from-header" : {
          "description" : "Whether to allow to use resource template from header or not (default false). Enabling this allows to specify dynamic templates via message header. However this can be seen as a potential security vulnerability if the header is coming from a malicious user, so use this with care.",
          "default" : "false",
          "type" : "boolean"
        },
        "content-cache" : {
          "description" : "Sets whether to use resource content cache or not",
          "default" : "false",
          "type" : "boolean"
        },
        "encoding" : {
          "description" : "Character encoding of the resource content.",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "mybatis" : {
      "type" : "object",
      "required" : [ "statement" ],
      "properties" : {
        "statement" : {
          "description" : "The statement name in the MyBatis XML mapping file which maps to the query, insert, update or delete operation you wish to evaluate.",
          "type" : "string"
        },
        "backoff-error-threshold" : {
          "description" : "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-idle-threshold" : {
          "description" : "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-multiplier" : {
          "description" : "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
          "type" : "integer"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "delay" : {
          "description" : "Milliseconds before the next poll.",
          "default" : "500",
          "type" : "integer"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "executor-type" : {
          "description" : "The executor type to be used while executing statements. simple - executor does nothing special. reuse - executor reuses prepared statements. batch - executor reuses statements and batches updates.",
          "default" : "SIMPLE",
          "enum" : [ "SIMPLE", "REUSE", "BATCH" ],
          "type" : "string"
        },
        "greedy" : {
          "description" : "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
          "default" : "false",
          "type" : "boolean"
        },
        "initial-delay" : {
          "description" : "Milliseconds before the first poll starts.",
          "default" : "1000",
          "type" : "integer"
        },
        "input-header" : {
          "description" : "User the header value for input parameters instead of the message body. By default, inputHeader == null and the input parameters are taken from the message body. If outputHeader is set, the value is used and query parameters will be taken from the header instead of the body.",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "max-messages-per-poll" : {
          "description" : "This option is intended to split results returned by the database pool into the batches and deliver them in multiple exchanges. This integer defines the maximum messages to deliver in single exchange. By default, no maximum is set. Can be used to set a limit of e.g. 1000 to avoid when starting up the server that there are thousands of files. Set a value of 0 or negative to disable it.",
          "default" : "0",
          "type" : "integer"
        },
        "on-consume" : {
          "description" : "Statement to run after data has been processed in the route",
          "type" : "string"
        },
        "output-header" : {
          "description" : "Store the query result in a header instead of the message body. By default, outputHeader == null and the query result is stored in the message body, any existing content in the message body is discarded. If outputHeader is set, the value is used as the name of the header to store the query result and the original message body is preserved. Setting outputHeader will also omit populating the default CamelMyBatisResult header since it would be the same as outputHeader all the time.",
          "type" : "string"
        },
        "poll-strategy" : {
          "description" : "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
          "type" : "string"
        },
        "processing-strategy" : {
          "description" : "To use a custom MyBatisProcessingStrategy",
          "type" : "string"
        },
        "repeat-count" : {
          "description" : "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
          "default" : "0",
          "type" : "integer"
        },
        "route-empty-result-set" : {
          "description" : "Whether allow empty resultset to be routed to the next hop",
          "default" : "false",
          "type" : "boolean"
        },
        "run-logging-level" : {
          "description" : "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
          "default" : "TRACE",
          "enum" : [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ],
          "type" : "string"
        },
        "scheduled-executor-service" : {
          "description" : "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
          "type" : "string"
        },
        "scheduler" : {
          "description" : "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
          "default" : "none",
          "type" : "string"
        },
        "scheduler-properties" : {
          "description" : "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
          "type" : "string"
        },
        "send-empty-message-when-idle" : {
          "description" : "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
          "default" : "false",
          "type" : "boolean"
        },
        "start-scheduler" : {
          "description" : "Whether the scheduler should be auto started.",
          "default" : "true",
          "type" : "boolean"
        },
        "statement-type" : {
          "description" : "Mandatory to specify for the producer to control which kind of operation to invoke.",
          "enum" : [ "SelectOne", "SelectList", "Insert", "InsertList", "Update", "UpdateList", "Delete", "DeleteList" ],
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "time-unit" : {
          "description" : "Time unit for initialDelay and delay options.",
          "default" : "MILLISECONDS",
          "enum" : [ "NANOSECONDS", "MICROSECONDS", "MILLISECONDS", "SECONDS", "MINUTES", "HOURS", "DAYS" ],
          "type" : "string"
        },
        "transacted" : {
          "description" : "Enables or disables transaction. If enabled then if processing an exchange failed then the consumer breaks out processing any further exchanges to cause a rollback eager.",
          "default" : "false",
          "type" : "boolean"
        },
        "use-fixed-delay" : {
          "description" : "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
          "default" : "true",
          "type" : "boolean"
        },
        "use-iterator" : {
          "description" : "Process resultset individually or as a list",
          "default" : "true",
          "type" : "boolean"
        }
      }
    },
    "mybatis-bean" : {
      "type" : "object",
      "required" : [ "beanName", "methodName" ],
      "properties" : {
        "bean-name" : {
          "description" : "Name of the bean with the MyBatis annotations. This can either by a type alias or a FQN class name.",
          "type" : "string"
        },
        "method-name" : {
          "description" : "Name of the method on the bean that has the SQL query to be executed.",
          "type" : "string"
        },
        "executor-type" : {
          "description" : "The executor type to be used while executing statements. simple - executor does nothing special. reuse - executor reuses prepared statements. batch - executor reuses statements and batches updates.",
          "default" : "SIMPLE",
          "enum" : [ "SIMPLE", "REUSE", "BATCH" ],
          "type" : "string"
        },
        "input-header" : {
          "description" : "User the header value for input parameters instead of the message body. By default, inputHeader == null and the input parameters are taken from the message body. If outputHeader is set, the value is used and query parameters will be taken from the header instead of the body.",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "output-header" : {
          "description" : "Store the query result in a header instead of the message body. By default, outputHeader == null and the query result is stored in the message body, any existing content in the message body is discarded. If outputHeader is set, the value is used as the name of the header to store the query result and the original message body is preserved. Setting outputHeader will also omit populating the default CamelMyBatisResult header since it would be the same as outputHeader all the time.",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "nagios" : {
      "type" : "object",
      "required" : [ "host", "port" ],
      "properties" : {
        "host" : {
          "description" : "This is the address of the Nagios host where checks should be send.",
          "type" : "string"
        },
        "port" : {
          "description" : "The port number of the host.",
          "type" : "integer"
        },
        "connection-timeout" : {
          "description" : "Connection timeout in millis.",
          "default" : "5000",
          "type" : "integer"
        },
        "encryption" : {
          "description" : "To specify an encryption method.",
          "enum" : [ "NONE", "TRIPLE_DES", "XOR", "RIJNDAEL128", "RIJNDAEL192", "RIJNDAEL256", "BLOWFISH" ],
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "password" : {
          "description" : "Password to be authenticated when sending checks to Nagios.",
          "type" : "string"
        },
        "send-sync" : {
          "description" : "Whether or not to use synchronous when sending a passive check. Setting it to false will allow Camel to continue routing the message and the passive check message will be send asynchronously.",
          "default" : "true",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "timeout" : {
          "description" : "Sending timeout in millis.",
          "default" : "5000",
          "type" : "integer"
        }
      }
    },
    "nats" : {
      "type" : "object",
      "required" : [ "topic" ],
      "properties" : {
        "topic" : {
          "description" : "The name of topic we want to use",
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "connection" : {
          "description" : "Reference an already instantiated connection to Nats server",
          "type" : "string"
        },
        "connection-timeout" : {
          "description" : "Timeout for connection attempts. (in milliseconds)",
          "default" : "2000",
          "type" : "integer"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "flush-connection" : {
          "description" : "Define if we want to flush connection when stopping or not",
          "default" : "true",
          "type" : "boolean"
        },
        "flush-timeout" : {
          "description" : "Set the flush timeout (in milliseconds)",
          "default" : "1000",
          "type" : "integer"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "max-messages" : {
          "description" : "Stop receiving messages from a topic we are subscribing to after maxMessages",
          "type" : "string"
        },
        "max-pings-out" : {
          "description" : "maximum number of pings have not received a response allowed by the client",
          "default" : "2",
          "type" : "integer"
        },
        "max-reconnect-attempts" : {
          "description" : "Max reconnection attempts",
          "default" : "60",
          "type" : "integer"
        },
        "no-echo" : {
          "description" : "Turn off echo. If supported by the gnatsd version you are connecting to this flag will prevent the server from echoing messages back to the connection if it has subscriptions on the subject being published to.",
          "default" : "false",
          "type" : "boolean"
        },
        "no-randomize-servers" : {
          "description" : "Whether or not randomizing the order of servers for the connection attempts",
          "default" : "false",
          "type" : "boolean"
        },
        "pedantic" : {
          "description" : "Whether or not running in pedantic mode (this affects performance)",
          "default" : "false",
          "type" : "boolean"
        },
        "ping-interval" : {
          "description" : "Ping interval to be aware if connection is still alive (in milliseconds)",
          "default" : "120000",
          "type" : "integer"
        },
        "pool-size" : {
          "description" : "Consumer thread pool size (default is 10)",
          "default" : "10",
          "type" : "integer"
        },
        "queue-name" : {
          "description" : "The Queue name if we are using nats for a queue configuration",
          "type" : "string"
        },
        "reconnect" : {
          "description" : "Whether or not using reconnection feature",
          "default" : "true",
          "type" : "boolean"
        },
        "reconnect-time-wait" : {
          "description" : "Waiting time before attempts reconnection (in milliseconds)",
          "default" : "2000",
          "type" : "integer"
        },
        "reply-subject" : {
          "description" : "the subject to which subscribers should send response",
          "type" : "string"
        },
        "reply-to-disabled" : {
          "description" : "Can be used to turn off sending back reply message in the consumer.",
          "default" : "false",
          "type" : "boolean"
        },
        "request-cleanup-interval" : {
          "description" : "Interval to clean up cancelled/timed out requests.",
          "default" : "5000",
          "type" : "integer"
        },
        "secure" : {
          "description" : "Set secure option indicating TLS is required",
          "default" : "false",
          "type" : "boolean"
        },
        "servers" : {
          "description" : "URLs to one or more NAT servers. Use comma to separate URLs when specifying multiple servers.",
          "type" : "string"
        },
        "ssl-context-parameters" : {
          "description" : "To configure security using SSLContextParameters",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "trace-connection" : {
          "description" : "Whether or not connection trace messages should be printed to standard out for fine grained debugging of connection issues.",
          "default" : "false",
          "type" : "boolean"
        },
        "verbose" : {
          "description" : "Whether or not running in verbose mode",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "netty" : {
      "type" : "object",
      "required" : [ "host", "port", "protocol" ],
      "properties" : {
        "host" : {
          "description" : "The hostname. For the consumer the hostname is localhost or 0.0.0.0. For the producer the hostname is the remote host to connect to",
          "type" : "string"
        },
        "port" : {
          "description" : "The host port number",
          "type" : "integer"
        },
        "protocol" : {
          "description" : "The protocol to use which can be tcp or udp.",
          "enum" : [ "tcp", "udp" ],
          "type" : "string"
        },
        "allow-default-codec" : {
          "description" : "The netty component installs a default codec if both, encoder/decoder is null and textline is false. Setting allowDefaultCodec to false prevents the netty component from installing a default codec as the first element in the filter chain.",
          "default" : "true",
          "type" : "boolean"
        },
        "allow-serialized-headers" : {
          "description" : "Only used for TCP when transferExchange is true. When set to true, serializable objects in headers and properties will be added to the exchange. Otherwise Camel will exclude any non-serializable objects and log it at WARN level.",
          "default" : "false",
          "type" : "boolean"
        },
        "auto-append-delimiter" : {
          "description" : "Whether or not to auto append missing end delimiter when sending using the textline codec.",
          "default" : "true",
          "type" : "boolean"
        },
        "backlog" : {
          "description" : "Allows to configure a backlog for netty consumer (server). Note the backlog is just a best effort depending on the OS. Setting this option to a value such as 200, 500 or 1000, tells the TCP stack how long the accept queue can be If this option is not configured, then the backlog depends on OS setting.",
          "type" : "integer"
        },
        "boss-count" : {
          "description" : "When netty works on nio mode, it uses default bossCount parameter from Netty, which is 1. User can use this option to override the default bossCount from Netty",
          "default" : "1",
          "type" : "integer"
        },
        "boss-group" : {
          "description" : "Set the BossGroup which could be used for handling the new connection of the server side across the NettyEndpoint",
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "broadcast" : {
          "description" : "Setting to choose Multicast over UDP",
          "default" : "false",
          "type" : "boolean"
        },
        "channel-group" : {
          "description" : "To use a explicit ChannelGroup.",
          "type" : "string"
        },
        "client-initializer-factory" : {
          "description" : "To use a custom ClientInitializerFactory",
          "type" : "string"
        },
        "client-mode" : {
          "description" : "If the clientMode is true, netty consumer will connect the address as a TCP client.",
          "default" : "false",
          "type" : "boolean"
        },
        "connect-timeout" : {
          "description" : "Time to wait for a socket connection to be available. Value is in milliseconds.",
          "default" : "10000",
          "type" : "integer"
        },
        "correlation-manager" : {
          "description" : "To use a custom correlation manager to manage how request and reply messages are mapped when using request/reply with the netty producer. This should only be used if you have a way to map requests together with replies such as if there is correlation ids in both the request and reply messages. This can be used if you want to multiplex concurrent messages on the same channel (aka connection) in netty. When doing this you must have a way to correlate the request and reply messages so you can store the right reply on the inflight Camel Exchange before its continued routed. We recommend extending the TimeoutCorrelationManagerSupport when you build custom correlation managers. This provides support for timeout and other complexities you otherwise would need to implement as well. See also the producerPoolEnabled option for more details.",
          "type" : "string"
        },
        "decoder-max-line-length" : {
          "description" : "The max line length to use for the textline codec.",
          "default" : "1024",
          "type" : "integer"
        },
        "decoders" : {
          "description" : "A list of decoders to be used. You can use a String which have values separated by comma, and have the values be looked up in the Registry. Just remember to prefix the value with # so Camel knows it should lookup.",
          "type" : "string"
        },
        "delimiter" : {
          "description" : "The delimiter to use for the textline codec. Possible values are LINE and NULL.",
          "default" : "LINE",
          "enum" : [ "LINE", "NULL" ],
          "type" : "string"
        },
        "disconnect" : {
          "description" : "Whether or not to disconnect(close) from Netty Channel right after use. Can be used for both consumer and producer.",
          "default" : "false",
          "type" : "boolean"
        },
        "disconnect-on-no-reply" : {
          "description" : "If sync is enabled then this option dictates NettyConsumer if it should disconnect where there is no reply to send back.",
          "default" : "true",
          "type" : "boolean"
        },
        "enabled-protocols" : {
          "description" : "Which protocols to enable when using SSL",
          "default" : "TLSv1,TLSv1.1,TLSv1.2",
          "type" : "string"
        },
        "encoders" : {
          "description" : "A list of encoders to be used. You can use a String which have values separated by comma, and have the values be looked up in the Registry. Just remember to prefix the value with # so Camel knows it should lookup.",
          "type" : "string"
        },
        "encoding" : {
          "description" : "The encoding (a charset name) to use for the textline codec. If not provided, Camel will use the JVM default Charset.",
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "keep-alive" : {
          "description" : "Setting to ensure socket is not closed due to inactivity",
          "default" : "true",
          "type" : "boolean"
        },
        "key-store-file" : {
          "description" : "Client side certificate keystore to be used for encryption",
          "type" : "string"
        },
        "key-store-format" : {
          "description" : "Keystore format to be used for payload encryption. Defaults to JKS if not set",
          "type" : "string"
        },
        "key-store-resource" : {
          "description" : "Client side certificate keystore to be used for encryption. Is loaded by default from classpath, but you can prefix with classpath:, file:, or http: to load the resource from different systems.",
          "type" : "string"
        },
        "lazy-channel-creation" : {
          "description" : "Channels can be lazily created to avoid exceptions, if the remote server is not up and running when the Camel producer is started.",
          "default" : "true",
          "type" : "boolean"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "native-transport" : {
          "description" : "Whether to use native transport instead of NIO. Native transport takes advantage of the host operating system and is only supported on some platforms. You need to add the netty JAR for the host operating system you are using. See more details at: http://netty.io/wiki/native-transports.html",
          "default" : "false",
          "type" : "boolean"
        },
        "need-client-auth" : {
          "description" : "Configures whether the server needs client authentication when using SSL.",
          "default" : "false",
          "type" : "boolean"
        },
        "netty-server-bootstrap-factory" : {
          "description" : "To use a custom NettyServerBootstrapFactory",
          "type" : "string"
        },
        "network-interface" : {
          "description" : "When using UDP then this option can be used to specify a network interface by its name, such as eth0 to join a multicast group.",
          "type" : "string"
        },
        "no-reply-log-level" : {
          "description" : "If sync is enabled this option dictates NettyConsumer which logging level to use when logging a there is no reply to send back.",
          "default" : "WARN",
          "enum" : [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ],
          "type" : "string"
        },
        "options" : {
          "description" : "Allows to configure additional netty options using option. as prefix. For example option.child.keepAlive=false to set the netty option child.keepAlive=false. See the Netty documentation for possible options that can be used.",
          "type" : "string"
        },
        "passphrase" : {
          "description" : "Password setting to use in order to encrypt/decrypt payloads sent using SSH",
          "type" : "string"
        },
        "producer-pool-enabled" : {
          "description" : "Whether producer pool is enabled or not. Important: If you turn this off then a single shared connection is used for the producer, also if you are doing request/reply. That means there is a potential issue with interleaved responses if replies comes back out-of-order. Therefore you need to have a correlation id in both the request and reply messages so you can properly correlate the replies to the Camel callback that is responsible for continue processing the message in Camel. To do this you need to implement NettyCamelStateCorrelationManager as correlation manager and configure it via the correlationManager option. See also the correlationManager option for more details.",
          "default" : "true",
          "type" : "boolean"
        },
        "producer-pool-max-active" : {
          "description" : "Sets the cap on the number of objects that can be allocated by the pool (checked out to clients, or idle awaiting checkout) at a given time. Use a negative value for no limit.",
          "default" : "-1",
          "type" : "integer"
        },
        "producer-pool-max-idle" : {
          "description" : "Sets the cap on the number of idle instances in the pool.",
          "default" : "100",
          "type" : "integer"
        },
        "producer-pool-min-evictable-idle" : {
          "description" : "Sets the minimum amount of time (value in millis) an object may sit idle in the pool before it is eligible for eviction by the idle object evictor.",
          "default" : "300000",
          "type" : "integer"
        },
        "producer-pool-min-idle" : {
          "description" : "Sets the minimum number of instances allowed in the producer pool before the evictor thread (if active) spawns new objects.",
          "type" : "integer"
        },
        "receive-buffer-size" : {
          "description" : "The TCP/UDP buffer sizes to be used during inbound communication. Size is bytes.",
          "default" : "65536",
          "type" : "integer"
        },
        "receive-buffer-size-predictor" : {
          "description" : "Configures the buffer size predictor. See details at Jetty documentation and this mail thread.",
          "type" : "integer"
        },
        "reconnect" : {
          "description" : "Used only in clientMode in consumer, the consumer will attempt to reconnect on disconnection if this is enabled",
          "default" : "true",
          "type" : "boolean"
        },
        "reconnect-interval" : {
          "description" : "Used if reconnect and clientMode is enabled. The interval in milli seconds to attempt reconnection",
          "default" : "10000",
          "type" : "integer"
        },
        "request-timeout" : {
          "description" : "Allows to use a timeout for the Netty producer when calling a remote server. By default no timeout is in use. The value is in milli seconds, so eg 30000 is 30 seconds. The requestTimeout is using Netty's ReadTimeoutHandler to trigger the timeout.",
          "type" : "integer"
        },
        "reuse-address" : {
          "description" : "Setting to facilitate socket multiplexing",
          "default" : "true",
          "type" : "boolean"
        },
        "reuse-channel" : {
          "description" : "This option allows producers and consumers (in client mode) to reuse the same Netty Channel for the lifecycle of processing the Exchange. This is useful if you need to call a server multiple times in a Camel route and want to use the same network connection. When using this, the channel is not returned to the connection pool until the Exchange is done; or disconnected if the disconnect option is set to true. The reused Channel is stored on the Exchange as an exchange property with the key NettyConstants#NETTY_CHANNEL which allows you to obtain the channel during routing and use it as well.",
          "default" : "false",
          "type" : "boolean"
        },
        "security-provider" : {
          "description" : "Security provider to be used for payload encryption. Defaults to SunX509 if not set.",
          "type" : "string"
        },
        "send-buffer-size" : {
          "description" : "The TCP/UDP buffer sizes to be used during outbound communication. Size is bytes.",
          "default" : "65536",
          "type" : "integer"
        },
        "server-closed-channel-exception-caught-log-level" : {
          "description" : "If the server (NettyConsumer) catches an java.nio.channels.ClosedChannelException then its logged using this logging level. This is used to avoid logging the closed channel exceptions, as clients can disconnect abruptly and then cause a flood of closed exceptions in the Netty server.",
          "default" : "DEBUG",
          "enum" : [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ],
          "type" : "string"
        },
        "server-exception-caught-log-level" : {
          "description" : "If the server (NettyConsumer) catches an exception then its logged using this logging level.",
          "default" : "WARN",
          "enum" : [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ],
          "type" : "string"
        },
        "server-initializer-factory" : {
          "description" : "To use a custom ServerInitializerFactory",
          "type" : "string"
        },
        "ssl" : {
          "description" : "Setting to specify whether SSL encryption is applied to this endpoint",
          "default" : "false",
          "type" : "boolean"
        },
        "ssl-client-cert-headers" : {
          "description" : "When enabled and in SSL mode, then the Netty consumer will enrich the Camel Message with headers having information about the client certificate such as subject name, issuer name, serial number, and the valid date range.",
          "default" : "false",
          "type" : "boolean"
        },
        "ssl-context-parameters" : {
          "description" : "To configure security using SSLContextParameters",
          "type" : "string"
        },
        "ssl-handler" : {
          "description" : "Reference to a class that could be used to return an SSL Handler",
          "type" : "string"
        },
        "sync" : {
          "description" : "Setting to set endpoint as one-way or request-response",
          "default" : "true",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "tcp-no-delay" : {
          "description" : "Setting to improve TCP protocol performance",
          "default" : "true",
          "type" : "boolean"
        },
        "textline" : {
          "description" : "Only used for TCP. If no codec is specified, you can use this flag to indicate a text line based codec; if not specified or the value is false, then Object Serialization is assumed over TCP - however only Strings are allowed to be serialized by default.",
          "default" : "false",
          "type" : "boolean"
        },
        "transfer-exchange" : {
          "description" : "Only used for TCP. You can transfer the exchange over the wire instead of just the body. The following fields are transferred: In body, Out body, fault body, In headers, Out headers, fault headers, exchange properties, exchange exception. This requires that the objects are serializable. Camel will exclude any non-serializable objects and log it at WARN level.",
          "default" : "false",
          "type" : "boolean"
        },
        "trust-store-file" : {
          "description" : "Server side certificate keystore to be used for encryption",
          "type" : "string"
        },
        "trust-store-resource" : {
          "description" : "Server side certificate keystore to be used for encryption. Is loaded by default from classpath, but you can prefix with classpath:, file:, or http: to load the resource from different systems.",
          "type" : "string"
        },
        "udp-byte-array-codec" : {
          "description" : "For UDP only. If enabled the using byte array codec instead of Java serialization protocol.",
          "default" : "false",
          "type" : "boolean"
        },
        "udp-connectionless-sending" : {
          "description" : "This option supports connection less udp sending which is a real fire and forget. A connected udp send receive the PortUnreachableException if no one is listen on the receiving port.",
          "default" : "false",
          "type" : "boolean"
        },
        "use-byte-buf" : {
          "description" : "If the useByteBuf is true, netty producer will turn the message body into ByteBuf before sending it out.",
          "default" : "false",
          "type" : "boolean"
        },
        "using-executor-service" : {
          "description" : "Whether to use ordered thread pool, to ensure events are processed orderly on the same channel.",
          "default" : "true",
          "type" : "boolean"
        },
        "worker-count" : {
          "description" : "When netty works on nio mode, it uses default workerCount parameter from Netty (which is cpu_core_threads x 2). User can use this option to override the default workerCount from Netty.",
          "type" : "integer"
        },
        "worker-group" : {
          "description" : "To use a explicit EventLoopGroup as the boss thread pool. For example to share a thread pool with multiple consumers or producers. By default each consumer or producer has their own worker pool with 2 x cpu count core threads.",
          "type" : "string"
        }
      }
    },
    "netty-http" : {
      "type" : "object",
      "required" : [ "host", "protocol" ],
      "properties" : {
        "host" : {
          "description" : "The local hostname such as localhost, or 0.0.0.0 when being a consumer. The remote HTTP server hostname when using producer.",
          "type" : "string"
        },
        "path" : {
          "description" : "Resource path",
          "type" : "string"
        },
        "port" : {
          "description" : "The host port number",
          "type" : "integer"
        },
        "protocol" : {
          "description" : "The protocol to use which is either http, https or proxy - a consumer only option.",
          "enum" : [ "http", "https" ],
          "type" : "string"
        },
        "allow-serialized-headers" : {
          "description" : "Only used for TCP when transferExchange is true. When set to true, serializable objects in headers and properties will be added to the exchange. Otherwise Camel will exclude any non-serializable objects and log it at WARN level.",
          "default" : "false",
          "type" : "boolean"
        },
        "backlog" : {
          "description" : "Allows to configure a backlog for netty consumer (server). Note the backlog is just a best effort depending on the OS. Setting this option to a value such as 200, 500 or 1000, tells the TCP stack how long the accept queue can be If this option is not configured, then the backlog depends on OS setting.",
          "type" : "integer"
        },
        "boss-count" : {
          "description" : "When netty works on nio mode, it uses default bossCount parameter from Netty, which is 1. User can use this option to override the default bossCount from Netty",
          "default" : "1",
          "type" : "integer"
        },
        "boss-group" : {
          "description" : "Set the BossGroup which could be used for handling the new connection of the server side across the NettyEndpoint",
          "type" : "string"
        },
        "bridge-endpoint" : {
          "description" : "If the option is true, the producer will ignore the Exchange.HTTP_URI header, and use the endpoint's URI for request. You may also set the throwExceptionOnFailure to be false to let the producer send all the fault response back. The consumer working in the bridge mode will skip the gzip compression and WWW URL form encoding (by adding the Exchange.SKIP_GZIP_ENCODING and Exchange.SKIP_WWW_FORM_URLENCODED headers to the consumed exchange).",
          "default" : "false",
          "type" : "boolean"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "channel-group" : {
          "description" : "To use a explicit ChannelGroup.",
          "type" : "string"
        },
        "chunked-max-content-length" : {
          "description" : "Value in bytes the max content length per chunked frame received on the Netty HTTP server.",
          "default" : "1048576",
          "type" : "integer"
        },
        "client-initializer-factory" : {
          "description" : "To use a custom ClientInitializerFactory",
          "type" : "string"
        },
        "compression" : {
          "description" : "Allow using gzip/deflate for compression on the Netty HTTP server if the client supports it from the HTTP headers.",
          "default" : "false",
          "type" : "boolean"
        },
        "configuration" : {
          "description" : "To use a custom configured NettyHttpConfiguration for configuring this endpoint.",
          "type" : "string"
        },
        "connect-timeout" : {
          "description" : "Time to wait for a socket connection to be available. Value is in milliseconds.",
          "default" : "10000",
          "type" : "integer"
        },
        "cookie-handler" : {
          "description" : "Configure a cookie handler to maintain a HTTP session",
          "type" : "string"
        },
        "decoders" : {
          "description" : "A list of decoders to be used. You can use a String which have values separated by comma, and have the values be looked up in the Registry. Just remember to prefix the value with # so Camel knows it should lookup.",
          "type" : "string"
        },
        "disable-stream-cache" : {
          "description" : "Determines whether or not the raw input stream from Netty HttpRequest#getContent() or HttpResponset#getContent() is cached or not (Camel will read the stream into a in light-weight memory based Stream caching) cache. By default Camel will cache the Netty input stream to support reading it multiple times to ensure it Camel can retrieve all data from the stream. However you can set this option to true when you for example need to access the raw stream, such as streaming it directly to a file or other persistent store. Mind that if you enable this option, then you cannot read the Netty stream multiple times out of the box, and you would need manually to reset the reader index on the Netty raw stream. Also Netty will auto-close the Netty stream when the Netty HTTP server/HTTP client is done processing, which means that if the asynchronous routing engine is in use then any asynchronous thread that may continue routing the org.apache.camel.Exchange may not be able to read the Netty stream, because Netty has closed it.",
          "default" : "false",
          "type" : "boolean"
        },
        "disconnect" : {
          "description" : "Whether or not to disconnect(close) from Netty Channel right after use. Can be used for both consumer and producer.",
          "default" : "false",
          "type" : "boolean"
        },
        "disconnect-on-no-reply" : {
          "description" : "If sync is enabled then this option dictates NettyConsumer if it should disconnect where there is no reply to send back.",
          "default" : "true",
          "type" : "boolean"
        },
        "enabled-protocols" : {
          "description" : "Which protocols to enable when using SSL",
          "default" : "TLSv1,TLSv1.1,TLSv1.2",
          "type" : "string"
        },
        "encoders" : {
          "description" : "A list of encoders to be used. You can use a String which have values separated by comma, and have the values be looked up in the Registry. Just remember to prefix the value with # so Camel knows it should lookup.",
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "header-filter-strategy" : {
          "description" : "To use a custom org.apache.camel.spi.HeaderFilterStrategy to filter headers.",
          "type" : "string"
        },
        "http-method-restrict" : {
          "description" : "To disable HTTP methods on the Netty HTTP consumer. You can specify multiple separated by comma.",
          "type" : "string"
        },
        "keep-alive" : {
          "description" : "Setting to ensure socket is not closed due to inactivity",
          "default" : "true",
          "type" : "boolean"
        },
        "key-store-file" : {
          "description" : "Client side certificate keystore to be used for encryption",
          "type" : "string"
        },
        "key-store-format" : {
          "description" : "Keystore format to be used for payload encryption. Defaults to JKS if not set",
          "type" : "string"
        },
        "key-store-resource" : {
          "description" : "Client side certificate keystore to be used for encryption. Is loaded by default from classpath, but you can prefix with classpath:, file:, or http: to load the resource from different systems.",
          "type" : "string"
        },
        "lazy-channel-creation" : {
          "description" : "Channels can be lazily created to avoid exceptions, if the remote server is not up and running when the Camel producer is started.",
          "default" : "true",
          "type" : "boolean"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "log-warn-on-bad-request" : {
          "description" : "Whether Netty HTTP server should log a WARN if decoding the HTTP request failed and a HTTP Status 400 (bad request) is returned.",
          "default" : "true",
          "type" : "boolean"
        },
        "map-headers" : {
          "description" : "If this option is enabled, then during binding from Netty to Camel Message then the headers will be mapped as well (eg added as header to the Camel Message as well). You can turn off this option to disable this. The headers can still be accessed from the org.apache.camel.component.netty.http.NettyHttpMessage message with the method getHttpRequest() that returns the Netty HTTP request io.netty.handler.codec.http.HttpRequest instance.",
          "default" : "true",
          "type" : "boolean"
        },
        "match-on-uri-prefix" : {
          "description" : "Whether or not Camel should try to find a target consumer by matching the URI prefix if no exact match is found.",
          "default" : "false",
          "type" : "boolean"
        },
        "max-header-size" : {
          "description" : "The maximum length of all headers. If the sum of the length of each header exceeds this value, a io.netty.handler.codec.TooLongFrameException will be raised.",
          "default" : "8192",
          "type" : "integer"
        },
        "mute-exception" : {
          "description" : "If enabled and an Exchange failed processing on the consumer side the response's body won't contain the exception's stack trace.",
          "default" : "false",
          "type" : "boolean"
        },
        "native-transport" : {
          "description" : "Whether to use native transport instead of NIO. Native transport takes advantage of the host operating system and is only supported on some platforms. You need to add the netty JAR for the host operating system you are using. See more details at: http://netty.io/wiki/native-transports.html",
          "default" : "false",
          "type" : "boolean"
        },
        "need-client-auth" : {
          "description" : "Configures whether the server needs client authentication when using SSL.",
          "default" : "false",
          "type" : "boolean"
        },
        "netty-http-binding" : {
          "description" : "To use a custom org.apache.camel.component.netty.http.NettyHttpBinding for binding to/from Netty and Camel Message API.",
          "type" : "string"
        },
        "netty-server-bootstrap-factory" : {
          "description" : "To use a custom NettyServerBootstrapFactory",
          "type" : "string"
        },
        "netty-shared-http-server" : {
          "description" : "To use a shared Netty HTTP server. See Netty HTTP Server Example for more details.",
          "type" : "string"
        },
        "no-reply-log-level" : {
          "description" : "If sync is enabled this option dictates NettyConsumer which logging level to use when logging a there is no reply to send back.",
          "default" : "WARN",
          "enum" : [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ],
          "type" : "string"
        },
        "ok-status-code-range" : {
          "description" : "The status codes which are considered a success response. The values are inclusive. Multiple ranges can be defined, separated by comma, e.g. 200-204,209,301-304. Each range must be a single number or from-to with the dash included. The default range is 200-299",
          "default" : "200-299",
          "type" : "string"
        },
        "options" : {
          "description" : "Allows to configure additional netty options using option. as prefix. For example option.child.keepAlive=false to set the netty option child.keepAlive=false. See the Netty documentation for possible options that can be used.",
          "type" : "string"
        },
        "passphrase" : {
          "description" : "Password setting to use in order to encrypt/decrypt payloads sent using SSH",
          "type" : "string"
        },
        "producer-pool-enabled" : {
          "description" : "Whether producer pool is enabled or not. Important: If you turn this off then a single shared connection is used for the producer, also if you are doing request/reply. That means there is a potential issue with interleaved responses if replies comes back out-of-order. Therefore you need to have a correlation id in both the request and reply messages so you can properly correlate the replies to the Camel callback that is responsible for continue processing the message in Camel. To do this you need to implement NettyCamelStateCorrelationManager as correlation manager and configure it via the correlationManager option. See also the correlationManager option for more details.",
          "default" : "true",
          "type" : "boolean"
        },
        "producer-pool-max-active" : {
          "description" : "Sets the cap on the number of objects that can be allocated by the pool (checked out to clients, or idle awaiting checkout) at a given time. Use a negative value for no limit.",
          "default" : "-1",
          "type" : "integer"
        },
        "producer-pool-max-idle" : {
          "description" : "Sets the cap on the number of idle instances in the pool.",
          "default" : "100",
          "type" : "integer"
        },
        "producer-pool-min-evictable-idle" : {
          "description" : "Sets the minimum amount of time (value in millis) an object may sit idle in the pool before it is eligible for eviction by the idle object evictor.",
          "default" : "300000",
          "type" : "integer"
        },
        "producer-pool-min-idle" : {
          "description" : "Sets the minimum number of instances allowed in the producer pool before the evictor thread (if active) spawns new objects.",
          "type" : "integer"
        },
        "receive-buffer-size" : {
          "description" : "The TCP/UDP buffer sizes to be used during inbound communication. Size is bytes.",
          "default" : "65536",
          "type" : "integer"
        },
        "receive-buffer-size-predictor" : {
          "description" : "Configures the buffer size predictor. See details at Jetty documentation and this mail thread.",
          "type" : "integer"
        },
        "request-timeout" : {
          "description" : "Allows to use a timeout for the Netty producer when calling a remote server. By default no timeout is in use. The value is in milli seconds, so eg 30000 is 30 seconds. The requestTimeout is using Netty's ReadTimeoutHandler to trigger the timeout.",
          "type" : "integer"
        },
        "reuse-address" : {
          "description" : "Setting to facilitate socket multiplexing",
          "default" : "true",
          "type" : "boolean"
        },
        "reuse-channel" : {
          "description" : "This option allows producers and consumers (in client mode) to reuse the same Netty Channel for the lifecycle of processing the Exchange. This is useful if you need to call a server multiple times in a Camel route and want to use the same network connection. When using this, the channel is not returned to the connection pool until the Exchange is done; or disconnected if the disconnect option is set to true. The reused Channel is stored on the Exchange as an exchange property with the key NettyConstants#NETTY_CHANNEL which allows you to obtain the channel during routing and use it as well.",
          "default" : "false",
          "type" : "boolean"
        },
        "security-configuration" : {
          "description" : "Refers to a org.apache.camel.component.netty.http.NettyHttpSecurityConfiguration for configuring secure web resources.",
          "type" : "string"
        },
        "security-options" : {
          "description" : "To configure NettyHttpSecurityConfiguration using key/value pairs from the map",
          "type" : "string"
        },
        "security-provider" : {
          "description" : "Security provider to be used for payload encryption. Defaults to SunX509 if not set.",
          "type" : "string"
        },
        "send503when-suspended" : {
          "description" : "Whether to send back HTTP status code 503 when the consumer has been suspended. If the option is false then the Netty Acceptor is unbound when the consumer is suspended, so clients cannot connect anymore.",
          "default" : "true",
          "type" : "boolean"
        },
        "send-buffer-size" : {
          "description" : "The TCP/UDP buffer sizes to be used during outbound communication. Size is bytes.",
          "default" : "65536",
          "type" : "integer"
        },
        "server-closed-channel-exception-caught-log-level" : {
          "description" : "If the server (NettyConsumer) catches an java.nio.channels.ClosedChannelException then its logged using this logging level. This is used to avoid logging the closed channel exceptions, as clients can disconnect abruptly and then cause a flood of closed exceptions in the Netty server.",
          "default" : "DEBUG",
          "enum" : [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ],
          "type" : "string"
        },
        "server-exception-caught-log-level" : {
          "description" : "If the server (NettyConsumer) catches an exception then its logged using this logging level.",
          "default" : "WARN",
          "enum" : [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ],
          "type" : "string"
        },
        "server-initializer-factory" : {
          "description" : "To use a custom ServerInitializerFactory",
          "type" : "string"
        },
        "ssl" : {
          "description" : "Setting to specify whether SSL encryption is applied to this endpoint",
          "default" : "false",
          "type" : "boolean"
        },
        "ssl-client-cert-headers" : {
          "description" : "When enabled and in SSL mode, then the Netty consumer will enrich the Camel Message with headers having information about the client certificate such as subject name, issuer name, serial number, and the valid date range.",
          "default" : "false",
          "type" : "boolean"
        },
        "ssl-context-parameters" : {
          "description" : "To configure security using SSLContextParameters",
          "type" : "string"
        },
        "ssl-handler" : {
          "description" : "Reference to a class that could be used to return an SSL Handler",
          "type" : "string"
        },
        "sync" : {
          "description" : "Setting to set endpoint as one-way or request-response",
          "default" : "true",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "tcp-no-delay" : {
          "description" : "Setting to improve TCP protocol performance",
          "default" : "true",
          "type" : "boolean"
        },
        "throw-exception-on-failure" : {
          "description" : "Option to disable throwing the HttpOperationFailedException in case of failed responses from the remote server. This allows you to get all responses regardless of the HTTP status code.",
          "default" : "true",
          "type" : "boolean"
        },
        "trace-enabled" : {
          "description" : "Specifies whether to enable HTTP TRACE for this Netty HTTP consumer. By default TRACE is turned off.",
          "default" : "false",
          "type" : "boolean"
        },
        "transfer-exception" : {
          "description" : "If enabled and an Exchange failed processing on the consumer side, and if the caused Exception was send back serialized in the response as a application/x-java-serialized-object content type. On the producer side the exception will be deserialized and thrown as is, instead of the HttpOperationFailedException. The caused exception is required to be serialized. This is by default turned off. If you enable this then be aware that Java will deserialize the incoming data from the request to Java and that can be a potential security risk.",
          "default" : "false",
          "type" : "boolean"
        },
        "transfer-exchange" : {
          "description" : "Only used for TCP. You can transfer the exchange over the wire instead of just the body. The following fields are transferred: In body, Out body, fault body, In headers, Out headers, fault headers, exchange properties, exchange exception. This requires that the objects are serializable. Camel will exclude any non-serializable objects and log it at WARN level.",
          "default" : "false",
          "type" : "boolean"
        },
        "trust-store-file" : {
          "description" : "Server side certificate keystore to be used for encryption",
          "type" : "string"
        },
        "trust-store-resource" : {
          "description" : "Server side certificate keystore to be used for encryption. Is loaded by default from classpath, but you can prefix with classpath:, file:, or http: to load the resource from different systems.",
          "type" : "string"
        },
        "url-decode-headers" : {
          "description" : "If this option is enabled, then during binding from Netty to Camel Message then the header values will be URL decoded (eg %20 will be a space character. Notice this option is used by the default org.apache.camel.component.netty.http.NettyHttpBinding and therefore if you implement a custom org.apache.camel.component.netty.http.NettyHttpBinding then you would need to decode the headers accordingly to this option.",
          "default" : "false",
          "type" : "boolean"
        },
        "use-relative-path" : {
          "description" : "Sets whether to use a relative path in HTTP requests.",
          "default" : "true",
          "type" : "boolean"
        },
        "using-executor-service" : {
          "description" : "Whether to use ordered thread pool, to ensure events are processed orderly on the same channel.",
          "default" : "true",
          "type" : "boolean"
        },
        "worker-count" : {
          "description" : "When netty works on nio mode, it uses default workerCount parameter from Netty (which is cpu_core_threads x 2). User can use this option to override the default workerCount from Netty.",
          "type" : "integer"
        },
        "worker-group" : {
          "description" : "To use a explicit EventLoopGroup as the boss thread pool. For example to share a thread pool with multiple consumers or producers. By default each consumer or producer has their own worker pool with 2 x cpu count core threads.",
          "type" : "string"
        }
      }
    },
    "nitrite" : {
      "type" : "object",
      "required" : [ "database" ],
      "properties" : {
        "database" : {
          "description" : "Path to database file. Will be created if not exists.",
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "collection" : {
          "description" : "Name of Nitrite collection. Cannot be used in combination with repositoryClass option.",
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "password" : {
          "description" : "Password for Nitrite database. Required, if option username specified.",
          "type" : "string"
        },
        "repository-class" : {
          "description" : "Class of Nitrite ObjectRepository. Cannot be used in combination with collection option.",
          "type" : "string"
        },
        "repository-name" : {
          "description" : "Optional name of ObjectRepository. Can be only used in combination with repositoryClass, otherwise have no effect",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "username" : {
          "description" : "Username for Nitrite database. Database is not secured if option not specified.",
          "type" : "string"
        }
      }
    },
    "nsq" : {
      "type" : "object",
      "required" : [ "topic" ],
      "properties" : {
        "topic" : {
          "description" : "The NSQ topic",
          "type" : "string"
        },
        "auto-finish" : {
          "description" : "Automatically finish the NSQ Message when it is retrieved from the queue and before the Exchange is processed",
          "default" : "true",
          "type" : "boolean"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "channel" : {
          "description" : "The NSQ channel",
          "type" : "string"
        },
        "custom-nsq-lookup" : {
          "description" : "A Custom NSQ lookup implementation",
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "lookup-interval" : {
          "description" : "The lookup interval",
          "default" : "5000",
          "type" : "string"
        },
        "lookup-server-port" : {
          "description" : "The NSQ lookup server port",
          "default" : "4161",
          "type" : "integer"
        },
        "message-timeout" : {
          "description" : "The NSQ consumer timeout period for messages retrieved from the queue. A value of -1 is the server default",
          "default" : "-1",
          "type" : "string"
        },
        "pool-size" : {
          "description" : "Consumer pool size",
          "default" : "10",
          "type" : "integer"
        },
        "port" : {
          "description" : "The port of the nsqd server",
          "default" : "4150",
          "type" : "integer"
        },
        "requeue-interval" : {
          "description" : "The requeue interval in milliseconds. A value of -1 is the server default",
          "default" : "-1",
          "type" : "string"
        },
        "secure" : {
          "description" : "Set secure option indicating TLS is required",
          "default" : "false",
          "type" : "boolean"
        },
        "servers" : {
          "description" : "The hostnames of one or more nsqlookupd servers (consumer) or nsqd servers (producer)",
          "type" : "string"
        },
        "ssl-context-parameters" : {
          "description" : "To configure security using SSLContextParameters",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "user-agent" : {
          "description" : "A String to identify the kind of client",
          "type" : "string"
        }
      }
    },
    "oaipmh" : {
      "type" : "object",
      "required" : [ "baseUrl" ],
      "properties" : {
        "base-url" : {
          "description" : "Base URL of the repository to which the request is made through the OAI-PMH protocol",
          "type" : "string"
        },
        "backoff-error-threshold" : {
          "description" : "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-idle-threshold" : {
          "description" : "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-multiplier" : {
          "description" : "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
          "type" : "integer"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "delay" : {
          "description" : "Milliseconds before the next poll.",
          "default" : "500",
          "type" : "integer"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "from" : {
          "description" : "Specifies a lower bound for datestamp-based selective harvesting. UTC DateTime value",
          "type" : "string"
        },
        "greedy" : {
          "description" : "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
          "default" : "false",
          "type" : "boolean"
        },
        "identifier" : {
          "description" : "Identifier of the requested resources. Applicable only with certain verbs",
          "type" : "string"
        },
        "ignore-ssl-warnings" : {
          "description" : "Ignore SSL certificate warnings",
          "default" : "false",
          "type" : "boolean"
        },
        "initial-delay" : {
          "description" : "Milliseconds before the first poll starts.",
          "default" : "1000",
          "type" : "integer"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "metadata-prefix" : {
          "description" : "Specifies the metadataPrefix of the format that should be included in the metadata part of the returned records.",
          "default" : "oai_dc",
          "type" : "string"
        },
        "only-first" : {
          "description" : "Returns the response of a single request. Otherwise it will make requests until there is no more data to return.",
          "default" : "false",
          "type" : "boolean"
        },
        "poll-strategy" : {
          "description" : "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
          "type" : "string"
        },
        "repeat-count" : {
          "description" : "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
          "default" : "0",
          "type" : "integer"
        },
        "run-logging-level" : {
          "description" : "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
          "default" : "TRACE",
          "enum" : [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ],
          "type" : "string"
        },
        "scheduled-executor-service" : {
          "description" : "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
          "type" : "string"
        },
        "scheduler" : {
          "description" : "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
          "default" : "none",
          "type" : "string"
        },
        "scheduler-properties" : {
          "description" : "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
          "type" : "string"
        },
        "send-empty-message-when-idle" : {
          "description" : "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
          "default" : "false",
          "type" : "boolean"
        },
        "set" : {
          "description" : "Specifies membership as a criteria for set-based selective harvesting",
          "type" : "string"
        },
        "ssl" : {
          "description" : "Causes the defined url to make an https request",
          "default" : "false",
          "type" : "boolean"
        },
        "start-scheduler" : {
          "description" : "Whether the scheduler should be auto started.",
          "default" : "true",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "time-unit" : {
          "description" : "Time unit for initialDelay and delay options.",
          "default" : "MILLISECONDS",
          "enum" : [ "NANOSECONDS", "MICROSECONDS", "MILLISECONDS", "SECONDS", "MINUTES", "HOURS", "DAYS" ],
          "type" : "string"
        },
        "until" : {
          "description" : "Specifies an upper bound for datestamp-based selective harvesting. UTC DateTime value.",
          "type" : "string"
        },
        "use-fixed-delay" : {
          "description" : "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
          "default" : "true",
          "type" : "boolean"
        },
        "verb" : {
          "description" : "Request name supported by OAI-PMh protocol",
          "default" : "ListRecords",
          "type" : "string"
        }
      }
    },
    "olingo2" : {
      "type" : "object",
      "required" : [ "apiName", "methodName" ],
      "properties" : {
        "api-name" : {
          "description" : "What kind of operation to perform",
          "enum" : [ "DEFAULT" ],
          "type" : "string"
        },
        "method-name" : {
          "description" : "What sub operation to use for the selected operation",
          "type" : "string"
        },
        "backoff-error-threshold" : {
          "description" : "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-idle-threshold" : {
          "description" : "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-multiplier" : {
          "description" : "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
          "type" : "integer"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "connect-timeout" : {
          "description" : "HTTP connection creation timeout in milliseconds, defaults to 30,000 (30 seconds)",
          "default" : "30000",
          "type" : "integer"
        },
        "content-type" : {
          "description" : "Content-Type header value can be used to specify JSON or XML message format, defaults to application/json;charset=utf-8",
          "default" : "application/json;charset=utf-8",
          "type" : "string"
        },
        "delay" : {
          "description" : "Milliseconds before the next poll.",
          "default" : "500",
          "type" : "integer"
        },
        "entity-provider-read-properties" : {
          "description" : "Custom entity provider read properties applied to all read operations.",
          "type" : "string"
        },
        "entity-provider-write-properties" : {
          "description" : "Custom entity provider write properties applied to create, update, patch, batch and merge operations. For instance users can skip the Json object wrapper or enable content only mode when sending request data. A service URI set in the properties will always be overwritten by the serviceUri configuration parameter. Please consider to using the serviceUri configuration parameter instead of setting the respective write property here.",
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "filter-already-seen" : {
          "description" : "Set this to true to filter out results that have already been communicated by this component.",
          "default" : "false",
          "type" : "boolean"
        },
        "greedy" : {
          "description" : "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
          "default" : "false",
          "type" : "boolean"
        },
        "http-async-client-builder" : {
          "description" : "Custom HTTP async client builder for more complex HTTP client configuration, overrides connectionTimeout, socketTimeout, proxy and sslContext. Note that a socketTimeout MUST be specified in the builder, otherwise OData requests could block indefinitely",
          "type" : "string"
        },
        "http-client-builder" : {
          "description" : "Custom HTTP client builder for more complex HTTP client configuration, overrides connectionTimeout, socketTimeout, proxy and sslContext. Note that a socketTimeout MUST be specified in the builder, otherwise OData requests could block indefinitely",
          "type" : "string"
        },
        "http-headers" : {
          "description" : "Custom HTTP headers to inject into every request, this could include OAuth tokens, etc.",
          "type" : "string"
        },
        "in-body" : {
          "description" : "Sets the name of a parameter to be passed in the exchange In Body",
          "type" : "string"
        },
        "initial-delay" : {
          "description" : "Milliseconds before the first poll starts.",
          "default" : "1000",
          "type" : "integer"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "poll-strategy" : {
          "description" : "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
          "type" : "string"
        },
        "proxy" : {
          "description" : "HTTP proxy server configuration",
          "type" : "string"
        },
        "repeat-count" : {
          "description" : "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
          "default" : "0",
          "type" : "integer"
        },
        "run-logging-level" : {
          "description" : "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
          "default" : "TRACE",
          "enum" : [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ],
          "type" : "string"
        },
        "scheduled-executor-service" : {
          "description" : "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
          "type" : "string"
        },
        "scheduler" : {
          "description" : "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
          "default" : "none",
          "type" : "string"
        },
        "scheduler-properties" : {
          "description" : "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
          "type" : "string"
        },
        "send-empty-message-when-idle" : {
          "description" : "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
          "default" : "false",
          "type" : "boolean"
        },
        "service-uri" : {
          "description" : "Target OData service base URI, e.g. http://services.odata.org/OData/OData.svc",
          "type" : "string"
        },
        "socket-timeout" : {
          "description" : "HTTP request timeout in milliseconds, defaults to 30,000 (30 seconds)",
          "default" : "30000",
          "type" : "integer"
        },
        "split-result" : {
          "description" : "For endpoints that return an array or collection, a consumer endpoint will map every element to distinct messages, unless splitResult is set to false.",
          "default" : "true",
          "type" : "boolean"
        },
        "ssl-context-parameters" : {
          "description" : "To configure security using SSLContextParameters",
          "type" : "string"
        },
        "start-scheduler" : {
          "description" : "Whether the scheduler should be auto started.",
          "default" : "true",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "time-unit" : {
          "description" : "Time unit for initialDelay and delay options.",
          "default" : "MILLISECONDS",
          "enum" : [ "NANOSECONDS", "MICROSECONDS", "MILLISECONDS", "SECONDS", "MINUTES", "HOURS", "DAYS" ],
          "type" : "string"
        },
        "use-fixed-delay" : {
          "description" : "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
          "default" : "true",
          "type" : "boolean"
        }
      }
    },
    "olingo4" : {
      "type" : "object",
      "required" : [ "apiName", "methodName" ],
      "properties" : {
        "api-name" : {
          "description" : "What kind of operation to perform",
          "enum" : [ "DEFAULT" ],
          "type" : "string"
        },
        "method-name" : {
          "description" : "What sub operation to use for the selected operation",
          "type" : "string"
        },
        "backoff-error-threshold" : {
          "description" : "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-idle-threshold" : {
          "description" : "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-multiplier" : {
          "description" : "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
          "type" : "integer"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "connect-timeout" : {
          "description" : "HTTP connection creation timeout in milliseconds, defaults to 30,000 (30 seconds)",
          "default" : "30000",
          "type" : "integer"
        },
        "content-type" : {
          "description" : "Content-Type header value can be used to specify JSON or XML message format, defaults to application/json;charset=utf-8",
          "default" : "application/json;charset=utf-8",
          "type" : "string"
        },
        "delay" : {
          "description" : "Milliseconds before the next poll.",
          "default" : "500",
          "type" : "integer"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "filter-already-seen" : {
          "description" : "Set this to true to filter out results that have already been communicated by this component.",
          "default" : "false",
          "type" : "boolean"
        },
        "greedy" : {
          "description" : "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
          "default" : "false",
          "type" : "boolean"
        },
        "http-async-client-builder" : {
          "description" : "Custom HTTP async client builder for more complex HTTP client configuration, overrides connectionTimeout, socketTimeout, proxy and sslContext. Note that a socketTimeout MUST be specified in the builder, otherwise OData requests could block indefinitely",
          "type" : "string"
        },
        "http-client-builder" : {
          "description" : "Custom HTTP client builder for more complex HTTP client configuration, overrides connectionTimeout, socketTimeout, proxy and sslContext. Note that a socketTimeout MUST be specified in the builder, otherwise OData requests could block indefinitely",
          "type" : "string"
        },
        "http-headers" : {
          "description" : "Custom HTTP headers to inject into every request, this could include OAuth tokens, etc.",
          "type" : "string"
        },
        "in-body" : {
          "description" : "Sets the name of a parameter to be passed in the exchange In Body",
          "type" : "string"
        },
        "initial-delay" : {
          "description" : "Milliseconds before the first poll starts.",
          "default" : "1000",
          "type" : "integer"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "poll-strategy" : {
          "description" : "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
          "type" : "string"
        },
        "proxy" : {
          "description" : "HTTP proxy server configuration",
          "type" : "string"
        },
        "repeat-count" : {
          "description" : "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
          "default" : "0",
          "type" : "integer"
        },
        "run-logging-level" : {
          "description" : "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
          "default" : "TRACE",
          "enum" : [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ],
          "type" : "string"
        },
        "scheduled-executor-service" : {
          "description" : "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
          "type" : "string"
        },
        "scheduler" : {
          "description" : "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
          "default" : "none",
          "type" : "string"
        },
        "scheduler-properties" : {
          "description" : "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
          "type" : "string"
        },
        "send-empty-message-when-idle" : {
          "description" : "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
          "default" : "false",
          "type" : "boolean"
        },
        "service-uri" : {
          "description" : "Target OData service base URI, e.g. http://services.odata.org/OData/OData.svc",
          "type" : "string"
        },
        "socket-timeout" : {
          "description" : "HTTP request timeout in milliseconds, defaults to 30,000 (30 seconds)",
          "default" : "30000",
          "type" : "integer"
        },
        "split-result" : {
          "description" : "For endpoints that return an array or collection, a consumer endpoint will map every element to distinct messages, unless splitResult is set to false.",
          "default" : "true",
          "type" : "boolean"
        },
        "ssl-context-parameters" : {
          "description" : "To configure security using SSLContextParameters",
          "type" : "string"
        },
        "start-scheduler" : {
          "description" : "Whether the scheduler should be auto started.",
          "default" : "true",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "time-unit" : {
          "description" : "Time unit for initialDelay and delay options.",
          "default" : "MILLISECONDS",
          "enum" : [ "NANOSECONDS", "MICROSECONDS", "MILLISECONDS", "SECONDS", "MINUTES", "HOURS", "DAYS" ],
          "type" : "string"
        },
        "use-fixed-delay" : {
          "description" : "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
          "default" : "true",
          "type" : "boolean"
        }
      }
    },
    "openshift-build-configs" : {
      "type" : "object",
      "required" : [ "masterUrl" ],
      "properties" : {
        "master-url" : {
          "description" : "Kubernetes Master url",
          "type" : "string"
        },
        "api-version" : {
          "description" : "The Kubernetes API Version to use",
          "type" : "string"
        },
        "ca-cert-data" : {
          "description" : "The CA Cert Data",
          "type" : "string"
        },
        "ca-cert-file" : {
          "description" : "The CA Cert File",
          "type" : "string"
        },
        "client-cert-data" : {
          "description" : "The Client Cert Data",
          "type" : "string"
        },
        "client-cert-file" : {
          "description" : "The Client Cert File",
          "type" : "string"
        },
        "client-key-algo" : {
          "description" : "The Key Algorithm used by the client",
          "type" : "string"
        },
        "client-key-data" : {
          "description" : "The Client Key data",
          "type" : "string"
        },
        "client-key-file" : {
          "description" : "The Client Key file",
          "type" : "string"
        },
        "client-key-passphrase" : {
          "description" : "The Client Key Passphrase",
          "type" : "string"
        },
        "connection-timeout" : {
          "description" : "Connection timeout in milliseconds to use when making requests to the Kubernetes API server.",
          "type" : "integer"
        },
        "dns-domain" : {
          "description" : "The dns domain, used for ServiceCall EIP",
          "type" : "string"
        },
        "kubernetes-client" : {
          "description" : "Default KubernetesClient to use if provided",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "oauth-token" : {
          "description" : "The Auth Token",
          "type" : "string"
        },
        "operation" : {
          "description" : "Producer operation to do on Kubernetes",
          "type" : "string"
        },
        "password" : {
          "description" : "Password to connect to Kubernetes",
          "type" : "string"
        },
        "port-name" : {
          "description" : "The port name, used for ServiceCall EIP",
          "type" : "string"
        },
        "port-protocol" : {
          "description" : "The port protocol, used for ServiceCall EIP",
          "default" : "tcp",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "trust-certs" : {
          "description" : "Define if the certs we used are trusted anyway or not",
          "type" : "boolean"
        },
        "username" : {
          "description" : "Username to connect to Kubernetes",
          "type" : "string"
        }
      }
    },
    "openshift-builds" : {
      "type" : "object",
      "required" : [ "masterUrl" ],
      "properties" : {
        "master-url" : {
          "description" : "Kubernetes Master url",
          "type" : "string"
        },
        "api-version" : {
          "description" : "The Kubernetes API Version to use",
          "type" : "string"
        },
        "ca-cert-data" : {
          "description" : "The CA Cert Data",
          "type" : "string"
        },
        "ca-cert-file" : {
          "description" : "The CA Cert File",
          "type" : "string"
        },
        "client-cert-data" : {
          "description" : "The Client Cert Data",
          "type" : "string"
        },
        "client-cert-file" : {
          "description" : "The Client Cert File",
          "type" : "string"
        },
        "client-key-algo" : {
          "description" : "The Key Algorithm used by the client",
          "type" : "string"
        },
        "client-key-data" : {
          "description" : "The Client Key data",
          "type" : "string"
        },
        "client-key-file" : {
          "description" : "The Client Key file",
          "type" : "string"
        },
        "client-key-passphrase" : {
          "description" : "The Client Key Passphrase",
          "type" : "string"
        },
        "connection-timeout" : {
          "description" : "Connection timeout in milliseconds to use when making requests to the Kubernetes API server.",
          "type" : "integer"
        },
        "dns-domain" : {
          "description" : "The dns domain, used for ServiceCall EIP",
          "type" : "string"
        },
        "kubernetes-client" : {
          "description" : "Default KubernetesClient to use if provided",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "oauth-token" : {
          "description" : "The Auth Token",
          "type" : "string"
        },
        "operation" : {
          "description" : "Producer operation to do on Kubernetes",
          "type" : "string"
        },
        "password" : {
          "description" : "Password to connect to Kubernetes",
          "type" : "string"
        },
        "port-name" : {
          "description" : "The port name, used for ServiceCall EIP",
          "type" : "string"
        },
        "port-protocol" : {
          "description" : "The port protocol, used for ServiceCall EIP",
          "default" : "tcp",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "trust-certs" : {
          "description" : "Define if the certs we used are trusted anyway or not",
          "type" : "boolean"
        },
        "username" : {
          "description" : "Username to connect to Kubernetes",
          "type" : "string"
        }
      }
    },
    "openstack-cinder" : {
      "type" : "object",
      "required" : [ "host", "password", "project", "subsystem", "username" ],
      "properties" : {
        "host" : {
          "description" : "OpenStack host url",
          "type" : "string"
        },
        "api-version" : {
          "description" : "OpenStack API version",
          "default" : "V3",
          "enum" : [ "V2", "V3" ],
          "type" : "string"
        },
        "config" : {
          "description" : "OpenStack configuration",
          "type" : "string"
        },
        "domain" : {
          "description" : "Authentication domain",
          "default" : "default",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "operation" : {
          "description" : "The operation to do",
          "type" : "string"
        },
        "password" : {
          "description" : "OpenStack password",
          "type" : "string"
        },
        "project" : {
          "description" : "The project ID",
          "type" : "string"
        },
        "subsystem" : {
          "description" : "OpenStack Cinder subsystem",
          "enum" : [ "snapshots", "volumes" ],
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "username" : {
          "description" : "OpenStack username",
          "type" : "string"
        }
      }
    },
    "openstack-glance" : {
      "type" : "object",
      "required" : [ "host", "password", "project", "username" ],
      "properties" : {
        "host" : {
          "description" : "OpenStack host url",
          "type" : "string"
        },
        "api-version" : {
          "description" : "OpenStack API version",
          "default" : "V3",
          "enum" : [ "V2", "V3" ],
          "type" : "string"
        },
        "config" : {
          "description" : "OpenStack configuration",
          "type" : "string"
        },
        "domain" : {
          "description" : "Authentication domain",
          "default" : "default",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "operation" : {
          "description" : "The operation to do",
          "type" : "string"
        },
        "password" : {
          "description" : "OpenStack password",
          "type" : "string"
        },
        "project" : {
          "description" : "The project ID",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "username" : {
          "description" : "OpenStack username",
          "type" : "string"
        }
      }
    },
    "openstack-keystone" : {
      "type" : "object",
      "required" : [ "host", "password", "project", "subsystem", "username" ],
      "properties" : {
        "host" : {
          "description" : "OpenStack host url",
          "type" : "string"
        },
        "config" : {
          "description" : "OpenStack configuration",
          "type" : "string"
        },
        "domain" : {
          "description" : "Authentication domain",
          "default" : "default",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "operation" : {
          "description" : "The operation to do",
          "type" : "string"
        },
        "password" : {
          "description" : "OpenStack password",
          "type" : "string"
        },
        "project" : {
          "description" : "The project ID",
          "type" : "string"
        },
        "subsystem" : {
          "description" : "OpenStack Keystone subsystem",
          "enum" : [ "regions", "domains", "projects", "users", "groups" ],
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "username" : {
          "description" : "OpenStack username",
          "type" : "string"
        }
      }
    },
    "openstack-neutron" : {
      "type" : "object",
      "required" : [ "host", "password", "project", "subsystem", "username" ],
      "properties" : {
        "host" : {
          "description" : "OpenStack host url",
          "type" : "string"
        },
        "api-version" : {
          "description" : "OpenStack API version",
          "default" : "V3",
          "enum" : [ "V2", "V3" ],
          "type" : "string"
        },
        "config" : {
          "description" : "OpenStack configuration",
          "type" : "string"
        },
        "domain" : {
          "description" : "Authentication domain",
          "default" : "default",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "operation" : {
          "description" : "The operation to do",
          "type" : "string"
        },
        "password" : {
          "description" : "OpenStack password",
          "type" : "string"
        },
        "project" : {
          "description" : "The project ID",
          "type" : "string"
        },
        "subsystem" : {
          "description" : "OpenStack Neutron subsystem",
          "enum" : [ "networks", "subnets", "ports", "routers" ],
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "username" : {
          "description" : "OpenStack username",
          "type" : "string"
        }
      }
    },
    "openstack-nova" : {
      "type" : "object",
      "required" : [ "host", "password", "project", "subsystem", "username" ],
      "properties" : {
        "host" : {
          "description" : "OpenStack host url",
          "type" : "string"
        },
        "api-version" : {
          "description" : "OpenStack API version",
          "default" : "V3",
          "enum" : [ "V2", "V3" ],
          "type" : "string"
        },
        "config" : {
          "description" : "OpenStack configuration",
          "type" : "string"
        },
        "domain" : {
          "description" : "Authentication domain",
          "default" : "default",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "operation" : {
          "description" : "The operation to do",
          "type" : "string"
        },
        "password" : {
          "description" : "OpenStack password",
          "type" : "string"
        },
        "project" : {
          "description" : "The project ID",
          "type" : "string"
        },
        "subsystem" : {
          "description" : "OpenStack Nova subsystem",
          "enum" : [ "flavors", "servers", "keypairs" ],
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "username" : {
          "description" : "OpenStack username",
          "type" : "string"
        }
      }
    },
    "openstack-swift" : {
      "type" : "object",
      "required" : [ "host", "password", "project", "subsystem", "username" ],
      "properties" : {
        "host" : {
          "description" : "OpenStack host url",
          "type" : "string"
        },
        "api-version" : {
          "description" : "OpenStack API version",
          "default" : "V3",
          "enum" : [ "V2", "V3" ],
          "type" : "string"
        },
        "config" : {
          "description" : "OpenStack configuration",
          "type" : "string"
        },
        "domain" : {
          "description" : "Authentication domain",
          "default" : "default",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "operation" : {
          "description" : "The operation to do",
          "type" : "string"
        },
        "password" : {
          "description" : "OpenStack password",
          "type" : "string"
        },
        "project" : {
          "description" : "The project ID",
          "type" : "string"
        },
        "subsystem" : {
          "description" : "OpenStack Swift subsystem",
          "enum" : [ "objects", "containers" ],
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "username" : {
          "description" : "OpenStack username",
          "type" : "string"
        }
      }
    },
    "optaplanner" : {
      "type" : "object",
      "required" : [ "configFile" ],
      "properties" : {
        "config-file" : {
          "description" : "Specifies the location to the solver file. If useSolverManager=FALSE, Camel uses this file and create the Solver. If useSolverManager=TRUE and SolverManager is set in the header {OptaPlannerConstants.SOLVER_MANAGER} : this file is ignored by Camel usage of SolverManager. SolverManager can be injected by DI in Quarkus or Spring.",
          "type" : "string"
        },
        "async" : {
          "description" : "Specifies to perform operations in async mode",
          "default" : "false",
          "type" : "boolean"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "problem-id" : {
          "description" : "In case of using SolverManager : the problem id",
          "default" : "1L",
          "type" : "integer"
        },
        "solver-id" : {
          "description" : "Specifies the solverId to user for the solver instance key",
          "default" : "DEFAULT_SOLVER",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "thread-pool-size" : {
          "description" : "Specifies the thread pool size to use when async is true",
          "default" : "10",
          "type" : "integer"
        },
        "use-solver-manager" : {
          "description" : "use SolverManager instead of XML file config. Use this mode on Quarkus app.",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "paho" : {
      "type" : "object",
      "required" : [ "topic" ],
      "properties" : {
        "topic" : {
          "description" : "Name of the topic",
          "type" : "string"
        },
        "automatic-reconnect" : {
          "description" : "Sets whether the client will automatically attempt to reconnect to the server if the connection is lost. If set to false, the client will not attempt to automatically reconnect to the server in the event that the connection is lost. If set to true, in the event that the connection is lost, the client will attempt to reconnect to the server. It will initially wait 1 second before it attempts to reconnect, for every failed reconnect attempt, the delay will double until it is at 2 minutes at which point the delay will stay at 2 minutes.",
          "default" : "true",
          "type" : "boolean"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "broker-url" : {
          "description" : "The URL of the MQTT broker.",
          "default" : "tcp://localhost:1883",
          "type" : "string"
        },
        "clean-session" : {
          "description" : "Sets whether the client and server should remember state across restarts and reconnects. If set to false both the client and server will maintain state across restarts of the client, the server and the connection. As state is maintained: Message delivery will be reliable meeting the specified QOS even if the client, server or connection are restarted. The server will treat a subscription as durable. If set to true the client and server will not maintain state across restarts of the client, the server or the connection. This means Message delivery to the specified QOS cannot be maintained if the client, server or connection are restarted The server will treat a subscription as non-durable",
          "default" : "true",
          "type" : "boolean"
        },
        "client" : {
          "description" : "To use an existing mqtt client",
          "type" : "string"
        },
        "client-id" : {
          "description" : "MQTT client identifier. The identifier must be unique.",
          "type" : "string"
        },
        "connection-timeout" : {
          "description" : "Sets the connection timeout value. This value, measured in seconds, defines the maximum time interval the client will wait for the network connection to the MQTT server to be established. The default timeout is 30 seconds. A value of 0 disables timeout processing meaning the client will wait until the network connection is made successfully or fails.",
          "default" : "30",
          "type" : "integer"
        },
        "custom-web-socket-headers" : {
          "description" : "Sets the Custom WebSocket Headers for the WebSocket Connection.",
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "executor-service-timeout" : {
          "description" : "Set the time in seconds that the executor service should wait when terminating before forcefully terminating. It is not recommended to change this value unless you are absolutely sure that you need to.",
          "default" : "1",
          "type" : "integer"
        },
        "file-persistence-directory" : {
          "description" : "Base directory used by file persistence. Will by default use user directory.",
          "type" : "string"
        },
        "https-hostname-verification-enabled" : {
          "description" : "Whether SSL HostnameVerifier is enabled or not. The default value is true.",
          "default" : "true",
          "type" : "boolean"
        },
        "keep-alive-interval" : {
          "description" : "Sets the keep alive interval. This value, measured in seconds, defines the maximum time interval between messages sent or received. It enables the client to detect if the server is no longer available, without having to wait for the TCP/IP timeout. The client will ensure that at least one message travels across the network within each keep alive period. In the absence of a data-related message during the time period, the client sends a very small ping message, which the server will acknowledge. A value of 0 disables keepalive processing in the client. The default value is 60 seconds",
          "default" : "60",
          "type" : "integer"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "max-inflight" : {
          "description" : "Sets the max inflight. please increase this value in a high traffic environment. The default value is 10",
          "default" : "10",
          "type" : "integer"
        },
        "max-reconnect-delay" : {
          "description" : "Get the maximum time (in millis) to wait between reconnects",
          "default" : "128000",
          "type" : "integer"
        },
        "mqtt-version" : {
          "description" : "Sets the MQTT version. The default action is to connect with version 3.1.1, and to fall back to 3.1 if that fails. Version 3.1.1 or 3.1 can be selected specifically, with no fall back, by using the MQTT_VERSION_3_1_1 or MQTT_VERSION_3_1 options respectively.",
          "type" : "integer"
        },
        "password" : {
          "description" : "Password to be used for authentication against the MQTT broker",
          "type" : "string"
        },
        "persistence" : {
          "description" : "Client persistence to be used - memory or file.",
          "default" : "MEMORY",
          "enum" : [ "FILE", "MEMORY" ],
          "type" : "string"
        },
        "qos" : {
          "description" : "Client quality of service level (0-2).",
          "default" : "2",
          "type" : "integer"
        },
        "retained" : {
          "description" : "Retain option",
          "default" : "false",
          "type" : "boolean"
        },
        "server-ur-is" : {
          "description" : "Set a list of one or more serverURIs the client may connect to. Multiple servers can be separated by comma. Each serverURI specifies the address of a server that the client may connect to. Two types of connection are supported tcp:// for a TCP connection and ssl:// for a TCP connection secured by SSL/TLS. For example: tcp://localhost:1883 ssl://localhost:8883 If the port is not specified, it will default to 1883 for tcp:// URIs, and 8883 for ssl:// URIs. If serverURIs is set then it overrides the serverURI parameter passed in on the constructor of the MQTT client. When an attempt to connect is initiated the client will start with the first serverURI in the list and work through the list until a connection is established with a server. If a connection cannot be made to any of the servers then the connect attempt fails. Specifying a list of servers that a client may connect to has several uses: High Availability and reliable message delivery Some MQTT servers support a high availability feature where two or more equal MQTT servers share state. An MQTT client can connect to any of the equal servers and be assured that messages are reliably delivered and durable subscriptions are maintained no matter which server the client connects to. The cleansession flag must be set to false if durable subscriptions and/or reliable message delivery is required. Hunt List A set of servers may be specified that are not equal (as in the high availability option). As no state is shared across the servers reliable message delivery and durable subscriptions are not valid. The cleansession flag must be set to true if the hunt list mode is used",
          "type" : "string"
        },
        "socket-factory" : {
          "description" : "Sets the SocketFactory to use. This allows an application to apply its own policies around the creation of network sockets. If using an SSL connection, an SSLSocketFactory can be used to supply application-specific security settings.",
          "type" : "string"
        },
        "ssl-client-props" : {
          "description" : "Sets the SSL properties for the connection. Note that these properties are only valid if an implementation of the Java Secure Socket Extensions (JSSE) is available. These properties are not used if a custom SocketFactory has been set. The following properties can be used: com.ibm.ssl.protocol One of: SSL, SSLv3, TLS, TLSv1, SSL_TLS. com.ibm.ssl.contextProvider Underlying JSSE provider. For example IBMJSSE2 or SunJSSE com.ibm.ssl.keyStore The name of the file that contains the KeyStore object that you want the KeyManager to use. For example /mydir/etc/key.p12 com.ibm.ssl.keyStorePassword The password for the KeyStore object that you want the KeyManager to use. The password can either be in plain-text, or may be obfuscated using the static method: com.ibm.micro.security.Password.obfuscate(char password). This obfuscates the password using a simple and insecure XOR and Base64 encoding mechanism. Note that this is only a simple scrambler to obfuscate clear-text passwords. com.ibm.ssl.keyStoreType Type of key store, for example PKCS12, JKS, or JCEKS. com.ibm.ssl.keyStoreProvider Key store provider, for example IBMJCE or IBMJCEFIPS. com.ibm.ssl.trustStore The name of the file that contains the KeyStore object that you want the TrustManager to use. com.ibm.ssl.trustStorePassword The password for the TrustStore object that you want the TrustManager to use. The password can either be in plain-text, or may be obfuscated using the static method: com.ibm.micro.security.Password.obfuscate(char password). This obfuscates the password using a simple and insecure XOR and Base64 encoding mechanism. Note that this is only a simple scrambler to obfuscate clear-text passwords. com.ibm.ssl.trustStoreType The type of KeyStore object that you want the default TrustManager to use. Same possible values as keyStoreType. com.ibm.ssl.trustStoreProvider Trust store provider, for example IBMJCE or IBMJCEFIPS. com.ibm.ssl.enabledCipherSuites A list of which ciphers are enabled. Values are dependent on the provider, for example: SSL_RSA_WITH_AES_128_CBC_SHA;SSL_RSA_WITH_3DES_EDE_CBC_SHA. com.ibm.ssl.keyManager Sets the algorithm that will be used to instantiate a KeyManagerFactory object instead of using the default algorithm available in the platform. Example values: IbmX509 or IBMJ9X509. com.ibm.ssl.trustManager Sets the algorithm that will be used to instantiate a TrustManagerFactory object instead of using the default algorithm available in the platform. Example values: PKIX or IBMJ9X509.",
          "type" : "string"
        },
        "ssl-hostname-verifier" : {
          "description" : "Sets the HostnameVerifier for the SSL connection. Note that it will be used after handshake on a connection and you should do actions by yourself when hostname is verified error. There is no default HostnameVerifier",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "user-name" : {
          "description" : "Username to be used for authentication against the MQTT broker",
          "type" : "string"
        },
        "will-payload" : {
          "description" : "Sets the Last Will and Testament (LWT) for the connection. In the event that this client unexpectedly loses its connection to the server, the server will publish a message to itself using the supplied details. The topic to publish to The byte payload for the message. The quality of service to publish the message at (0, 1 or 2). Whether or not the message should be retained.",
          "type" : "string"
        },
        "will-qos" : {
          "description" : "Sets the Last Will and Testament (LWT) for the connection. In the event that this client unexpectedly loses its connection to the server, the server will publish a message to itself using the supplied details. The topic to publish to The byte payload for the message. The quality of service to publish the message at (0, 1 or 2). Whether or not the message should be retained.",
          "type" : "integer"
        },
        "will-retained" : {
          "description" : "Sets the Last Will and Testament (LWT) for the connection. In the event that this client unexpectedly loses its connection to the server, the server will publish a message to itself using the supplied details. The topic to publish to The byte payload for the message. The quality of service to publish the message at (0, 1 or 2). Whether or not the message should be retained.",
          "default" : "false",
          "type" : "boolean"
        },
        "will-topic" : {
          "description" : "Sets the Last Will and Testament (LWT) for the connection. In the event that this client unexpectedly loses its connection to the server, the server will publish a message to itself using the supplied details. The topic to publish to The byte payload for the message. The quality of service to publish the message at (0, 1 or 2). Whether or not the message should be retained.",
          "type" : "string"
        }
      }
    },
    "pdf" : {
      "type" : "object",
      "required" : [ "operation" ],
      "properties" : {
        "operation" : {
          "description" : "Operation type",
          "enum" : [ "create", "append", "extractText" ],
          "type" : "string"
        },
        "font" : {
          "description" : "Font",
          "default" : "Helvetica",
          "enum" : [ "Courier", "Courier-Bold", "Courier-Oblique", "Courier-BoldOblique", "Helvetica", "Helvetica-Bold", "Helvetica-Oblique", "Helvetica-BoldOblique", "Times-Roman", "Times-Bold", "Times-Italic", "Times-BoldItalic", "Symbol", "ZapfDingbats" ],
          "type" : "string"
        },
        "font-size" : {
          "description" : "Font size in pixels",
          "default" : "14.0",
          "type" : "number"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "margin-bottom" : {
          "description" : "Margin bottom in pixels",
          "default" : "20",
          "type" : "integer"
        },
        "margin-left" : {
          "description" : "Margin left in pixels",
          "default" : "20",
          "type" : "integer"
        },
        "margin-right" : {
          "description" : "Margin right in pixels",
          "default" : "40",
          "type" : "integer"
        },
        "margin-top" : {
          "description" : "Margin top in pixels",
          "default" : "20",
          "type" : "integer"
        },
        "page-size" : {
          "description" : "Page size",
          "default" : "A4",
          "enum" : [ "LETTER", "LEGAL", "A0", "A1", "A2", "A3", "A4", "A5", "A6" ],
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "text-processing-factory" : {
          "description" : "Text processing to use. autoFormatting: Text is getting sliced by words, then max amount of words that fits in the line will be written into pdf document. With this strategy all words that doesn't fit in the line will be moved to the new line. lineTermination: Builds set of classes for line-termination writing strategy. Text getting sliced by line termination symbol and then it will be written regardless it fits in the line or not.",
          "default" : "lineTermination",
          "enum" : [ "autoFormatting", "lineTermination" ],
          "type" : "string"
        }
      }
    },
    "pg-replication-slot" : {
      "type" : "object",
      "required" : [ "database", "outputPlugin", "slot" ],
      "properties" : {
        "database" : {
          "description" : "Postgres database name",
          "type" : "string"
        },
        "host" : {
          "description" : "Postgres host",
          "default" : "localhost",
          "type" : "string"
        },
        "output-plugin" : {
          "description" : "Output plugin name",
          "type" : "string"
        },
        "port" : {
          "description" : "Postgres port",
          "default" : "5432",
          "type" : "integer"
        },
        "slot" : {
          "description" : "Replication Slot name",
          "type" : "string"
        },
        "auto-create-slot" : {
          "description" : "Auto create slot if it does not exist",
          "default" : "true",
          "type" : "boolean"
        },
        "backoff-error-threshold" : {
          "description" : "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-idle-threshold" : {
          "description" : "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-multiplier" : {
          "description" : "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
          "type" : "integer"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "delay" : {
          "description" : "Milliseconds before the next poll.",
          "default" : "500",
          "type" : "integer"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "greedy" : {
          "description" : "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
          "default" : "false",
          "type" : "boolean"
        },
        "initial-delay" : {
          "description" : "Milliseconds before the first poll starts.",
          "default" : "1000",
          "type" : "integer"
        },
        "password" : {
          "description" : "Postgres password",
          "type" : "string"
        },
        "poll-strategy" : {
          "description" : "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
          "type" : "string"
        },
        "repeat-count" : {
          "description" : "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
          "default" : "0",
          "type" : "integer"
        },
        "run-logging-level" : {
          "description" : "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
          "default" : "TRACE",
          "enum" : [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ],
          "type" : "string"
        },
        "scheduled-executor-service" : {
          "description" : "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
          "type" : "string"
        },
        "scheduler" : {
          "description" : "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
          "default" : "none",
          "type" : "string"
        },
        "scheduler-properties" : {
          "description" : "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
          "type" : "string"
        },
        "send-empty-message-when-idle" : {
          "description" : "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
          "default" : "false",
          "type" : "boolean"
        },
        "slot-options" : {
          "description" : "Slot options to be passed to the output plugin.",
          "type" : "string"
        },
        "start-scheduler" : {
          "description" : "Whether the scheduler should be auto started.",
          "default" : "true",
          "type" : "boolean"
        },
        "status-interval" : {
          "description" : "Specifies the number of seconds between status packets sent back to Postgres server.",
          "default" : "10",
          "type" : "integer"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "time-unit" : {
          "description" : "Time unit for initialDelay and delay options.",
          "default" : "MILLISECONDS",
          "enum" : [ "NANOSECONDS", "MICROSECONDS", "MILLISECONDS", "SECONDS", "MINUTES", "HOURS", "DAYS" ],
          "type" : "string"
        },
        "use-fixed-delay" : {
          "description" : "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
          "default" : "true",
          "type" : "boolean"
        },
        "user" : {
          "description" : "Postgres user",
          "default" : "postgres",
          "type" : "string"
        }
      }
    },
    "pgevent" : {
      "type" : "object",
      "required" : [ "channel", "database" ],
      "properties" : {
        "channel" : {
          "description" : "The channel name",
          "type" : "string"
        },
        "database" : {
          "description" : "The database name. The database name can take any characters because it is sent as a quoted identifier. It is part of the endpoint URI, so diacritical marks and non-Latin letters have to be URL encoded.",
          "type" : "string"
        },
        "host" : {
          "description" : "To connect using hostname and port to the database.",
          "default" : "localhost",
          "type" : "string"
        },
        "port" : {
          "description" : "To connect using hostname and port to the database.",
          "default" : "5432",
          "type" : "integer"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "datasource" : {
          "description" : "To connect using the given javax.sql.DataSource instead of using hostname and port.",
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "pass" : {
          "description" : "Password for login",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "user" : {
          "description" : "Username for login",
          "default" : "postgres",
          "type" : "string"
        }
      }
    },
    "platform-http" : {
      "type" : "object",
      "required" : [ "path" ],
      "properties" : {
        "path" : {
          "description" : "The path under which this endpoint serves the HTTP requests",
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "consumes" : {
          "description" : "The content type this endpoint accepts as an input, such as application/xml or application/json. null or &#42;/&#42; mean no restriction.",
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "file-name-ext-whitelist" : {
          "description" : "A comma or whitespace separated list of file extensions. Uploads having these extensions will be stored locally. Null value or asterisk () will allow all files.",
          "type" : "string"
        },
        "header-filter-strategy" : {
          "description" : "To use a custom HeaderFilterStrategy to filter headers to and from Camel message.",
          "type" : "string"
        },
        "http-method-restrict" : {
          "description" : "A comma separated list of HTTP methods to serve, e.g. GET,POST . If no methods are specified, all methods will be served.",
          "type" : "string"
        },
        "match-on-uri-prefix" : {
          "description" : "Whether or not the consumer should try to find a target consumer by matching the URI prefix if no exact match is found.",
          "default" : "false",
          "type" : "boolean"
        },
        "platform-http-engine" : {
          "description" : "An HTTP Server engine implementation to serve the requests of this endpoint.",
          "type" : "string"
        },
        "produces" : {
          "description" : "The content type this endpoint produces, such as application/xml or application/json.",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "pubnub" : {
      "type" : "object",
      "required" : [ "channel" ],
      "properties" : {
        "channel" : {
          "description" : "The channel used for subscribing/publishing events",
          "type" : "string"
        },
        "auth-key" : {
          "description" : "If Access Manager is utilized, client will use this authKey in all restricted requests.",
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "cipher-key" : {
          "description" : "If cipher is passed, all communications to/from PubNub will be encrypted.",
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "operation" : {
          "description" : "The operation to perform. PUBLISH: Default. Send a message to all subscribers of a channel. FIRE: allows the client to send a message to BLOCKS Event Handlers. These messages will go directly to any Event Handlers registered on the channel. HERENOW: Obtain information about the current state of a channel including a list of unique user-ids currently subscribed to the channel and the total occupancy count. WHERENOW: Obtain information about the current list of channels to which a uuid is subscribed to. GETSTATE: Used to get key/value pairs specific to a subscriber uuid. State information is supplied as a JSON object of key/value pairs SETSTATE: Used to set key/value pairs specific to a subscriber uuid GETHISTORY: Fetches historical messages of a channel.",
          "enum" : [ "HERENOW", "WHERENOW", "GETSTATE", "SETSTATE", "GETHISTORY", "PUBLISH", "FIRE" ],
          "type" : "string"
        },
        "publish-key" : {
          "description" : "The publish key obtained from your PubNub account. Required when publishing messages.",
          "type" : "string"
        },
        "pubnub" : {
          "description" : "Reference to a Pubnub client in the registry.",
          "type" : "string"
        },
        "secret-key" : {
          "description" : "The secret key used for message signing.",
          "type" : "string"
        },
        "secure" : {
          "description" : "Use SSL for secure transmission.",
          "default" : "true",
          "type" : "boolean"
        },
        "subscribe-key" : {
          "description" : "The subscribe key obtained from your PubNub account. Required when subscribing to channels or listening for presence events",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "uuid" : {
          "description" : "UUID to be used as a device identifier, a default UUID is generated if not passed.",
          "type" : "string"
        },
        "with-presence" : {
          "description" : "Also subscribe to related presence information",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "pulsar" : {
      "type" : "object",
      "required" : [ "namespace", "persistence", "tenant", "topic" ],
      "properties" : {
        "namespace" : {
          "description" : "The namespace",
          "type" : "string"
        },
        "persistence" : {
          "description" : "Whether the topic is persistent or non-persistent",
          "enum" : [ "persistent", "non-persistent" ],
          "type" : "string"
        },
        "tenant" : {
          "description" : "The tenant",
          "type" : "string"
        },
        "topic" : {
          "description" : "The topic",
          "type" : "string"
        },
        "ack-group-time-millis" : {
          "description" : "Group the consumer acknowledgments for the specified time in milliseconds - defaults to 100",
          "default" : "100",
          "type" : "integer"
        },
        "ack-timeout-millis" : {
          "description" : "Timeout for unacknowledged messages in milliseconds - defaults to 10000",
          "default" : "10000",
          "type" : "integer"
        },
        "allow-manual-acknowledgement" : {
          "description" : "Whether to allow manual message acknowledgements. If this option is enabled, then messages are not acknowledged automatically after successful route completion. Instead, an instance of PulsarMessageReceipt is stored as a header on the org.apache.camel.Exchange. Messages can then be acknowledged using PulsarMessageReceipt at any time before the ackTimeout occurs.",
          "default" : "false",
          "type" : "boolean"
        },
        "batcher-builder" : {
          "description" : "Control batching method used by the producer.",
          "default" : "DEFAULT",
          "type" : "string"
        },
        "batching-enabled" : {
          "description" : "Control whether automatic batching of messages is enabled for the producer.",
          "default" : "true",
          "type" : "boolean"
        },
        "batching-max-messages" : {
          "description" : "The maximum size to batch messages.",
          "default" : "1000",
          "type" : "integer"
        },
        "batching-max-publish-delay-micros" : {
          "description" : "The maximum time period within which the messages sent will be batched if batchingEnabled is true.",
          "default" : "1000",
          "type" : "integer"
        },
        "block-if-queue-full" : {
          "description" : "Whether to block the producing thread if pending messages queue is full or to throw a ProducerQueueIsFullError",
          "default" : "false",
          "type" : "boolean"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "compression-type" : {
          "description" : "Compression type to use",
          "default" : "NONE",
          "enum" : [ "NONE", "LZ4", "ZLIB", "ZSTD", "SNAPPY" ],
          "type" : "string"
        },
        "consumer-name" : {
          "description" : "Name of the consumer when subscription is EXCLUSIVE",
          "default" : "sole-consumer",
          "type" : "string"
        },
        "consumer-name-prefix" : {
          "description" : "Prefix to add to consumer names when a SHARED or FAILOVER subscription is used",
          "default" : "cons",
          "type" : "string"
        },
        "consumer-queue-size" : {
          "description" : "Size of the consumer queue - defaults to 10",
          "default" : "10",
          "type" : "integer"
        },
        "dead-letter-topic" : {
          "description" : "Name of the topic where the messages which fail maxRedeliverCount times will be sent. Note: if not set, default topic name will be topicName-subscriptionName-DLQ",
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "initial-sequence-id" : {
          "description" : "The first message published will have a sequence Id of initialSequenceId 1.",
          "default" : "-1",
          "type" : "integer"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "max-pending-messages" : {
          "description" : "Size of the pending massages queue. When the queue is full, by default, any further sends will fail unless blockIfQueueFull=true",
          "default" : "1000",
          "type" : "integer"
        },
        "max-pending-messages-across-partitions" : {
          "description" : "The maximum number of pending messages for partitioned topics. The maxPendingMessages value will be reduced if (number of partitions maxPendingMessages) exceeds this value. Partitioned topics have a pending message queue for each partition.",
          "default" : "50000",
          "type" : "integer"
        },
        "max-redeliver-count" : {
          "description" : "Maximum number of times that a message will be redelivered before being sent to the dead letter queue. If this value is not set, no Dead Letter Policy will be created",
          "type" : "integer"
        },
        "message-router" : {
          "description" : "Custom Message Router to use",
          "type" : "string"
        },
        "message-routing-mode" : {
          "description" : "Message Routing Mode to use",
          "default" : "RoundRobinPartition",
          "enum" : [ "SinglePartition", "RoundRobinPartition", "CustomPartition" ],
          "type" : "string"
        },
        "negative-ack-redelivery-delay-micros" : {
          "description" : "Set the negative acknowledgement delay",
          "default" : "60000000",
          "type" : "integer"
        },
        "number-of-consumers" : {
          "description" : "Number of consumers - defaults to 1",
          "default" : "1",
          "type" : "integer"
        },
        "producer-name" : {
          "description" : "Name of the producer. If unset, lets Pulsar select a unique identifier.",
          "type" : "string"
        },
        "read-compacted" : {
          "description" : "Enable compacted topic reading.",
          "default" : "false",
          "type" : "boolean"
        },
        "send-timeout-ms" : {
          "description" : "Send timeout in milliseconds",
          "default" : "30000",
          "type" : "integer"
        },
        "subscription-initial-position" : {
          "description" : "Control the initial position in the topic of a newly created subscription. Default is latest message.",
          "default" : "LATEST",
          "enum" : [ "EARLIEST", "LATEST" ],
          "type" : "string"
        },
        "subscription-name" : {
          "description" : "Name of the subscription to use",
          "default" : "subs",
          "type" : "string"
        },
        "subscription-topics-mode" : {
          "description" : "Determines to which topics this consumer should be subscribed to - Persistent, Non-Persistent, or both. Only used with pattern subscriptions.",
          "default" : "PersistentOnly",
          "enum" : [ "PersistentOnly", "NonPersistentOnly", "AllTopics" ],
          "type" : "string"
        },
        "subscription-type" : {
          "description" : "Type of the subscription EXCLUSIVESHAREDFAILOVERKEY_SHARED, defaults to EXCLUSIVE",
          "default" : "EXCLUSIVE",
          "enum" : [ "EXCLUSIVE", "SHARED", "FAILOVER", "KEY_SHARED" ],
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "true",
          "type" : "boolean"
        },
        "topics-pattern" : {
          "description" : "Whether the topic is a pattern (regular expression) that allows the consumer to subscribe to all matching topics in the namespace",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "quartz" : {
      "type" : "object",
      "properties" : {
        "group-name" : {
          "description" : "The quartz group name to use. The combination of group name and trigger name should be unique.",
          "default" : "Camel",
          "type" : "string"
        },
        "trigger-name" : {
          "description" : "The quartz trigger name to use. The combination of group name and trigger name should be unique.",
          "type" : "string"
        },
        "auto-start-scheduler" : {
          "description" : "Whether or not the scheduler should be auto started.",
          "default" : "true",
          "type" : "boolean"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "cron" : {
          "description" : "Specifies a cron expression to define when to trigger.",
          "type" : "string"
        },
        "custom-calendar" : {
          "description" : "Specifies a custom calendar to avoid specific range of date",
          "type" : "string"
        },
        "delete-job" : {
          "description" : "If set to true, then the trigger automatically delete when route stop. Else if set to false, it will remain in scheduler. When set to false, it will also mean user may reuse pre-configured trigger with camel Uri. Just ensure the names match. Notice you cannot have both deleteJob and pauseJob set to true.",
          "default" : "true",
          "type" : "boolean"
        },
        "durable-job" : {
          "description" : "Whether or not the job should remain stored after it is orphaned (no triggers point to it).",
          "default" : "false",
          "type" : "boolean"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "fire-now" : {
          "description" : "If it is true will fire the trigger when the route is start when using SimpleTrigger.",
          "default" : "false",
          "type" : "boolean"
        },
        "job-parameters" : {
          "description" : "To configure additional options on the job.",
          "type" : "string"
        },
        "pause-job" : {
          "description" : "If set to true, then the trigger automatically pauses when route stop. Else if set to false, it will remain in scheduler. When set to false, it will also mean user may reuse pre-configured trigger with camel Uri. Just ensure the names match. Notice you cannot have both deleteJob and pauseJob set to true.",
          "default" : "false",
          "type" : "boolean"
        },
        "prefix-job-name-with-endpoint-id" : {
          "description" : "Whether the job name should be prefixed with endpoint id",
          "default" : "false",
          "type" : "boolean"
        },
        "recoverable-job" : {
          "description" : "Instructs the scheduler whether or not the job should be re-executed if a 'recovery' or 'fail-over' situation is encountered.",
          "default" : "false",
          "type" : "boolean"
        },
        "start-delayed-seconds" : {
          "description" : "Seconds to wait before starting the quartz scheduler.",
          "type" : "integer"
        },
        "stateful" : {
          "description" : "Uses a Quartz PersistJobDataAfterExecution and DisallowConcurrentExecution instead of the default job.",
          "default" : "false",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "trigger-parameters" : {
          "description" : "To configure additional options on the trigger.",
          "type" : "string"
        },
        "trigger-start-delay" : {
          "description" : "In case of scheduler has already started, we want the trigger start slightly after current time to ensure endpoint is fully started before the job kicks in.",
          "default" : "500",
          "type" : "string"
        },
        "using-fixed-camel-context-name" : {
          "description" : "If it is true, JobDataMap uses the CamelContext name directly to reference the CamelContext, if it is false, JobDataMap uses use the CamelContext management name which could be changed during the deploy time.",
          "default" : "false",
          "type" : "boolean"
        }
      },
      "required" : [ "triggerName" ]
    },
    "quickfix" : {
      "type" : "object",
      "required" : [ "configurationName" ],
      "properties" : {
        "configuration-name" : {
          "description" : "Path to the quickfix configuration file. You can prefix with: classpath, file, http, ref, or bean. classpath, file and http loads the configuration file using these protocols (classpath is default). ref will lookup the configuration file in the registry. bean will call a method on a bean to be used as the configuration. For bean you can specify the method name after dot, eg bean:myBean.myMethod",
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "lazy-create-engine" : {
          "description" : "This option allows to create QuickFIX/J engine on demand. Value true means the engine is started when first message is send or there's consumer configured in route definition. When false value is used, the engine is started at the endpoint creation. When this parameter is missing, the value of component's property lazyCreateEngines is being used.",
          "default" : "false",
          "type" : "boolean"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "session-id" : {
          "description" : "The optional sessionID identifies a specific FIX session. The format of the sessionID is: (BeginString):(SenderCompID)/(SenderSubID)/(SenderLocationID)-(TargetCompID)/(TargetSubID)/(TargetLocationID)",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "rabbitmq" : {
      "type" : "object",
      "required" : [ "exchangeName" ],
      "properties" : {
        "exchange-name" : {
          "description" : "The exchange name determines the exchange to which the produced messages will be sent to. In the case of consumers, the exchange name determines the exchange the queue will be bound to.",
          "type" : "string"
        },
        "additional-headers" : {
          "description" : "Map of additional headers. These headers will be set only when the 'allowCustomHeaders' is set to true",
          "type" : "string"
        },
        "additional-properties" : {
          "description" : "Map of additional properties. These are standard RabbitMQ properties as defined in com.rabbitmq.client.AMQP.BasicProperties. The map keys should be from org.apache.camel.component.rabbitmq.RabbitMQConstants. Any other keys will be ignored.",
          "type" : "string"
        },
        "addresses" : {
          "description" : "If this option is set, camel-rabbitmq will try to create connection based on the setting of option addresses. The addresses value is a string which looks like server1:12345, server2:12345",
          "type" : "string"
        },
        "allow-custom-headers" : {
          "description" : "Allow pass custom values to header",
          "default" : "false",
          "type" : "boolean"
        },
        "allow-message-body-serialization" : {
          "description" : "Whether to allow Java serialization of the message body or not. If this value is true, the message body will be serialized on the producer side using Java serialization, if no type converter can handle the message body. On the consumer side, it will deserialize the message body if this value is true and the message contains a CamelSerialize header. Setting this value to true may introduce a security vulnerability as it allows an attacker to attempt to deserialize to a gadget object which could result in a RCE or other security vulnerability.",
          "default" : "false",
          "type" : "boolean"
        },
        "allow-null-headers" : {
          "description" : "Allow pass null values to header",
          "default" : "false",
          "type" : "boolean"
        },
        "args" : {
          "description" : "Specify arguments for configuring the different RabbitMQ concepts, a different prefix is required for each: Exchange: arg.exchange. Queue: arg.queue. Binding: arg.binding. DLQ: arg.dlq.queue. DLQ binding: arg.dlq.binding. For example to declare a queue with message ttl argument: http://localhost:5672/exchange/queueargs=arg.queue.x-message-ttl=60000",
          "type" : "string"
        },
        "auto-ack" : {
          "description" : "If messages should be auto acknowledged",
          "default" : "true",
          "type" : "boolean"
        },
        "auto-delete" : {
          "description" : "If it is true, the exchange will be deleted when it is no longer in use",
          "default" : "true",
          "type" : "boolean"
        },
        "automatic-recovery-enabled" : {
          "description" : "Enables connection automatic recovery (uses connection implementation that performs automatic recovery when existing connection has failures)",
          "default" : "true",
          "type" : "boolean"
        },
        "bridge-endpoint" : {
          "description" : "If the bridgeEndpoint is true, the producer will ignore the message header of rabbitmq.EXCHANGE_NAME and rabbitmq.ROUTING_KEY",
          "default" : "false",
          "type" : "boolean"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "channel-pool-max-size" : {
          "description" : "Get maximum number of opened channel in pool",
          "default" : "10",
          "type" : "integer"
        },
        "channel-pool-max-wait" : {
          "description" : "Set the maximum number of milliseconds to wait for a channel from the pool",
          "default" : "1000",
          "type" : "integer"
        },
        "client-properties" : {
          "description" : "Connection client properties (client info used in negotiating with the server)",
          "type" : "string"
        },
        "concurrent-consumers" : {
          "description" : "Number of concurrent consumers when consuming from broker. (eg similar as to the same option for the JMS component).",
          "default" : "1",
          "type" : "integer"
        },
        "connection-factory" : {
          "description" : "To use a custom RabbitMQ connection factory. When this option is set, all connection options (connectionTimeout, requestedChannelMax...) set on URI are not used",
          "type" : "string"
        },
        "connection-factory-exception-handler" : {
          "description" : "Custom rabbitmq ExceptionHandler for ConnectionFactory",
          "type" : "string"
        },
        "connection-timeout" : {
          "description" : "Connection timeout",
          "default" : "60000",
          "type" : "integer"
        },
        "consumer-tag" : {
          "description" : "Specify a client-generated consumer tag to establish context when invoking the consume operation",
          "type" : "string"
        },
        "dead-letter-exchange" : {
          "description" : "The name of the dead letter exchange",
          "type" : "string"
        },
        "dead-letter-exchange-type" : {
          "description" : "The type of the dead letter exchange",
          "default" : "direct",
          "enum" : [ "direct", "fanout", "headers", "topic" ],
          "type" : "string"
        },
        "dead-letter-queue" : {
          "description" : "The name of the dead letter queue",
          "type" : "string"
        },
        "dead-letter-routing-key" : {
          "description" : "The routing key for the dead letter exchange",
          "type" : "string"
        },
        "declare" : {
          "description" : "If the option is true, camel declare the exchange and queue name and bind them together. If the option is false, camel won't declare the exchange and queue name on the server.",
          "default" : "true",
          "type" : "boolean"
        },
        "durable" : {
          "description" : "If we are declaring a durable exchange (the exchange will survive a server restart)",
          "default" : "true",
          "type" : "boolean"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "exchange-type" : {
          "description" : "The exchange type such as direct or topic.",
          "default" : "direct",
          "enum" : [ "direct", "fanout", "headers", "topic" ],
          "type" : "string"
        },
        "exclusive" : {
          "description" : "Exclusive queues may only be accessed by the current connection, and are deleted when that connection closes.",
          "default" : "false",
          "type" : "boolean"
        },
        "exclusive-consumer" : {
          "description" : "Request exclusive access to the queue (meaning only this consumer can access the queue). This is useful when you want a long-lived shared queue to be temporarily accessible by just one consumer.",
          "default" : "false",
          "type" : "boolean"
        },
        "guaranteed-deliveries" : {
          "description" : "When true, an exception will be thrown when the message cannot be delivered (basic.return) and the message is marked as mandatory. PublisherAcknowledgement will also be activated in this case. See also publisher acknowledgements - When will messages be confirmed.",
          "default" : "false",
          "type" : "boolean"
        },
        "hostname" : {
          "description" : "The hostname of the running rabbitmq instance or cluster.",
          "type" : "string"
        },
        "immediate" : {
          "description" : "This flag tells the server how to react if the message cannot be routed to a queue consumer immediately. If this flag is set, the server will return an undeliverable message with a Return method. If this flag is zero, the server will queue the message, but with no guarantee that it will ever be consumed. If the header is present rabbitmq.IMMEDIATE it will override this option.",
          "default" : "false",
          "type" : "boolean"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "mandatory" : {
          "description" : "This flag tells the server how to react if the message cannot be routed to a queue. If this flag is set, the server will return an unroutable message with a Return method. If this flag is zero, the server silently drops the message. If the header is present rabbitmq.MANDATORY it will override this option.",
          "default" : "false",
          "type" : "boolean"
        },
        "network-recovery-interval" : {
          "description" : "Network recovery interval in milliseconds (interval used when recovering from network failure)",
          "default" : "5000",
          "type" : "integer"
        },
        "passive" : {
          "description" : "Passive queues depend on the queue already to be available at RabbitMQ.",
          "default" : "false",
          "type" : "boolean"
        },
        "password" : {
          "description" : "Password for authenticated access",
          "default" : "guest",
          "type" : "string"
        },
        "port-number" : {
          "description" : "Port number for the host with the running rabbitmq instance or cluster. Default value is 5672.",
          "type" : "integer"
        },
        "prefetch-count" : {
          "description" : "The maximum number of messages that the server will deliver, 0 if unlimited. You need to specify the option of prefetchSize, prefetchCount, prefetchGlobal at the same time",
          "type" : "integer"
        },
        "prefetch-enabled" : {
          "description" : "Enables the quality of service on the RabbitMQConsumer side. You need to specify the option of prefetchSize, prefetchCount, prefetchGlobal at the same time",
          "default" : "false",
          "type" : "boolean"
        },
        "prefetch-global" : {
          "description" : "If the settings should be applied to the entire channel rather than each consumer You need to specify the option of prefetchSize, prefetchCount, prefetchGlobal at the same time",
          "default" : "false",
          "type" : "boolean"
        },
        "prefetch-size" : {
          "description" : "The maximum amount of content (measured in octets) that the server will deliver, 0 if unlimited. You need to specify the option of prefetchSize, prefetchCount, prefetchGlobal at the same time",
          "type" : "integer"
        },
        "publisher-acknowledgements" : {
          "description" : "When true, the message will be published with publisher acknowledgements turned on",
          "default" : "false",
          "type" : "boolean"
        },
        "publisher-acknowledgements-timeout" : {
          "description" : "The amount of time in milliseconds to wait for a basic.ack response from RabbitMQ server",
          "type" : "integer"
        },
        "queue" : {
          "description" : "The queue to receive messages from",
          "type" : "string"
        },
        "re-queue" : {
          "description" : "This is used by the consumer to control rejection of the message. When the consumer is complete processing the exchange, and if the exchange failed, then the consumer is going to reject the message from the RabbitMQ broker. If the header CamelRabbitmqRequeue is present then the value of the header will be used, otherwise this endpoint value is used as fallback. If the value is false (by default) then the message is discarded/dead-lettered. If the value is true, then the message is re-queued.",
          "default" : "false",
          "type" : "boolean"
        },
        "request-timeout" : {
          "description" : "Set timeout for waiting for a reply when using the InOut Exchange Pattern (in milliseconds)",
          "default" : "20000",
          "type" : "integer"
        },
        "request-timeout-checker-interval" : {
          "description" : "Set requestTimeoutCheckerInterval for inOut exchange",
          "default" : "1000",
          "type" : "integer"
        },
        "requested-channel-max" : {
          "description" : "Connection requested channel max (max number of channels offered)",
          "default" : "2047",
          "type" : "integer"
        },
        "requested-frame-max" : {
          "description" : "Connection requested frame max (max size of frame offered)",
          "default" : "0",
          "type" : "integer"
        },
        "requested-heartbeat" : {
          "description" : "Connection requested heartbeat (heart-beat in seconds offered)",
          "default" : "60",
          "type" : "integer"
        },
        "routing-key" : {
          "description" : "The routing key to use when binding a consumer queue to the exchange. For producer routing keys, you set the header rabbitmq.ROUTING_KEY.",
          "type" : "string"
        },
        "skip-dlq-declare" : {
          "description" : "If true the producer will not declare and bind a dead letter queue. This can be used if you have also DLQ rabbitmq consumer and you want to avoid argument clashing between Producer and Consumer. This option have no effect, if DLQ configured (deadLetterExchange option is not set).",
          "default" : "false",
          "type" : "boolean"
        },
        "skip-exchange-declare" : {
          "description" : "This can be used if we need to declare the queue but not the exchange",
          "default" : "false",
          "type" : "boolean"
        },
        "skip-queue-bind" : {
          "description" : "If true the queue will not be bound to the exchange after declaring it",
          "default" : "false",
          "type" : "boolean"
        },
        "skip-queue-declare" : {
          "description" : "If true the producer will not declare and bind a queue. This can be used for directing messages via an existing routing key.",
          "default" : "false",
          "type" : "boolean"
        },
        "ssl-protocol" : {
          "description" : "Enables SSL on connection, accepted value are true, TLS and 'SSLv3",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "thread-pool-size" : {
          "description" : "The consumer uses a Thread Pool Executor with a fixed number of threads. This setting allows you to set that number of threads.",
          "default" : "10",
          "type" : "integer"
        },
        "topology-recovery-enabled" : {
          "description" : "Enables connection topology recovery (should topology recovery be performed)",
          "type" : "boolean"
        },
        "transfer-exception" : {
          "description" : "When true and an inOut Exchange failed on the consumer side send the caused Exception back in the response",
          "default" : "false",
          "type" : "boolean"
        },
        "trust-manager" : {
          "description" : "Configure SSL trust manager, SSL should be enabled for this option to be effective",
          "type" : "string"
        },
        "username" : {
          "description" : "Username in case of authenticated access",
          "default" : "guest",
          "type" : "string"
        },
        "vhost" : {
          "description" : "The vhost for the channel",
          "default" : "/",
          "type" : "string"
        }
      }
    },
    "reactive-streams" : {
      "type" : "object",
      "properties" : {
        "stream" : {
          "description" : "Name of the stream channel used by the endpoint to exchange messages.",
          "type" : "string"
        },
        "backpressure-strategy" : {
          "description" : "The backpressure strategy to use when pushing events to a slow subscriber.",
          "enum" : [ "BUFFER", "OLDEST", "LATEST" ],
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "concurrent-consumers" : {
          "description" : "Number of threads used to process exchanges in the Camel route.",
          "default" : "1",
          "type" : "integer"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "exchanges-refill-low-watermark" : {
          "description" : "Set the low watermark of requested exchanges to the active subscription as percentage of the maxInflightExchanges. When the number of pending items from the upstream source is lower than the watermark, new items can be requested to the subscription. If set to 0, the subscriber will request items in batches of maxInflightExchanges, only after all items of the previous batch have been processed. If set to 1, the subscriber can request a new item each time an exchange is processed (chatty). Any intermediate value can be used.",
          "default" : "0.25",
          "type" : "number"
        },
        "forward-on-complete" : {
          "description" : "Determines if onComplete events should be pushed to the Camel route.",
          "default" : "false",
          "type" : "boolean"
        },
        "forward-on-error" : {
          "description" : "Determines if onError events should be pushed to the Camel route. Exceptions will be set as message body.",
          "default" : "false",
          "type" : "boolean"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "max-inflight-exchanges" : {
          "description" : "Maximum number of exchanges concurrently being processed by Camel. This parameter controls backpressure on the stream. Setting a non-positive value will disable backpressure.",
          "default" : "128",
          "type" : "integer"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "ref" : {
      "type" : "object",
      "required" : [ "name" ],
      "properties" : {
        "name" : {
          "description" : "Name of endpoint to lookup in the registry.",
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "rest" : {
      "type" : "object",
      "required" : [ "method", "path" ],
      "properties" : {
        "method" : {
          "description" : "HTTP method to use.",
          "enum" : [ "get", "post", "put", "delete", "patch", "head", "trace", "connect", "options" ],
          "type" : "string"
        },
        "path" : {
          "description" : "The base path",
          "type" : "string"
        },
        "uri-template" : {
          "description" : "The uri template",
          "type" : "string"
        },
        "api-doc" : {
          "description" : "The openapi api doc resource to use. The resource is loaded from classpath by default and must be in JSON format.",
          "type" : "string"
        },
        "binding-mode" : {
          "description" : "Configures the binding mode for the producer. If set to anything other than 'off' the producer will try to convert the body of the incoming message from inType to the json or xml, and the response from json or xml to outType.",
          "enum" : [ "auto", "off", "json", "xml", "json_xml" ],
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "consumer-component-name" : {
          "description" : "The Camel Rest component to use for (consumer) the REST transport, such as jetty, servlet, undertow. If no component has been explicit configured, then Camel will lookup if there is a Camel component that integrates with the Rest DSL, or if a org.apache.camel.spi.RestConsumerFactory is registered in the registry. If either one is found, then that is being used.",
          "type" : "string"
        },
        "consumes" : {
          "description" : "Media type such as: 'text/xml', or 'application/json' this REST service accepts. By default we accept all kinds of types.",
          "type" : "string"
        },
        "description" : {
          "description" : "Human description to document this REST service",
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "host" : {
          "description" : "Host and port of HTTP service to use (override host in openapi schema)",
          "type" : "string"
        },
        "in-type" : {
          "description" : "To declare the incoming POJO binding type as a FQN class name",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "out-type" : {
          "description" : "To declare the outgoing POJO binding type as a FQN class name",
          "type" : "string"
        },
        "producer-component-name" : {
          "description" : "The Camel Rest component to use for (producer) the REST transport, such as http, undertow. If no component has been explicit configured, then Camel will lookup if there is a Camel component that integrates with the Rest DSL, or if a org.apache.camel.spi.RestProducerFactory is registered in the registry. If either one is found, then that is being used.",
          "type" : "string"
        },
        "produces" : {
          "description" : "Media type such as: 'text/xml', or 'application/json' this REST service returns.",
          "type" : "string"
        },
        "query-parameters" : {
          "description" : "Query parameters for the HTTP service to call. The query parameters can contain multiple parameters separated by ampersand such such as foo=123&bar=456.",
          "type" : "string"
        },
        "route-id" : {
          "description" : "Name of the route this REST services creates",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "rest-api" : {
      "type" : "object",
      "properties" : {
        "context-id-pattern" : {
          "description" : "Optional CamelContext id pattern to only allow Rest APIs from rest services within CamelContext's which name matches the pattern.",
          "type" : "string"
        },
        "path" : {
          "description" : "The base path",
          "type" : "string"
        },
        "api-component-name" : {
          "description" : "The Camel Rest API component to use for generating the API of the REST services, such as openapi.",
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "consumer-component-name" : {
          "description" : "The Camel Rest component to use for (consumer) the REST transport, such as jetty, servlet, undertow. If no component has been explicit configured, then Camel will lookup if there is a Camel component that integrates with the Rest DSL, or if a org.apache.camel.spi.RestConsumerFactory is registered in the registry. If either one is found, then that is being used.",
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        }
      },
      "required" : [ "path" ]
    },
    "rest-openapi" : {
      "type" : "object",
      "required" : [ "operationId" ],
      "properties" : {
        "operation-id" : {
          "description" : "ID of the operation from the OpenApi specification.",
          "type" : "string"
        },
        "specification-uri" : {
          "description" : "Path to the OpenApi specification file. The scheme, host base path are taken from this specification, but these can be overridden with properties on the component or endpoint level. If not given the component tries to load openapi.json resource from the classpath. Note that the host defined on the component and endpoint of this Component should contain the scheme, hostname and optionally the port in the URI syntax (i.e. http://api.example.com:8080). Overrides component configuration. The OpenApi specification can be loaded from different sources by prefixing with file: classpath: http: https:. Support for https is limited to using the JDK installed UrlHandler, and as such it can be cumbersome to setup TLS/SSL certificates for https (such as setting a number of javax.net.ssl JVM system properties). How to do that consult the JDK documentation for UrlHandler. Default value notice: By default loads openapi.json file",
          "default" : "openapi.json",
          "type" : "string"
        },
        "base-path" : {
          "description" : "API basePath, for example /v2. Default is unset, if set overrides the value present in OpenApi specification and in the component configuration.",
          "type" : "string"
        },
        "component-name" : {
          "description" : "Name of the Camel component that will perform the requests. The component must be present in Camel registry and it must implement RestProducerFactory service provider interface. If not set CLASSPATH is searched for single component that implements RestProducerFactory SPI. Overrides component configuration.",
          "type" : "string"
        },
        "consumes" : {
          "description" : "What payload type this component capable of consuming. Could be one type, like application/json or multiple types as application/json, application/xml; q=0.5 according to the RFC7231. This equates to the value of Accept HTTP header. If set overrides any value found in the OpenApi specification and. in the component configuration",
          "type" : "string"
        },
        "host" : {
          "description" : "Scheme hostname and port to direct the HTTP requests to in the form of https://hostname:port. Can be configured at the endpoint, component or in the corresponding REST configuration in the Camel Context. If you give this component a name (e.g. petstore) that REST configuration is consulted first, rest-openapi next, and global configuration last. If set overrides any value found in the OpenApi specification, RestConfiguration. Overrides all other configuration.",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "produces" : {
          "description" : "What payload type this component is producing. For example application/json according to the RFC7231. This equates to the value of Content-Type HTTP header. If set overrides any value present in the OpenApi specification. Overrides all other configuration.",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "rest-swagger" : {
      "type" : "object",
      "required" : [ "operationId" ],
      "properties" : {
        "operation-id" : {
          "description" : "ID of the operation from the Swagger specification.",
          "type" : "string"
        },
        "specification-uri" : {
          "description" : "Path to the Swagger specification file. The scheme, host base path are taken from this specification, but these can be overridden with properties on the component or endpoint level. If not given the component tries to load swagger.json resource from the classpath. Note that the host defined on the component and endpoint of this Component should contain the scheme, hostname and optionally the port in the URI syntax (i.e. http://api.example.com:8080). Overrides component configuration. The Swagger specification can be loaded from different sources by prefixing with file: classpath: http: https:. Support for https is limited to using the JDK installed UrlHandler, and as such it can be cumbersome to setup TLS/SSL certificates for https (such as setting a number of javax.net.ssl JVM system properties). How to do that consult the JDK documentation for UrlHandler. Default value notice: By default loads swagger.json file",
          "default" : "swagger.json",
          "type" : "string"
        },
        "base-path" : {
          "description" : "API basePath, for example /v2. Default is unset, if set overrides the value present in Swagger specification and in the component configuration.",
          "type" : "string"
        },
        "component-name" : {
          "description" : "Name of the Camel component that will perform the requests. The component must be present in Camel registry and it must implement RestProducerFactory service provider interface. If not set CLASSPATH is searched for single component that implements RestProducerFactory SPI. Overrides component configuration.",
          "type" : "string"
        },
        "consumes" : {
          "description" : "What payload type this component capable of consuming. Could be one type, like application/json or multiple types as application/json, application/xml; q=0.5 according to the RFC7231. This equates to the value of Accept HTTP header. If set overrides any value found in the Swagger specification and. in the component configuration",
          "type" : "string"
        },
        "host" : {
          "description" : "Scheme hostname and port to direct the HTTP requests to in the form of https://hostname:port. Can be configured at the endpoint, component or in the corresponding REST configuration in the Camel Context. If you give this component a name (e.g. petstore) that REST configuration is consulted first, rest-swagger next, and global configuration last. If set overrides any value found in the Swagger specification, RestConfiguration. Overrides all other configuration.",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "produces" : {
          "description" : "What payload type this component is producing. For example application/json according to the RFC7231. This equates to the value of Content-Type HTTP header. If set overrides any value present in the Swagger specification. Overrides all other configuration.",
          "type" : "string"
        },
        "ssl-context-parameters" : {
          "description" : "To configure security using SSLContextParameters.",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "resteasy" : {
      "type" : "object",
      "required" : [ "httpUri" ],
      "properties" : {
        "http-uri" : {
          "description" : "The url of the HTTP endpoint to call.",
          "type" : "string"
        },
        "async" : {
          "description" : "Configure the consumer to work in async mode",
          "default" : "false",
          "type" : "boolean"
        },
        "bridge-endpoint" : {
          "description" : "If the option is true, HttpProducer will ignore the Exchange.HTTP_URI header, and use the endpoint's URI for request. You may also set the option throwExceptionOnFailure to be false to let the HttpProducer send all the fault response back.",
          "default" : "false",
          "type" : "boolean"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "chunked" : {
          "description" : "If this option is false the Servlet will disable the HTTP streaming and set the content-length header on the response",
          "default" : "true",
          "type" : "boolean"
        },
        "clear-expired-cookies" : {
          "description" : "Whether to clear expired cookies before sending the HTTP request. This ensures the cookies store does not keep growing by adding new cookies which is newer removed when they are expired.",
          "default" : "true",
          "type" : "boolean"
        },
        "connection-close" : {
          "description" : "Specifies whether a Connection Close header must be added to HTTP Request. By default connectionClose is false.",
          "default" : "false",
          "type" : "boolean"
        },
        "cookie-handler" : {
          "description" : "Configure a cookie handler to maintain a HTTP session",
          "type" : "string"
        },
        "copy-headers" : {
          "description" : "If this option is true then IN exchange headers will be copied to OUT exchange headers according to copy strategy. Setting this to false, allows to only include the headers from the HTTP response (not propagating IN headers).",
          "default" : "true",
          "type" : "boolean"
        },
        "custom-host-header" : {
          "description" : "To use custom host header for producer. When not set in query will be ignored. When set will override host header derived from url.",
          "type" : "string"
        },
        "delete-with-body" : {
          "description" : "Whether the HTTP DELETE should include the message body or not. By default HTTP DELETE do not include any HTTP body. However in some rare cases users may need to be able to include the message body.",
          "default" : "false",
          "type" : "boolean"
        },
        "disable-stream-cache" : {
          "description" : "Determines whether or not the raw input stream from Servlet is cached or not (Camel will read the stream into a in memory/overflow to file, Stream caching) cache. By default Camel will cache the Servlet input stream to support reading it multiple times to ensure it Camel can retrieve all data from the stream. However you can set this option to true when you for example need to access the raw stream, such as streaming it directly to a file or other persistent store. DefaultHttpBinding will copy the request input stream into a stream cache and put it into message body if this option is false to support reading the stream multiple times. If you use Servlet to bridge/proxy an endpoint then consider enabling this option to improve performance, in case you do not need to read the message payload multiple times. The http producer will by default cache the response body stream. If setting this option to true, then the producers will not cache the response body stream but use the response stream as-is as the message body.",
          "default" : "false",
          "type" : "boolean"
        },
        "eager-check-content-available" : {
          "description" : "Whether to eager check whether the HTTP requests has content if the content-length header is 0 or not present. This can be turned on in case HTTP clients do not send streamed data.",
          "default" : "false",
          "type" : "boolean"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "get-with-body" : {
          "description" : "Whether the HTTP GET should include the message body or not. By default HTTP GET do not include any HTTP body. However in some rare cases users may need to be able to include the message body.",
          "default" : "false",
          "type" : "boolean"
        },
        "header-filter-strategy" : {
          "description" : "To use a custom HeaderFilterStrategy to filter header to and from Camel message.",
          "type" : "string"
        },
        "http-method" : {
          "description" : "Configure the HTTP method to use. The HttpMethod header cannot override this option if set.",
          "enum" : [ "GET", "POST", "PUT", "DELETE", "HEAD", "OPTIONS", "TRACE", "PATCH" ],
          "type" : "string"
        },
        "http-method-restrict" : {
          "description" : "Used to only allow consuming if the HttpMethod matches, such as GET/POST/PUT etc. Multiple methods can be specified separated by comma.",
          "type" : "string"
        },
        "ignore-response-body" : {
          "description" : "If this option is true, The http producer won't read response body and cache the input stream",
          "default" : "false",
          "type" : "boolean"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "map-http-message-body" : {
          "description" : "If this option is true then IN exchange Body of the exchange will be mapped to HTTP body. Setting this to false will avoid the HTTP mapping.",
          "default" : "true",
          "type" : "boolean"
        },
        "map-http-message-form-url-encoded-body" : {
          "description" : "If this option is true then IN exchange Form Encoded body of the exchange will be mapped to HTTP. Setting this to false will avoid the HTTP Form Encoded body mapping.",
          "default" : "true",
          "type" : "boolean"
        },
        "map-http-message-headers" : {
          "description" : "If this option is true then IN exchange Headers of the exchange will be mapped to HTTP headers. Setting this to false will avoid the HTTP Headers mapping.",
          "default" : "true",
          "type" : "boolean"
        },
        "match-on-uri-prefix" : {
          "description" : "Whether or not the consumer should try to find a target consumer by matching the URI prefix if no exact match is found.",
          "default" : "false",
          "type" : "boolean"
        },
        "mute-exception" : {
          "description" : "If enabled and an Exchange failed processing on the consumer side the response's body won't contain the exception's stack trace.",
          "default" : "false",
          "type" : "boolean"
        },
        "ok-status-code-range" : {
          "description" : "The status codes which are considered a success response. The values are inclusive. Multiple ranges can be defined, separated by comma, e.g. 200-204,209,301-304. Each range must be a single number or from-to with the dash included.",
          "default" : "200-299",
          "type" : "string"
        },
        "options-enabled" : {
          "description" : "Specifies whether to enable HTTP OPTIONS for this Servlet consumer. By default OPTIONS is turned off.",
          "default" : "false",
          "type" : "boolean"
        },
        "password" : {
          "description" : "Sets the password",
          "type" : "string"
        },
        "preserve-host-header" : {
          "description" : "If the option is true, HttpProducer will set the Host header to the value contained in the current exchange Host header, useful in reverse proxy applications where you want the Host header received by the downstream server to reflect the URL called by the upstream client, this allows applications which use the Host header to generate accurate URL's for a proxied service",
          "default" : "false",
          "type" : "boolean"
        },
        "proxy-client-class" : {
          "description" : "Sets the resteasy proxyClientClass",
          "type" : "string"
        },
        "response-buffer-size" : {
          "description" : "To use a custom buffer size on the javax.servlet.ServletResponse.",
          "type" : "integer"
        },
        "resteasy-method" : {
          "description" : "Sets the resteasy method to process the request",
          "default" : "GET",
          "type" : "string"
        },
        "servlet-name" : {
          "description" : "Sets the servlet name",
          "type" : "string"
        },
        "set-http-response-during-processing" : {
          "description" : "Sets the flag to use the endpoint where you can either populate camel exchange from servlet response or use request itself which may be thought as if it is a proxy.",
          "type" : "boolean"
        },
        "skip-servlet-processing" : {
          "description" : "Sets the flag to use skip servlet processing and let camel take over processing",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "throw-exception-on-failure" : {
          "description" : "Option to disable throwing the HttpOperationFailedException in case of failed responses from the remote server. This allows you to get all responses regardless of the HTTP status code.",
          "default" : "true",
          "type" : "boolean"
        },
        "trace-enabled" : {
          "description" : "Specifies whether to enable HTTP TRACE for this Servlet consumer. By default TRACE is turned off.",
          "default" : "false",
          "type" : "boolean"
        },
        "transfer-exception" : {
          "description" : "If enabled and an Exchange failed processing on the consumer side, and if the caused Exception was send back serialized in the response as a application/x-java-serialized-object content type. On the producer side the exception will be deserialized and thrown as is, instead of the HttpOperationFailedException. The caused exception is required to be serialized. This is by default turned off. If you enable this then be aware that Java will deserialize the incoming data from the request to Java and that can be a potential security risk.",
          "default" : "false",
          "type" : "boolean"
        },
        "use-system-properties" : {
          "description" : "To use System Properties as fallback for configuration",
          "default" : "false",
          "type" : "boolean"
        },
        "username" : {
          "description" : "Sets the username",
          "type" : "string"
        }
      }
    },
    "robotframework" : {
      "type" : "object",
      "required" : [ "resourceUri" ],
      "properties" : {
        "resource-uri" : {
          "description" : "Path to the resource. You can prefix with: classpath, file, http, ref, or bean. classpath, file and http loads the resource using these protocols (classpath is default). ref will lookup the resource in the registry. bean will call a method on a bean to be used as the resource. For bean you can specify the method name after dot, eg bean:myBean.myMethod.",
          "type" : "string"
        },
        "allow-context-map-all" : {
          "description" : "Sets whether the context map should allow access to all details. By default only the message body and headers can be accessed. This option can be enabled for full access to the current Exchange and CamelContext. Doing so impose a potential security risk as this opens access to the full power of CamelContext API.",
          "default" : "false",
          "type" : "boolean"
        },
        "allow-template-from-header" : {
          "description" : "Whether to allow to use resource template from header or not (default false). Enabling this allows to specify dynamic templates via message header. However this can be seen as a potential security vulnerability if the header is coming from a malicious user, so use this with care.",
          "default" : "false",
          "type" : "boolean"
        },
        "argument-file" : {
          "description" : "A text file to read more arguments from.",
          "type" : "string"
        },
        "backoff-error-threshold" : {
          "description" : "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-idle-threshold" : {
          "description" : "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-multiplier" : {
          "description" : "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
          "type" : "integer"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "combined-tag-stats" : {
          "description" : "Creates combined statistics based on tags. Use the format tags:title List",
          "type" : "string"
        },
        "content-cache" : {
          "description" : "Sets whether to use resource content cache or not",
          "default" : "false",
          "type" : "boolean"
        },
        "critical-tags" : {
          "description" : "Tests that have the given tags are considered critical. List",
          "type" : "string"
        },
        "debug-file" : {
          "description" : "A debug file that is written during execution.",
          "type" : "string"
        },
        "delay" : {
          "description" : "Milliseconds before the next poll.",
          "default" : "500",
          "type" : "integer"
        },
        "document" : {
          "description" : "Sets the documentation of the top-level tests suites.",
          "type" : "string"
        },
        "dryrun" : {
          "description" : "Sets dryrun mode on use. In the dry run mode tests are run without executing keywords originating from test libraries. Useful for validating test data syntax.",
          "default" : "false",
          "type" : "boolean"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "excludes" : {
          "description" : "Selects the tests cases by tags. List",
          "type" : "string"
        },
        "exit-on-failure" : {
          "description" : "Sets robot to stop execution immediately if a critical test fails.",
          "default" : "false",
          "type" : "boolean"
        },
        "greedy" : {
          "description" : "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
          "default" : "false",
          "type" : "boolean"
        },
        "includes" : {
          "description" : "Selects the tests cases by tags. List",
          "type" : "string"
        },
        "initial-delay" : {
          "description" : "Milliseconds before the first poll starts.",
          "default" : "1000",
          "type" : "integer"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "listener" : {
          "description" : "Sets a single listener for monitoring tests execution",
          "type" : "string"
        },
        "listeners" : {
          "description" : "Sets multiple listeners for monitoring tests execution. Use the format ListenerWithArgs:arg1:arg2 or simply ListenerWithoutArgs List",
          "type" : "string"
        },
        "log" : {
          "description" : "Sets the path to the generated log file.",
          "type" : "string"
        },
        "log-level" : {
          "description" : "Sets the threshold level for logging.",
          "type" : "string"
        },
        "log-title" : {
          "description" : "Sets a title for the generated tests log.",
          "type" : "string"
        },
        "metadata" : {
          "description" : "Sets free metadata for the top level tests suites. comma seperated list of string resulting as List",
          "type" : "string"
        },
        "monitor-colors" : {
          "description" : "Using ANSI colors in console. Normally colors work in unixes but not in Windows. Default is 'on'. 'on' - use colors in unixes but not in Windows 'off' - never use colors 'force' - always use colors (also in Windows)",
          "type" : "string"
        },
        "monitor-width" : {
          "description" : "Width of the monitor output. Default is 78.",
          "default" : "78",
          "type" : "string"
        },
        "name" : {
          "description" : "Sets the name of the top-level tests suites.",
          "type" : "string"
        },
        "no-status-return-code" : {
          "description" : "If true, sets the return code to zero regardless of failures in test cases. Error codes are returned normally.",
          "default" : "false",
          "type" : "boolean"
        },
        "non-critical-tags" : {
          "description" : "Tests that have the given tags are not critical. List",
          "type" : "string"
        },
        "output" : {
          "description" : "Sets the path to the generated output file.",
          "type" : "string"
        },
        "output-directory" : {
          "description" : "Configures where generated reports are to be placed.",
          "type" : "string"
        },
        "poll-strategy" : {
          "description" : "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
          "type" : "string"
        },
        "randomize" : {
          "description" : "Sets the test execution order to be randomized. Valid values are all, suite, and test",
          "type" : "string"
        },
        "repeat-count" : {
          "description" : "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
          "default" : "0",
          "type" : "integer"
        },
        "report" : {
          "description" : "Sets the path to the generated report file.",
          "type" : "string"
        },
        "report-background" : {
          "description" : "Sets background colors for the generated report and summary.",
          "type" : "string"
        },
        "report-title" : {
          "description" : "Sets a title for the generated tests report.",
          "type" : "string"
        },
        "run-empty-suite" : {
          "description" : "Executes tests also if the top level test suite is empty. Useful e.g. with --include/--exclude when it is not an error that no test matches the condition.",
          "default" : "false",
          "type" : "boolean"
        },
        "run-failed" : {
          "description" : "Re-run failed tests, based on output.xml file.",
          "type" : "string"
        },
        "run-logging-level" : {
          "description" : "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
          "default" : "TRACE",
          "enum" : [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ],
          "type" : "string"
        },
        "run-mode" : {
          "description" : "Sets the execution mode for this tests run. Note that this setting has been deprecated in Robot Framework 2.8. Use separate dryryn, skipTeardownOnExit, exitOnFailure, and randomize settings instead.",
          "type" : "string"
        },
        "scheduled-executor-service" : {
          "description" : "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
          "type" : "string"
        },
        "scheduler" : {
          "description" : "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
          "default" : "none",
          "type" : "string"
        },
        "scheduler-properties" : {
          "description" : "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
          "type" : "string"
        },
        "send-empty-message-when-idle" : {
          "description" : "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
          "default" : "false",
          "type" : "boolean"
        },
        "skip-teardown-on-exit" : {
          "description" : "Sets whether the teardowns are skipped if the test execution is prematurely stopped.",
          "default" : "false",
          "type" : "boolean"
        },
        "split-outputs" : {
          "description" : "Splits output and log files.",
          "type" : "string"
        },
        "start-scheduler" : {
          "description" : "Whether the scheduler should be auto started.",
          "default" : "true",
          "type" : "boolean"
        },
        "suite-stat-level" : {
          "description" : "Defines how many levels to show in the Statistics by Suite table in outputs.",
          "type" : "string"
        },
        "suites" : {
          "description" : "Selects the tests suites by name. List",
          "type" : "string"
        },
        "summary-title" : {
          "description" : "Sets a title for the generated summary report.",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "tag-docs" : {
          "description" : "Adds documentation to the specified tags. List",
          "type" : "string"
        },
        "tag-stat-excludes" : {
          "description" : "Excludes these tags from the Statistics by Tag and Test Details by Tag tables in outputs. List",
          "type" : "string"
        },
        "tag-stat-includes" : {
          "description" : "Includes only these tags in the Statistics by Tag and Test Details by Tag tables in outputs. List",
          "type" : "string"
        },
        "tag-stat-links" : {
          "description" : "Adds external links to the Statistics by Tag table in outputs. Use the format pattern:link:title List",
          "type" : "string"
        },
        "tags" : {
          "description" : "Sets the tags(s) to all executed tests cases. List",
          "type" : "string"
        },
        "tests" : {
          "description" : "Selects the tests cases by name. List",
          "type" : "string"
        },
        "time-unit" : {
          "description" : "Time unit for initialDelay and delay options.",
          "default" : "MILLISECONDS",
          "enum" : [ "NANOSECONDS", "MICROSECONDS", "MILLISECONDS", "SECONDS", "MINUTES", "HOURS", "DAYS" ],
          "type" : "string"
        },
        "timestamp-outputs" : {
          "description" : "Adds a timestamp to all output files.",
          "default" : "false",
          "type" : "boolean"
        },
        "use-fixed-delay" : {
          "description" : "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
          "default" : "true",
          "type" : "boolean"
        },
        "variable-files" : {
          "description" : "Sets variables using variables files. Use the format path:args List",
          "type" : "string"
        },
        "variables" : {
          "description" : "Sets individual variables. Use the format name:value List",
          "type" : "string"
        },
        "warn-on-skipped-files" : {
          "description" : "Show a warning when an invalid file is skipped.",
          "default" : "false",
          "type" : "boolean"
        },
        "xunit-file" : {
          "description" : "Sets the path to the generated XUnit compatible result file, relative to outputDirectory. The file is in xml format. By default, the file name is derived from the testCasesDirectory parameter, replacing blanks in the directory name by underscores.",
          "type" : "string"
        }
      }
    },
    "rss" : {
      "type" : "object",
      "required" : [ "feedUri" ],
      "properties" : {
        "feed-uri" : {
          "description" : "The URI to the feed to poll.",
          "type" : "string"
        },
        "backoff-error-threshold" : {
          "description" : "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-idle-threshold" : {
          "description" : "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-multiplier" : {
          "description" : "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
          "type" : "integer"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "delay" : {
          "description" : "Milliseconds before the next poll.",
          "default" : "500",
          "type" : "integer"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "feed-header" : {
          "description" : "Sets whether to add the feed object as a header.",
          "default" : "true",
          "type" : "boolean"
        },
        "filter" : {
          "description" : "Sets whether to use filtering or not of the entries.",
          "default" : "true",
          "type" : "boolean"
        },
        "greedy" : {
          "description" : "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
          "default" : "false",
          "type" : "boolean"
        },
        "initial-delay" : {
          "description" : "Milliseconds before the first poll starts.",
          "default" : "1000",
          "type" : "integer"
        },
        "last-update" : {
          "description" : "Sets the timestamp to be used for filtering entries from the atom feeds. This options is only in conjunction with the splitEntries.",
          "type" : "string"
        },
        "password" : {
          "description" : "Sets the password to be used for basic authentication when polling from a HTTP feed.",
          "type" : "string"
        },
        "poll-strategy" : {
          "description" : "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
          "type" : "string"
        },
        "repeat-count" : {
          "description" : "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
          "default" : "0",
          "type" : "integer"
        },
        "run-logging-level" : {
          "description" : "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
          "default" : "TRACE",
          "enum" : [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ],
          "type" : "string"
        },
        "scheduled-executor-service" : {
          "description" : "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
          "type" : "string"
        },
        "scheduler" : {
          "description" : "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
          "default" : "none",
          "type" : "string"
        },
        "scheduler-properties" : {
          "description" : "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
          "type" : "string"
        },
        "send-empty-message-when-idle" : {
          "description" : "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
          "default" : "false",
          "type" : "boolean"
        },
        "sort-entries" : {
          "description" : "Sets whether to sort entries by published date. Only works when splitEntries = true.",
          "default" : "false",
          "type" : "boolean"
        },
        "split-entries" : {
          "description" : "Sets whether or not entries should be sent individually or whether the entire feed should be sent as a single message",
          "default" : "true",
          "type" : "boolean"
        },
        "start-scheduler" : {
          "description" : "Whether the scheduler should be auto started.",
          "default" : "true",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "throttle-entries" : {
          "description" : "Sets whether all entries identified in a single feed poll should be delivered immediately. If true, only one entry is processed per delay. Only applicable when splitEntries = true.",
          "default" : "true",
          "type" : "boolean"
        },
        "time-unit" : {
          "description" : "Time unit for initialDelay and delay options.",
          "default" : "MILLISECONDS",
          "enum" : [ "NANOSECONDS", "MICROSECONDS", "MILLISECONDS", "SECONDS", "MINUTES", "HOURS", "DAYS" ],
          "type" : "string"
        },
        "use-fixed-delay" : {
          "description" : "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
          "default" : "true",
          "type" : "boolean"
        },
        "username" : {
          "description" : "Sets the username to be used for basic authentication when polling from a HTTP feed.",
          "type" : "string"
        }
      }
    },
    "saga" : {
      "type" : "object",
      "required" : [ "action" ],
      "properties" : {
        "action" : {
          "description" : "Action to execute (complete or compensate)",
          "enum" : [ "COMPLETE", "COMPENSATE" ],
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "salesforce" : {
      "type" : "object",
      "properties" : {
        "operation-name" : {
          "description" : "The operation to use",
          "enum" : [ "getVersions", "getResources", "getGlobalObjects", "getBasicInfo", "getDescription", "getSObject", "createSObject", "updateSObject", "deleteSObject", "getSObjectWithId", "upsertSObject", "deleteSObjectWithId", "getBlobField", "query", "queryMore", "queryAll", "search", "apexCall", "recent", "createJob", "getJob", "closeJob", "abortJob", "createBatch", "getBatch", "getAllBatches", "getRequest", "getResults", "createBatchQuery", "getQueryResultIds", "getQueryResult", "getRecentReports", "getReportDescription", "executeSyncReport", "executeAsyncReport", "getReportInstances", "getReportResults", "limits", "approval", "approvals", "composite-tree", "composite-batch", "composite" ],
          "type" : "string"
        },
        "topic-name" : {
          "description" : "The name of the topic/channel to use",
          "type" : "string"
        },
        "apex-method" : {
          "description" : "APEX method name",
          "type" : "string"
        },
        "apex-query-params" : {
          "description" : "Query params for APEX method",
          "type" : "string"
        },
        "apex-url" : {
          "description" : "APEX method URL",
          "type" : "string"
        },
        "api-version" : {
          "description" : "Salesforce API version.",
          "default" : "50.0",
          "type" : "string"
        },
        "backoff-increment" : {
          "description" : "Backoff interval increment for Streaming connection restart attempts for failures beyond CometD auto-reconnect.",
          "default" : "1000",
          "type" : "string"
        },
        "batch-id" : {
          "description" : "Bulk API Batch ID",
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "composite-method" : {
          "description" : "Composite (raw) method.",
          "type" : "string"
        },
        "content-type" : {
          "description" : "Bulk API content type, one of XML, CSV, ZIP_XML, ZIP_CSV",
          "enum" : [ "XML", "CSV", "JSON", "ZIP_XML", "ZIP_CSV", "ZIP_JSON" ],
          "type" : "string"
        },
        "default-replay-id" : {
          "description" : "Default replayId setting if no value is found in initialReplayIdMap",
          "default" : "-1",
          "type" : "integer"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "format" : {
          "description" : "Payload format to use for Salesforce API calls, either JSON or XML, defaults to JSON",
          "enum" : [ "JSON", "XML" ],
          "type" : "string"
        },
        "http-client" : {
          "description" : "Custom Jetty Http Client to use to connect to Salesforce.",
          "type" : "string"
        },
        "include-details" : {
          "description" : "Include details in Salesforce1 Analytics report, defaults to false.",
          "type" : "boolean"
        },
        "initial-replay-id-map" : {
          "description" : "Replay IDs to start from per channel name.",
          "type" : "string"
        },
        "instance-id" : {
          "description" : "Salesforce1 Analytics report execution instance ID",
          "type" : "string"
        },
        "job-id" : {
          "description" : "Bulk API Job ID",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "limit" : {
          "description" : "Limit on number of returned records. Applicable to some of the API, check the Salesforce documentation.",
          "type" : "integer"
        },
        "max-backoff" : {
          "description" : "Maximum backoff interval for Streaming connection restart attempts for failures beyond CometD auto-reconnect.",
          "default" : "30000",
          "type" : "string"
        },
        "not-found-behaviour" : {
          "description" : "Sets the behaviour of 404 not found status received from Salesforce API. Should the body be set to NULL NotFoundBehaviour#NULL or should a exception be signaled on the exchange NotFoundBehaviour#EXCEPTION - the default.",
          "default" : "EXCEPTION",
          "enum" : [ "EXCEPTION", "NULL" ],
          "type" : "string"
        },
        "notify-for-fields" : {
          "description" : "Notify for fields, options are ALL, REFERENCED, SELECT, WHERE",
          "enum" : [ "ALL", "REFERENCED", "SELECT", "WHERE" ],
          "type" : "string"
        },
        "notify-for-operation-create" : {
          "description" : "Notify for create operation, defaults to false (API version = 29.0)",
          "type" : "boolean"
        },
        "notify-for-operation-delete" : {
          "description" : "Notify for delete operation, defaults to false (API version = 29.0)",
          "type" : "boolean"
        },
        "notify-for-operation-undelete" : {
          "description" : "Notify for un-delete operation, defaults to false (API version = 29.0)",
          "type" : "boolean"
        },
        "notify-for-operation-update" : {
          "description" : "Notify for update operation, defaults to false (API version = 29.0)",
          "type" : "boolean"
        },
        "notify-for-operations" : {
          "description" : "Notify for operations, options are ALL, CREATE, EXTENDED, UPDATE (API version 29.0)",
          "enum" : [ "ALL", "CREATE", "EXTENDED", "UPDATE" ],
          "type" : "string"
        },
        "object-mapper" : {
          "description" : "Custom Jackson ObjectMapper to use when serializing/deserializing Salesforce objects.",
          "type" : "string"
        },
        "raw-payload" : {
          "description" : "Use raw payload String for request and response (either JSON or XML depending on format), instead of DTOs, false by default",
          "default" : "false",
          "type" : "boolean"
        },
        "replay-id" : {
          "description" : "The replayId value to use when subscribing",
          "type" : "integer"
        },
        "report-id" : {
          "description" : "Salesforce1 Analytics report Id",
          "type" : "string"
        },
        "report-metadata" : {
          "description" : "Salesforce1 Analytics report metadata for filtering",
          "type" : "string"
        },
        "result-id" : {
          "description" : "Bulk API Result ID",
          "type" : "string"
        },
        "s-object-blob-field-name" : {
          "description" : "SObject blob field name",
          "type" : "string"
        },
        "s-object-class" : {
          "description" : "Fully qualified SObject class name, usually generated using camel-salesforce-maven-plugin",
          "type" : "string"
        },
        "s-object-fields" : {
          "description" : "SObject fields to retrieve",
          "type" : "string"
        },
        "s-object-id" : {
          "description" : "SObject ID if required by API",
          "type" : "string"
        },
        "s-object-id-name" : {
          "description" : "SObject external ID field name",
          "type" : "string"
        },
        "s-object-id-value" : {
          "description" : "SObject external ID field value",
          "type" : "string"
        },
        "s-object-name" : {
          "description" : "SObject name if required or supported by API",
          "type" : "string"
        },
        "s-object-query" : {
          "description" : "Salesforce SOQL query string",
          "type" : "string"
        },
        "s-object-search" : {
          "description" : "Salesforce SOSL search string",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "update-topic" : {
          "description" : "Whether to update an existing Push Topic when using the Streaming API, defaults to false",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "sap-netweaver" : {
      "type" : "object",
      "required" : [ "url", "password", "username" ],
      "properties" : {
        "url" : {
          "description" : "Url to the SAP net-weaver gateway server.",
          "type" : "string"
        },
        "flattern-map" : {
          "description" : "If the JSON Map contains only a single entry, then flattern by storing that single entry value as the message body.",
          "default" : "true",
          "type" : "boolean"
        },
        "json" : {
          "description" : "Whether to return data in JSON format. If this option is false, then XML is returned in Atom format.",
          "default" : "true",
          "type" : "boolean"
        },
        "json-as-map" : {
          "description" : "To transform the JSON from a String to a Map in the message body.",
          "default" : "true",
          "type" : "boolean"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "password" : {
          "description" : "Password for account.",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "username" : {
          "description" : "Username for account.",
          "type" : "string"
        }
      }
    },
    "scheduler" : {
      "type" : "object",
      "required" : [ "name" ],
      "properties" : {
        "name" : {
          "description" : "The name of the scheduler",
          "type" : "string"
        },
        "backoff-error-threshold" : {
          "description" : "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-idle-threshold" : {
          "description" : "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-multiplier" : {
          "description" : "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
          "type" : "integer"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "concurrent-tasks" : {
          "description" : "Number of threads used by the scheduling thread pool. Is by default using a single thread",
          "default" : "1",
          "type" : "integer"
        },
        "delay" : {
          "description" : "Milliseconds before the next poll.",
          "default" : "500",
          "type" : "integer"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "greedy" : {
          "description" : "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
          "default" : "false",
          "type" : "boolean"
        },
        "initial-delay" : {
          "description" : "Milliseconds before the first poll starts.",
          "default" : "1000",
          "type" : "integer"
        },
        "poll-strategy" : {
          "description" : "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
          "type" : "string"
        },
        "repeat-count" : {
          "description" : "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
          "default" : "0",
          "type" : "integer"
        },
        "run-logging-level" : {
          "description" : "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
          "default" : "TRACE",
          "enum" : [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ],
          "type" : "string"
        },
        "scheduled-executor-service" : {
          "description" : "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
          "type" : "string"
        },
        "scheduler" : {
          "description" : "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
          "default" : "none",
          "type" : "string"
        },
        "scheduler-properties" : {
          "description" : "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
          "type" : "string"
        },
        "send-empty-message-when-idle" : {
          "description" : "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
          "default" : "false",
          "type" : "boolean"
        },
        "start-scheduler" : {
          "description" : "Whether the scheduler should be auto started.",
          "default" : "true",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "time-unit" : {
          "description" : "Time unit for initialDelay and delay options.",
          "default" : "MILLISECONDS",
          "enum" : [ "NANOSECONDS", "MICROSECONDS", "MILLISECONDS", "SECONDS", "MINUTES", "HOURS", "DAYS" ],
          "type" : "string"
        },
        "use-fixed-delay" : {
          "description" : "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
          "default" : "true",
          "type" : "boolean"
        }
      }
    },
    "schematron" : {
      "type" : "object",
      "required" : [ "path" ],
      "properties" : {
        "path" : {
          "description" : "The path to the schematron rules file. Can either be in class path or location in the file system.",
          "type" : "string"
        },
        "abort" : {
          "description" : "Flag to abort the route and throw a schematron validation exception.",
          "default" : "false",
          "type" : "boolean"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "rules" : {
          "description" : "To use the given schematron rules instead of loading from the path",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "uri-resolver" : {
          "description" : "Set the URIResolver to be used for resolving schematron includes in the rules file.",
          "type" : "string"
        }
      }
    },
    "scp" : {
      "type" : "object",
      "properties" : {
        "directory-name" : {
          "description" : "The starting directory",
          "type" : "string"
        },
        "host" : {
          "description" : "Hostname of the FTP server",
          "type" : "string"
        },
        "port" : {
          "description" : "Port of the FTP server",
          "type" : "integer"
        },
        "allow-null-body" : {
          "description" : "Used to specify if a null body is allowed during file writing. If set to true then an empty file will be created, when set to false, and attempting to send a null body to the file component, a GenericFileWriteException of 'Cannot write null body to file.' will be thrown. If the fileExist option is set to 'Override', then the file will be truncated, and if set to append the file will remain unchanged.",
          "default" : "false",
          "type" : "boolean"
        },
        "chmod" : {
          "description" : "Allows you to set chmod on the stored file. For example chmod=664.",
          "default" : "664",
          "type" : "string"
        },
        "ciphers" : {
          "description" : "Set a comma separated list of ciphers that will be used in order of preference. Possible cipher names are defined by JCraft JSCH. Some examples include: aes128-ctr,aes128-cbc,3des-ctr,3des-cbc,blowfish-cbc,aes192-cbc,aes256-cbc. If not specified the default list from JSCH will be used.",
          "type" : "string"
        },
        "connect-timeout" : {
          "description" : "Sets the connect timeout for waiting for a connection to be established Used by both FTPClient and JSCH",
          "default" : "10000",
          "type" : "string"
        },
        "disconnect" : {
          "description" : "Whether or not to disconnect from remote FTP server right after use. Disconnect will only disconnect the current connection to the FTP server. If you have a consumer which you want to stop, then you need to stop the consumer/route instead.",
          "default" : "false",
          "type" : "boolean"
        },
        "disconnect-on-batch-complete" : {
          "description" : "Whether or not to disconnect from remote FTP server right after a Batch upload is complete. disconnectOnBatchComplete will only disconnect the current connection to the FTP server.",
          "default" : "false",
          "type" : "boolean"
        },
        "file-name" : {
          "description" : "Use Expression such as File Language to dynamically set the filename. For consumers, it's used as a filename filter. For producers, it's used to evaluate the filename to write. If an expression is set, it take precedence over the CamelFileName header. (Note: The header itself can also be an Expression). The expression options support both String and Expression types. If the expression is a String type, it is always evaluated using the File Language. If the expression is an Expression type, the specified Expression type is used - this allows you, for instance, to use OGNL expressions. For the consumer, you can use it to filter filenames, so you can for instance consume today's file using the File Language syntax: mydata-${date:now:yyyyMMdd}.txt. The producers support the CamelOverruleFileName header which takes precedence over any existing CamelFileName header; the CamelOverruleFileName is a header that is used only once, and makes it easier as this avoids to temporary store CamelFileName and have to restore it afterwards.",
          "type" : "string"
        },
        "flatten" : {
          "description" : "Flatten is used to flatten the file name path to strip any leading paths, so it's just the file name. This allows you to consume recursively into sub-directories, but when you eg write the files to another directory they will be written in a single directory. Setting this to true on the producer enforces that any file name in CamelFileName header will be stripped for any leading paths.",
          "default" : "false",
          "type" : "boolean"
        },
        "jail-starting-directory" : {
          "description" : "Used for jailing (restricting) writing files to the starting directory (and sub) only. This is enabled by default to not allow Camel to write files to outside directories (to be more secured out of the box). You can turn this off to allow writing files to directories outside the starting directory, such as parent or root folders.",
          "default" : "true",
          "type" : "boolean"
        },
        "known-hosts-file" : {
          "description" : "Sets the known_hosts file, so that the jsch endpoint can do host key verification. You can prefix with classpath: to load the file from classpath instead of file system.",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "move-existing-file-strategy" : {
          "description" : "Strategy (Custom Strategy) used to move file with special naming token to use when fileExist=Move is configured. By default, there is an implementation used if no custom strategy is provided",
          "type" : "string"
        },
        "password" : {
          "description" : "Password to use for login",
          "type" : "string"
        },
        "preferred-authentications" : {
          "description" : "Set a comma separated list of authentications that will be used in order of preference. Possible authentication methods are defined by JCraft JSCH. Some examples include: gssapi-with-mic,publickey,keyboard-interactive,password If not specified the JSCH and/or system defaults will be used.",
          "type" : "string"
        },
        "private-key-bytes" : {
          "description" : "Set the private key bytes to that the endpoint can do private key verification. This must be used only if privateKeyFile wasn't set. Otherwise the file will have the priority.",
          "type" : "string"
        },
        "private-key-file" : {
          "description" : "Set the private key file to that the endpoint can do private key verification. You can prefix with classpath: to load the file from classpath instead of file system.",
          "type" : "string"
        },
        "private-key-file-passphrase" : {
          "description" : "Set the private key file passphrase to that the endpoint can do private key verification.",
          "type" : "string"
        },
        "so-timeout" : {
          "description" : "Sets the so timeout FTP and FTPS Only for Camel 2.4. SFTP for Camel 2.14.3/2.15.3/2.16 onwards. Is the SocketOptions.SO_TIMEOUT value in millis. Recommended option is to set this to 300000 so as not have a hanged connection. On SFTP this option is set as timeout on the JSCH Session instance.",
          "default" : "5m",
          "type" : "string"
        },
        "strict-host-key-checking" : {
          "description" : "Sets whether to use strict host key checking. Possible values are: no, yes",
          "default" : "no",
          "enum" : [ "no", "yes" ],
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "timeout" : {
          "description" : "Sets the data timeout for waiting for reply Used only by FTPClient",
          "default" : "30s",
          "type" : "string"
        },
        "use-user-known-hosts-file" : {
          "description" : "If knownHostFile has not been explicit configured, then use the host file from System.getProperty(user.home) /.ssh/known_hosts",
          "default" : "true",
          "type" : "boolean"
        },
        "username" : {
          "description" : "Username to use for login",
          "type" : "string"
        }
      },
      "required" : [ "host" ]
    },
    "seda" : {
      "type" : "object",
      "required" : [ "name" ],
      "properties" : {
        "name" : {
          "description" : "Name of queue",
          "type" : "string"
        },
        "block-when-full" : {
          "description" : "Whether a thread that sends messages to a full SEDA queue will block until the queue's capacity is no longer exhausted. By default, an exception will be thrown stating that the queue is full. By enabling this option, the calling thread will instead block and wait until the message can be accepted.",
          "default" : "false",
          "type" : "boolean"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "concurrent-consumers" : {
          "description" : "Number of concurrent threads processing exchanges.",
          "default" : "1",
          "type" : "integer"
        },
        "discard-if-no-consumers" : {
          "description" : "Whether the producer should discard the message (do not add the message to the queue), when sending to a queue with no active consumers. Only one of the options discardIfNoConsumers and failIfNoConsumers can be enabled at the same time.",
          "default" : "false",
          "type" : "boolean"
        },
        "discard-when-full" : {
          "description" : "Whether a thread that sends messages to a full SEDA queue will be discarded. By default, an exception will be thrown stating that the queue is full. By enabling this option, the calling thread will give up sending and continue, meaning that the message was not sent to the SEDA queue.",
          "default" : "false",
          "type" : "boolean"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "fail-if-no-consumers" : {
          "description" : "Whether the producer should fail by throwing an exception, when sending to a queue with no active consumers. Only one of the options discardIfNoConsumers and failIfNoConsumers can be enabled at the same time.",
          "default" : "false",
          "type" : "boolean"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "limit-concurrent-consumers" : {
          "description" : "Whether to limit the number of concurrentConsumers to the maximum of 500. By default, an exception will be thrown if an endpoint is configured with a greater number. You can disable that check by turning this option off.",
          "default" : "true",
          "type" : "boolean"
        },
        "multiple-consumers" : {
          "description" : "Specifies whether multiple consumers are allowed. If enabled, you can use SEDA for Publish-Subscribe messaging. That is, you can send a message to the SEDA queue and have each consumer receive a copy of the message. When enabled, this option should be specified on every consumer endpoint.",
          "default" : "false",
          "type" : "boolean"
        },
        "offer-timeout" : {
          "description" : "offerTimeout (in milliseconds) can be added to the block case when queue is full. You can disable timeout by using 0 or a negative value.",
          "type" : "string"
        },
        "poll-timeout" : {
          "description" : "The timeout used when polling. When a timeout occurs, the consumer can check whether it is allowed to continue running. Setting a lower value allows the consumer to react more quickly upon shutdown.",
          "default" : "1000",
          "type" : "integer"
        },
        "purge-when-stopping" : {
          "description" : "Whether to purge the task queue when stopping the consumer/route. This allows to stop faster, as any pending messages on the queue is discarded.",
          "default" : "false",
          "type" : "boolean"
        },
        "queue" : {
          "description" : "Define the queue instance which will be used by the endpoint",
          "type" : "string"
        },
        "size" : {
          "description" : "The maximum capacity of the SEDA queue (i.e., the number of messages it can hold). Will by default use the defaultSize set on the SEDA component.",
          "default" : "1000",
          "type" : "integer"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "timeout" : {
          "description" : "Timeout (in milliseconds) before a SEDA producer will stop waiting for an asynchronous task to complete. You can disable timeout by using 0 or a negative value.",
          "default" : "30000",
          "type" : "string"
        },
        "wait-for-task-to-complete" : {
          "description" : "Option to specify whether the caller should wait for the async task to complete or not before continuing. The following three options are supported: Always, Never or IfReplyExpected. The first two values are self-explanatory. The last value, IfReplyExpected, will only wait if the message is Request Reply based. The default option is IfReplyExpected.",
          "default" : "IfReplyExpected",
          "enum" : [ "Never", "IfReplyExpected", "Always" ],
          "type" : "string"
        }
      }
    },
    "service" : {
      "type" : "object",
      "required" : [ "delegateUri" ],
      "properties" : {
        "delegate-uri" : {
          "description" : "The endpoint uri to expose as service",
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "servicenow" : {
      "type" : "object",
      "required" : [ "instanceName", "password", "userName" ],
      "properties" : {
        "instance-name" : {
          "description" : "The ServiceNow instance name",
          "type" : "string"
        },
        "api-url" : {
          "description" : "The ServiceNow REST API url",
          "type" : "string"
        },
        "api-version" : {
          "description" : "The ServiceNow REST API version, default latest",
          "type" : "string"
        },
        "date-format" : {
          "description" : "The date format used for Json serialization/deserialization",
          "default" : "yyyy-MM-dd",
          "type" : "string"
        },
        "date-time-format" : {
          "description" : "The date-time format used for Json serialization/deserialization",
          "default" : "yyyy-MM-dd HH:mm:ss",
          "type" : "string"
        },
        "display" : {
          "description" : "Set this parameter to true to return only scorecards where the indicator Display field is selected. Set this parameter to all to return scorecards with any Display field value. This parameter is true by default.",
          "default" : "true",
          "enum" : [ "false", "true", "all" ],
          "type" : "string"
        },
        "display-value" : {
          "description" : "Return the display value (true), actual value (false), or both (all) for reference fields (default: false)",
          "default" : "false",
          "enum" : [ "false", "true", "all" ],
          "type" : "string"
        },
        "exclude-reference-link" : {
          "description" : "True to exclude Table API links for reference fields (default: false)",
          "type" : "boolean"
        },
        "favorites" : {
          "description" : "Set this parameter to true to return only scorecards that are favorites of the querying user.",
          "type" : "boolean"
        },
        "http-client-policy" : {
          "description" : "To configure http-client",
          "type" : "string"
        },
        "include-aggregates" : {
          "description" : "Set this parameter to true to always return all available aggregates for an indicator, including when an aggregate has already been applied. If a value is not specified, this parameter defaults to false and returns no aggregates.",
          "type" : "boolean"
        },
        "include-available-aggregates" : {
          "description" : "Set this parameter to true to return all available aggregates for an indicator when no aggregate has been applied. If a value is not specified, this parameter defaults to false and returns no aggregates.",
          "type" : "boolean"
        },
        "include-available-breakdowns" : {
          "description" : "Set this parameter to true to return all available breakdowns for an indicator. If a value is not specified, this parameter defaults to false and returns no breakdowns.",
          "type" : "boolean"
        },
        "include-score-notes" : {
          "description" : "Set this parameter to true to return all notes associated with the score. The note element contains the note text as well as the author and timestamp when the note was added.",
          "type" : "boolean"
        },
        "include-scores" : {
          "description" : "Set this parameter to true to return all scores for a scorecard. If a value is not specified, this parameter defaults to false and returns only the most recent score value.",
          "type" : "boolean"
        },
        "input-display-value" : {
          "description" : "True to set raw value of input fields (default: false)",
          "type" : "boolean"
        },
        "key" : {
          "description" : "Set this parameter to true to return only scorecards for key indicators.",
          "type" : "boolean"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "mapper" : {
          "description" : "Sets Jackson's ObjectMapper to use for request/reply",
          "type" : "string"
        },
        "models" : {
          "description" : "Defines both request and response models",
          "type" : "string"
        },
        "oauth-client-id" : {
          "description" : "OAuth2 ClientID",
          "type" : "string"
        },
        "oauth-client-secret" : {
          "description" : "OAuth2 ClientSecret",
          "type" : "string"
        },
        "oauth-token-url" : {
          "description" : "OAuth token Url",
          "type" : "string"
        },
        "password" : {
          "description" : "ServiceNow account password, MUST be provided",
          "type" : "string"
        },
        "per-page" : {
          "description" : "Enter the maximum number of scorecards each query can return. By default this value is 10, and the maximum is 100.",
          "default" : "10",
          "type" : "integer"
        },
        "proxy-authorization-policy" : {
          "description" : "To configure proxy authentication",
          "type" : "string"
        },
        "proxy-host" : {
          "description" : "The proxy host name",
          "type" : "string"
        },
        "proxy-password" : {
          "description" : "Password for proxy authentication",
          "type" : "string"
        },
        "proxy-port" : {
          "description" : "The proxy port number",
          "type" : "integer"
        },
        "proxy-user-name" : {
          "description" : "Username for proxy authentication",
          "type" : "string"
        },
        "release" : {
          "description" : "The ServiceNow release to target, default to Helsinki See https://docs.servicenow.com",
          "default" : "HELSINKI",
          "enum" : [ "FUJI", "GENEVA", "HELSINKI" ],
          "type" : "string"
        },
        "request-models" : {
          "description" : "Defines the request model",
          "type" : "string"
        },
        "resource" : {
          "description" : "The default resource, can be overridden by header CamelServiceNowResource",
          "type" : "string"
        },
        "response-models" : {
          "description" : "Defines the response model",
          "type" : "string"
        },
        "retrieve-target-record-on-import" : {
          "description" : "Set this parameter to true to retrieve the target record when using import set api. The import set result is then replaced by the target record",
          "default" : "false",
          "type" : "boolean"
        },
        "sort-by" : {
          "description" : "Specify the value to use when sorting results. By default, queries sort records by value.",
          "enum" : [ "value", "change", "changeperc", "gap", "gapperc", "duedate", "name", "order", "default", "group", "indicator_group", "frequency", "target", "date", "trend", "bullet", "direction" ],
          "type" : "string"
        },
        "sort-dir" : {
          "description" : "Specify the sort direction, ascending or descending. By default, queries sort records in descending order. Use sysparm_sortdir=asc to sort in ascending order.",
          "enum" : [ "asc", "desc" ],
          "type" : "string"
        },
        "ssl-context-parameters" : {
          "description" : "To configure security using SSLContextParameters. See http://camel.apache.org/camel-configuration-utilities.html",
          "type" : "string"
        },
        "suppress-auto-sys-field" : {
          "description" : "True to suppress auto generation of system fields (default: false)",
          "type" : "boolean"
        },
        "suppress-pagination-header" : {
          "description" : "Set this value to true to remove the Link header from the response. The Link header allows you to request additional pages of data when the number of records matching your query exceeds the query limit",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "table" : {
          "description" : "The default table, can be overridden by header CamelServiceNowTable",
          "type" : "string"
        },
        "target" : {
          "description" : "Set this parameter to true to return only scorecards that have a target.",
          "type" : "boolean"
        },
        "time-format" : {
          "description" : "The time format used for Json serialization/deserialization",
          "default" : "HH:mm:ss",
          "type" : "string"
        },
        "top-level-only" : {
          "description" : "Gets only those categories whose parent is a catalog.",
          "type" : "boolean"
        },
        "user-name" : {
          "description" : "ServiceNow user account name, MUST be provided",
          "type" : "string"
        }
      }
    },
    "servlet" : {
      "type" : "object",
      "required" : [ "contextPath" ],
      "properties" : {
        "context-path" : {
          "description" : "The context-path to use",
          "type" : "string"
        },
        "async" : {
          "description" : "Configure the consumer to work in async mode",
          "default" : "false",
          "type" : "boolean"
        },
        "attachment-multipart-binding" : {
          "description" : "Whether to automatic bind multipart/form-data as attachments on the Camel Exchange. The options attachmentMultipartBinding=true and disableStreamCache=false cannot work together. Remove disableStreamCache to use AttachmentMultipartBinding. This is turn off by default as this may require servlet specific configuration to enable this when using Servlet's.",
          "default" : "false",
          "type" : "boolean"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "chunked" : {
          "description" : "If this option is false the Servlet will disable the HTTP streaming and set the content-length header on the response",
          "default" : "true",
          "type" : "boolean"
        },
        "disable-stream-cache" : {
          "description" : "Determines whether or not the raw input stream from Servlet is cached or not (Camel will read the stream into a in memory/overflow to file, Stream caching) cache. By default Camel will cache the Servlet input stream to support reading it multiple times to ensure it Camel can retrieve all data from the stream. However you can set this option to true when you for example need to access the raw stream, such as streaming it directly to a file or other persistent store. DefaultHttpBinding will copy the request input stream into a stream cache and put it into message body if this option is false to support reading the stream multiple times. If you use Servlet to bridge/proxy an endpoint then consider enabling this option to improve performance, in case you do not need to read the message payload multiple times. The http producer will by default cache the response body stream. If setting this option to true, then the producers will not cache the response body stream but use the response stream as-is as the message body.",
          "default" : "false",
          "type" : "boolean"
        },
        "eager-check-content-available" : {
          "description" : "Whether to eager check whether the HTTP requests has content if the content-length header is 0 or not present. This can be turned on in case HTTP clients do not send streamed data.",
          "default" : "false",
          "type" : "boolean"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "file-name-ext-whitelist" : {
          "description" : "Whitelist of accepted filename extensions for accepting uploaded files. Multiple extensions can be separated by comma, such as txt,xml.",
          "type" : "string"
        },
        "header-filter-strategy" : {
          "description" : "To use a custom HeaderFilterStrategy to filter header to and from Camel message.",
          "type" : "string"
        },
        "http-binding" : {
          "description" : "To use a custom HttpBinding to control the mapping between Camel message and HttpClient.",
          "type" : "string"
        },
        "http-method-restrict" : {
          "description" : "Used to only allow consuming if the HttpMethod matches, such as GET/POST/PUT etc. Multiple methods can be specified separated by comma.",
          "type" : "string"
        },
        "map-http-message-body" : {
          "description" : "If this option is true then IN exchange Body of the exchange will be mapped to HTTP body. Setting this to false will avoid the HTTP mapping.",
          "default" : "true",
          "type" : "boolean"
        },
        "map-http-message-form-url-encoded-body" : {
          "description" : "If this option is true then IN exchange Form Encoded body of the exchange will be mapped to HTTP. Setting this to false will avoid the HTTP Form Encoded body mapping.",
          "default" : "true",
          "type" : "boolean"
        },
        "map-http-message-headers" : {
          "description" : "If this option is true then IN exchange Headers of the exchange will be mapped to HTTP headers. Setting this to false will avoid the HTTP Headers mapping.",
          "default" : "true",
          "type" : "boolean"
        },
        "match-on-uri-prefix" : {
          "description" : "Whether or not the consumer should try to find a target consumer by matching the URI prefix if no exact match is found.",
          "default" : "false",
          "type" : "boolean"
        },
        "mute-exception" : {
          "description" : "If enabled and an Exchange failed processing on the consumer side the response's body won't contain the exception's stack trace.",
          "default" : "false",
          "type" : "boolean"
        },
        "options-enabled" : {
          "description" : "Specifies whether to enable HTTP OPTIONS for this Servlet consumer. By default OPTIONS is turned off.",
          "default" : "false",
          "type" : "boolean"
        },
        "response-buffer-size" : {
          "description" : "To use a custom buffer size on the javax.servlet.ServletResponse.",
          "type" : "integer"
        },
        "servlet-name" : {
          "description" : "Name of the servlet to use",
          "default" : "CamelServlet",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "trace-enabled" : {
          "description" : "Specifies whether to enable HTTP TRACE for this Servlet consumer. By default TRACE is turned off.",
          "default" : "false",
          "type" : "boolean"
        },
        "transfer-exception" : {
          "description" : "If enabled and an Exchange failed processing on the consumer side, and if the caused Exception was send back serialized in the response as a application/x-java-serialized-object content type. On the producer side the exception will be deserialized and thrown as is, instead of the HttpOperationFailedException. The caused exception is required to be serialized. This is by default turned off. If you enable this then be aware that Java will deserialize the incoming data from the request to Java and that can be a potential security risk.",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "sftp" : {
      "type" : "object",
      "properties" : {
        "directory-name" : {
          "description" : "The starting directory",
          "type" : "string"
        },
        "host" : {
          "description" : "Hostname of the FTP server",
          "type" : "string"
        },
        "port" : {
          "description" : "Port of the FTP server",
          "type" : "integer"
        },
        "allow-null-body" : {
          "description" : "Used to specify if a null body is allowed during file writing. If set to true then an empty file will be created, when set to false, and attempting to send a null body to the file component, a GenericFileWriteException of 'Cannot write null body to file.' will be thrown. If the fileExist option is set to 'Override', then the file will be truncated, and if set to append the file will remain unchanged.",
          "default" : "false",
          "type" : "boolean"
        },
        "ant-exclude" : {
          "description" : "Ant style filter exclusion. If both antInclude and antExclude are used, antExclude takes precedence over antInclude. Multiple exclusions may be specified in comma-delimited format.",
          "type" : "string"
        },
        "ant-filter-case-sensitive" : {
          "description" : "Sets case sensitive flag on ant filter.",
          "default" : "true",
          "type" : "boolean"
        },
        "ant-include" : {
          "description" : "Ant style filter inclusion. Multiple inclusions may be specified in comma-delimited format.",
          "type" : "string"
        },
        "auto-create" : {
          "description" : "Automatically create missing directories in the file's pathname. For the file consumer, that means creating the starting directory. For the file producer, it means the directory the files should be written to.",
          "default" : "true",
          "type" : "boolean"
        },
        "backoff-error-threshold" : {
          "description" : "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-idle-threshold" : {
          "description" : "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-multiplier" : {
          "description" : "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
          "type" : "integer"
        },
        "binary" : {
          "description" : "Specifies the file transfer mode, BINARY or ASCII. Default is ASCII (false).",
          "default" : "false",
          "type" : "boolean"
        },
        "bind-address" : {
          "description" : "Specifies the address of the local interface against which the connection should bind.",
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "bulk-requests" : {
          "description" : "Specifies how many requests may be outstanding at any one time. Increasing this value may slightly improve file transfer speed but will increase memory usage.",
          "type" : "integer"
        },
        "charset" : {
          "description" : "This option is used to specify the encoding of the file. You can use this on the consumer, to specify the encodings of the files, which allow Camel to know the charset it should load the file content in case the file content is being accessed. Likewise when writing a file, you can use this option to specify which charset to write the file as well. Do mind that when writing the file Camel may have to read the message content into memory to be able to convert the data into the configured charset, so do not use this if you have big messages.",
          "type" : "string"
        },
        "chmod" : {
          "description" : "Allows you to set chmod on the stored file. For example chmod=640.",
          "type" : "string"
        },
        "ciphers" : {
          "description" : "Set a comma separated list of ciphers that will be used in order of preference. Possible cipher names are defined by JCraft JSCH. Some examples include: aes128-ctr,aes128-cbc,3des-ctr,3des-cbc,blowfish-cbc,aes192-cbc,aes256-cbc. If not specified the default list from JSCH will be used.",
          "type" : "string"
        },
        "compression" : {
          "description" : "To use compression. Specify a level from 1 to 10. Important: You must manually add the needed JSCH zlib JAR to the classpath for compression support.",
          "type" : "integer"
        },
        "connect-timeout" : {
          "description" : "Sets the connect timeout for waiting for a connection to be established Used by both FTPClient and JSCH",
          "default" : "10000",
          "type" : "string"
        },
        "delay" : {
          "description" : "Milliseconds before the next poll.",
          "default" : "500",
          "type" : "integer"
        },
        "delete" : {
          "description" : "If true, the file will be deleted after it is processed successfully.",
          "default" : "false",
          "type" : "boolean"
        },
        "disconnect" : {
          "description" : "Whether or not to disconnect from remote FTP server right after use. Disconnect will only disconnect the current connection to the FTP server. If you have a consumer which you want to stop, then you need to stop the consumer/route instead.",
          "default" : "false",
          "type" : "boolean"
        },
        "disconnect-on-batch-complete" : {
          "description" : "Whether or not to disconnect from remote FTP server right after a Batch upload is complete. disconnectOnBatchComplete will only disconnect the current connection to the FTP server.",
          "default" : "false",
          "type" : "boolean"
        },
        "done-file-name" : {
          "description" : "Producer: If provided, then Camel will write a 2nd done file when the original file has been written. The done file will be empty. This option configures what file name to use. Either you can specify a fixed name. Or you can use dynamic placeholders. The done file will always be written in the same folder as the original file. Consumer: If provided, Camel will only consume files if a done file exists. This option configures what file name to use. Either you can specify a fixed name. Or you can use dynamic placeholders.The done file is always expected in the same folder as the original file. Only ${file.name} and ${file.name.next} is supported as dynamic placeholders.",
          "type" : "string"
        },
        "download" : {
          "description" : "Whether the FTP consumer should download the file. If this option is set to false, then the message body will be null, but the consumer will still trigger a Camel Exchange that has details about the file such as file name, file size, etc. It's just that the file will not be downloaded.",
          "default" : "false",
          "type" : "boolean"
        },
        "eager-delete-target-file" : {
          "description" : "Whether or not to eagerly delete any existing target file. This option only applies when you use fileExists=Override and the tempFileName option as well. You can use this to disable (set it to false) deleting the target file before the temp file is written. For example you may write big files and want the target file to exists during the temp file is being written. This ensure the target file is only deleted until the very last moment, just before the temp file is being renamed to the target filename. This option is also used to control whether to delete any existing files when fileExist=Move is enabled, and an existing file exists. If this option copyAndDeleteOnRenameFails false, then an exception will be thrown if an existing file existed, if its true, then the existing file is deleted before the move operation.",
          "default" : "true",
          "type" : "boolean"
        },
        "eager-max-messages-per-poll" : {
          "description" : "Allows for controlling whether the limit from maxMessagesPerPoll is eager or not. If eager then the limit is during the scanning of files. Where as false would scan all files, and then perform sorting. Setting this option to false allows for sorting all files first, and then limit the poll. Mind that this requires a higher memory usage as all file details are in memory to perform the sorting.",
          "default" : "true",
          "type" : "boolean"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "exclude" : {
          "description" : "Is used to exclude files, if filename matches the regex pattern (matching is case in-senstive). Notice if you use symbols such as plus sign and others you would need to configure this using the RAW() syntax if configuring this as an endpoint uri. See more details at configuring endpoint uris",
          "type" : "string"
        },
        "exclusive-read-lock-strategy" : {
          "description" : "Pluggable read-lock as a org.apache.camel.component.file.GenericFileExclusiveReadLockStrategy implementation.",
          "type" : "string"
        },
        "exist-dir-check-using-ls" : {
          "description" : "Whether to check for existing directory using LS command or CD. By default LS is used which is safer as otherwise Camel needs to change the directory back after checking. However LS has been reported to cause a problem on windows system in some situations and therefore you can disable this option to use CD.",
          "default" : "true",
          "type" : "boolean"
        },
        "fast-exists-check" : {
          "description" : "If set this option to be true, camel-ftp will use the list file directly to check if the file exists. Since some FTP server may not support to list the file directly, if the option is false, camel-ftp will use the old way to list the directory and check if the file exists. This option also influences readLock=changed to control whether it performs a fast check to update file information or not. This can be used to speed up the process if the FTP server has a lot of files.",
          "default" : "false",
          "type" : "boolean"
        },
        "file-exist" : {
          "description" : "What to do if a file already exists with the same name. Override, which is the default, replaces the existing file. - Append - adds content to the existing file. - Fail - throws a GenericFileOperationException, indicating that there is already an existing file. - Ignore - silently ignores the problem and does not override the existing file, but assumes everything is okay. - Move - option requires to use the moveExisting option to be configured as well. The option eagerDeleteTargetFile can be used to control what to do if an moving the file, and there exists already an existing file, otherwise causing the move operation to fail. The Move option will move any existing files, before writing the target file. - TryRename is only applicable if tempFileName option is in use. This allows to try renaming the file from the temporary name to the actual name, without doing any exists check. This check may be faster on some file systems and especially FTP servers.",
          "default" : "Override",
          "enum" : [ "Override", "Append", "Fail", "Ignore", "Move", "TryRename" ],
          "type" : "string"
        },
        "file-name" : {
          "description" : "Use Expression such as File Language to dynamically set the filename. For consumers, it's used as a filename filter. For producers, it's used to evaluate the filename to write. If an expression is set, it take precedence over the CamelFileName header. (Note: The header itself can also be an Expression). The expression options support both String and Expression types. If the expression is a String type, it is always evaluated using the File Language. If the expression is an Expression type, the specified Expression type is used - this allows you, for instance, to use OGNL expressions. For the consumer, you can use it to filter filenames, so you can for instance consume today's file using the File Language syntax: mydata-${date:now:yyyyMMdd}.txt. The producers support the CamelOverruleFileName header which takes precedence over any existing CamelFileName header; the CamelOverruleFileName is a header that is used only once, and makes it easier as this avoids to temporary store CamelFileName and have to restore it afterwards.",
          "type" : "string"
        },
        "filter" : {
          "description" : "Pluggable filter as a org.apache.camel.component.file.GenericFileFilter class. Will skip files if filter returns false in its accept() method.",
          "type" : "string"
        },
        "filter-directory" : {
          "description" : "Filters the directory based on Simple language. For example to filter on current date, you can use a simple date pattern such as ${date:now:yyyMMdd}",
          "type" : "string"
        },
        "filter-file" : {
          "description" : "Filters the file based on Simple language. For example to filter on file size, you can use ${file:size} 5000",
          "type" : "string"
        },
        "flatten" : {
          "description" : "Flatten is used to flatten the file name path to strip any leading paths, so it's just the file name. This allows you to consume recursively into sub-directories, but when you eg write the files to another directory they will be written in a single directory. Setting this to true on the producer enforces that any file name in CamelFileName header will be stripped for any leading paths.",
          "default" : "false",
          "type" : "boolean"
        },
        "greedy" : {
          "description" : "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
          "default" : "false",
          "type" : "boolean"
        },
        "idempotent" : {
          "description" : "Option to use the Idempotent Consumer EIP pattern to let Camel skip already processed files. Will by default use a memory based LRUCache that holds 1000 entries. If noop=true then idempotent will be enabled as well to avoid consuming the same files over and over again.",
          "default" : "false",
          "type" : "boolean"
        },
        "idempotent-key" : {
          "description" : "To use a custom idempotent key. By default the absolute path of the file is used. You can use the File Language, for example to use the file name and file size, you can do: idempotentKey=${file:name}-${file:size}",
          "type" : "string"
        },
        "idempotent-repository" : {
          "description" : "A pluggable repository org.apache.camel.spi.IdempotentRepository which by default use MemoryMessageIdRepository if none is specified and idempotent is true.",
          "type" : "string"
        },
        "ignore-file-not-found-or-permission-error" : {
          "description" : "Whether to ignore when (trying to list files in directories or when downloading a file), which does not exist or due to permission error. By default when a directory or file does not exists or insufficient permission, then an exception is thrown. Setting this option to true allows to ignore that instead.",
          "default" : "false",
          "type" : "boolean"
        },
        "in-progress-repository" : {
          "description" : "A pluggable in-progress repository org.apache.camel.spi.IdempotentRepository. The in-progress repository is used to account the current in progress files being consumed. By default a memory based repository is used.",
          "type" : "string"
        },
        "include" : {
          "description" : "Is used to include files, if filename matches the regex pattern (matching is case in-sensitive). Notice if you use symbols such as plus sign and others you would need to configure this using the RAW() syntax if configuring this as an endpoint uri. See more details at configuring endpoint uris",
          "type" : "string"
        },
        "initial-delay" : {
          "description" : "Milliseconds before the first poll starts.",
          "default" : "1000",
          "type" : "integer"
        },
        "jail-starting-directory" : {
          "description" : "Used for jailing (restricting) writing files to the starting directory (and sub) only. This is enabled by default to not allow Camel to write files to outside directories (to be more secured out of the box). You can turn this off to allow writing files to directories outside the starting directory, such as parent or root folders.",
          "default" : "true",
          "type" : "boolean"
        },
        "jsch-logging-level" : {
          "description" : "The logging level to use for JSCH activity logging. As JSCH is verbose at by default at INFO level the threshold is WARN by default.",
          "default" : "WARN",
          "enum" : [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ],
          "type" : "string"
        },
        "keep-last-modified" : {
          "description" : "Will keep the last modified timestamp from the source file (if any). Will use the Exchange.FILE_LAST_MODIFIED header to located the timestamp. This header can contain either a java.util.Date or long with the timestamp. If the timestamp exists and the option is enabled it will set this timestamp on the written file. Note: This option only applies to the file producer. You cannot use this option with any of the ftp producers.",
          "default" : "false",
          "type" : "boolean"
        },
        "key-pair" : {
          "description" : "Sets a key pair of the public and private key so to that the SFTP endpoint can do public/private key verification.",
          "type" : "string"
        },
        "known-hosts" : {
          "description" : "Sets the known_hosts from the byte array, so that the SFTP endpoint can do host key verification.",
          "type" : "string"
        },
        "known-hosts-file" : {
          "description" : "Sets the known_hosts file, so that the SFTP endpoint can do host key verification.",
          "type" : "string"
        },
        "known-hosts-uri" : {
          "description" : "Sets the known_hosts file (loaded from classpath by default), so that the SFTP endpoint can do host key verification.",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "local-work-directory" : {
          "description" : "When consuming, a local work directory can be used to store the remote file content directly in local files, to avoid loading the content into memory. This is beneficial, if you consume a very big remote file and thus can conserve memory.",
          "type" : "string"
        },
        "max-depth" : {
          "description" : "The maximum depth to traverse when recursively processing a directory.",
          "default" : "2147483647",
          "type" : "integer"
        },
        "max-messages-per-poll" : {
          "description" : "To define a maximum messages to gather per poll. By default no maximum is set. Can be used to set a limit of e.g. 1000 to avoid when starting up the server that there are thousands of files. Set a value of 0 or negative to disabled it. Notice: If this option is in use then the File and FTP components will limit before any sorting. For example if you have 100000 files and use maxMessagesPerPoll=500, then only the first 500 files will be picked up, and then sorted. You can use the eagerMaxMessagesPerPoll option and set this to false to allow to scan all files first and then sort afterwards.",
          "type" : "integer"
        },
        "maximum-reconnect-attempts" : {
          "description" : "Specifies the maximum reconnect attempts Camel performs when it tries to connect to the remote FTP server. Use 0 to disable this behavior.",
          "type" : "integer"
        },
        "min-depth" : {
          "description" : "The minimum depth to start processing when recursively processing a directory. Using minDepth=1 means the base directory. Using minDepth=2 means the first sub directory.",
          "type" : "integer"
        },
        "move" : {
          "description" : "Expression (such as Simple Language) used to dynamically set the filename when moving it after processing. To move files into a .done subdirectory just enter .done.",
          "type" : "string"
        },
        "move-existing" : {
          "description" : "Expression (such as File Language) used to compute file name to use when fileExist=Move is configured. To move files into a backup subdirectory just enter backup. This option only supports the following File Language tokens: file:name, file:name.ext, file:name.noext, file:onlyname, file:onlyname.noext, file:ext, and file:parent. Notice the file:parent is not supported by the FTP component, as the FTP component can only move any existing files to a relative directory based on current dir as base.",
          "type" : "string"
        },
        "move-existing-file-strategy" : {
          "description" : "Strategy (Custom Strategy) used to move file with special naming token to use when fileExist=Move is configured. By default, there is an implementation used if no custom strategy is provided",
          "type" : "string"
        },
        "move-failed" : {
          "description" : "Sets the move failure expression based on Simple language. For example, to move files into a .error subdirectory use: .error. Note: When moving the files to the fail location Camel will handle the error and will not pick up the file again.",
          "type" : "string"
        },
        "noop" : {
          "description" : "If true, the file is not moved or deleted in any way. This option is good for readonly data, or for ETL type requirements. If noop=true, Camel will set idempotent=true as well, to avoid consuming the same files over and over again.",
          "default" : "false",
          "type" : "boolean"
        },
        "on-completion-exception-handler" : {
          "description" : "To use a custom org.apache.camel.spi.ExceptionHandler to handle any thrown exceptions that happens during the file on completion process where the consumer does either a commit or rollback. The default implementation will log any exception at WARN level and ignore.",
          "type" : "string"
        },
        "passive-mode" : {
          "description" : "Sets passive mode connections. Default is active mode connections.",
          "default" : "false",
          "type" : "boolean"
        },
        "password" : {
          "description" : "Password to use for login",
          "type" : "string"
        },
        "poll-strategy" : {
          "description" : "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
          "type" : "string"
        },
        "pre-move" : {
          "description" : "Expression (such as File Language) used to dynamically set the filename when moving it before processing. For example to move in-progress files into the order directory set this value to order.",
          "type" : "string"
        },
        "pre-sort" : {
          "description" : "When pre-sort is enabled then the consumer will sort the file and directory names during polling, that was retrieved from the file system. You may want to do this in case you need to operate on the files in a sorted order. The pre-sort is executed before the consumer starts to filter, and accept files to process by Camel. This option is default=false meaning disabled.",
          "default" : "false",
          "type" : "boolean"
        },
        "preferred-authentications" : {
          "description" : "Set the preferred authentications which SFTP endpoint will used. Some example include:password,publickey. If not specified the default list from JSCH will be used.",
          "type" : "string"
        },
        "private-key" : {
          "description" : "Set the private key as byte so that the SFTP endpoint can do private key verification.",
          "type" : "string"
        },
        "private-key-file" : {
          "description" : "Set the private key file so that the SFTP endpoint can do private key verification.",
          "type" : "string"
        },
        "private-key-passphrase" : {
          "description" : "Set the private key file passphrase so that the SFTP endpoint can do private key verification.",
          "type" : "string"
        },
        "private-key-uri" : {
          "description" : "Set the private key file (loaded from classpath by default) so that the SFTP endpoint can do private key verification.",
          "type" : "string"
        },
        "process-strategy" : {
          "description" : "A pluggable org.apache.camel.component.file.GenericFileProcessStrategy allowing you to implement your own readLock option or similar. Can also be used when special conditions must be met before a file can be consumed, such as a special ready file exists. If this option is set then the readLock option does not apply.",
          "type" : "string"
        },
        "proxy" : {
          "description" : "To use a custom configured com.jcraft.jsch.Proxy. This proxy is used to consume/send messages from the target SFTP host.",
          "type" : "string"
        },
        "read-lock" : {
          "description" : "Used by consumer, to only poll the files if it has exclusive read-lock on the file (i.e. the file is not in-progress or being written). Camel will wait until the file lock is granted. This option provides the build in strategies: - none - No read lock is in use - markerFile - Camel creates a marker file (fileName.camelLock) and then holds a lock on it. This option is not available for the FTP component - changed - Changed is using file length/modification timestamp to detect whether the file is currently being copied or not. Will at least use 1 sec to determine this, so this option cannot consume files as fast as the others, but can be more reliable as the JDK IO API cannot always determine whether a file is currently being used by another process. The option readLockCheckInterval can be used to set the check frequency. - fileLock - is for using java.nio.channels.FileLock. This option is not avail for Windows OS and the FTP component. This approach should be avoided when accessing a remote file system via a mount/share unless that file system supports distributed file locks. - rename - rename is for using a try to rename the file as a test if we can get exclusive read-lock. - idempotent - (only for file component) idempotent is for using a idempotentRepository as the read-lock. This allows to use read locks that supports clustering if the idempotent repository implementation supports that. - idempotent-changed - (only for file component) idempotent-changed is for using a idempotentRepository and changed as the combined read-lock. This allows to use read locks that supports clustering if the idempotent repository implementation supports that. - idempotent-rename - (only for file component) idempotent-rename is for using a idempotentRepository and rename as the combined read-lock. This allows to use read locks that supports clustering if the idempotent repository implementation supports that.Notice: The various read locks is not all suited to work in clustered mode, where concurrent consumers on different nodes is competing for the same files on a shared file system. The markerFile using a close to atomic operation to create the empty marker file, but its not guaranteed to work in a cluster. The fileLock may work better but then the file system need to support distributed file locks, and so on. Using the idempotent read lock can support clustering if the idempotent repository supports clustering, such as Hazelcast Component or Infinispan.",
          "default" : "none",
          "enum" : [ "none", "markerFile", "fileLock", "rename", "changed", "idempotent", "idempotent-changed", "idempotent-rename" ],
          "type" : "string"
        },
        "read-lock-check-interval" : {
          "description" : "Interval in millis for the read-lock, if supported by the read lock. This interval is used for sleeping between attempts to acquire the read lock. For example when using the changed read lock, you can set a higher interval period to cater for slow writes. The default of 1 sec. may be too fast if the producer is very slow writing the file. Notice: For FTP the default readLockCheckInterval is 5000. The readLockTimeout value must be higher than readLockCheckInterval, but a rule of thumb is to have a timeout that is at least 2 or more times higher than the readLockCheckInterval. This is needed to ensure that amble time is allowed for the read lock process to try to grab the lock before the timeout was hit.",
          "default" : "1000",
          "type" : "integer"
        },
        "read-lock-delete-orphan-lock-files" : {
          "description" : "Whether or not read lock with marker files should upon startup delete any orphan read lock files, which may have been left on the file system, if Camel was not properly shutdown (such as a JVM crash). If turning this option to false then any orphaned lock file will cause Camel to not attempt to pickup that file, this could also be due another node is concurrently reading files from the same shared directory.",
          "default" : "true",
          "type" : "boolean"
        },
        "read-lock-idempotent-release-async" : {
          "description" : "Whether the delayed release task should be synchronous or asynchronous. See more details at the readLockIdempotentReleaseDelay option.",
          "default" : "false",
          "type" : "boolean"
        },
        "read-lock-idempotent-release-async-pool-size" : {
          "description" : "The number of threads in the scheduled thread pool when using asynchronous release tasks. Using a default of 1 core threads should be sufficient in almost all use-cases, only set this to a higher value if either updating the idempotent repository is slow, or there are a lot of files to process. This option is not in-use if you use a shared thread pool by configuring the readLockIdempotentReleaseExecutorService option. See more details at the readLockIdempotentReleaseDelay option.",
          "type" : "integer"
        },
        "read-lock-idempotent-release-delay" : {
          "description" : "Whether to delay the release task for a period of millis. This can be used to delay the release tasks to expand the window when a file is regarded as read-locked, in an active/active cluster scenario with a shared idempotent repository, to ensure other nodes cannot potentially scan and acquire the same file, due to race-conditions. By expanding the time-window of the release tasks helps prevents these situations. Note delaying is only needed if you have configured readLockRemoveOnCommit to true.",
          "type" : "integer"
        },
        "read-lock-idempotent-release-executor-service" : {
          "description" : "To use a custom and shared thread pool for asynchronous release tasks. See more details at the readLockIdempotentReleaseDelay option.",
          "type" : "string"
        },
        "read-lock-logging-level" : {
          "description" : "Logging level used when a read lock could not be acquired. By default a DEBUG is logged. You can change this level, for example to OFF to not have any logging. This option is only applicable for readLock of types: changed, fileLock, idempotent, idempotent-changed, idempotent-rename, rename.",
          "default" : "DEBUG",
          "enum" : [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ],
          "type" : "string"
        },
        "read-lock-marker-file" : {
          "description" : "Whether to use marker file with the changed, rename, or exclusive read lock types. By default a marker file is used as well to guard against other processes picking up the same files. This behavior can be turned off by setting this option to false. For example if you do not want to write marker files to the file systems by the Camel application.",
          "default" : "true",
          "type" : "boolean"
        },
        "read-lock-min-age" : {
          "description" : "This option is applied only for readLock=changed. It allows to specify a minimum age the file must be before attempting to acquire the read lock. For example use readLockMinAge=300s to require the file is at last 5 minutes old. This can speedup the changed read lock as it will only attempt to acquire files which are at least that given age.",
          "default" : "0",
          "type" : "integer"
        },
        "read-lock-min-length" : {
          "description" : "This option is applied only for readLock=changed. It allows you to configure a minimum file length. By default Camel expects the file to contain data, and thus the default value is 1. You can set this option to zero, to allow consuming zero-length files.",
          "default" : "1",
          "type" : "integer"
        },
        "read-lock-remove-on-commit" : {
          "description" : "This option is applied only for readLock=idempotent. It allows to specify whether to remove the file name entry from the idempotent repository when processing the file is succeeded and a commit happens. By default the file is not removed which ensures that any race-condition do not occur so another active node may attempt to grab the file. Instead the idempotent repository may support eviction strategies that you can configure to evict the file name entry after X minutes - this ensures no problems with race conditions. See more details at the readLockIdempotentReleaseDelay option.",
          "default" : "false",
          "type" : "boolean"
        },
        "read-lock-remove-on-rollback" : {
          "description" : "This option is applied only for readLock=idempotent. It allows to specify whether to remove the file name entry from the idempotent repository when processing the file failed and a rollback happens. If this option is false, then the file name entry is confirmed (as if the file did a commit).",
          "default" : "true",
          "type" : "boolean"
        },
        "read-lock-timeout" : {
          "description" : "Optional timeout in millis for the read-lock, if supported by the read-lock. If the read-lock could not be granted and the timeout triggered, then Camel will skip the file. At next poll Camel, will try the file again, and this time maybe the read-lock could be granted. Use a value of 0 or lower to indicate forever. Currently fileLock, changed and rename support the timeout. Notice: For FTP the default readLockTimeout value is 20000 instead of 10000. The readLockTimeout value must be higher than readLockCheckInterval, but a rule of thumb is to have a timeout that is at least 2 or more times higher than the readLockCheckInterval. This is needed to ensure that amble time is allowed for the read lock process to try to grab the lock before the timeout was hit.",
          "default" : "10000",
          "type" : "integer"
        },
        "reconnect-delay" : {
          "description" : "Delay in millis Camel will wait before performing a reconnect attempt.",
          "type" : "string"
        },
        "recursive" : {
          "description" : "If a directory, will look for files in all the sub-directories as well.",
          "default" : "false",
          "type" : "boolean"
        },
        "repeat-count" : {
          "description" : "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
          "default" : "0",
          "type" : "integer"
        },
        "run-logging-level" : {
          "description" : "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
          "default" : "TRACE",
          "enum" : [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ],
          "type" : "string"
        },
        "scheduled-executor-service" : {
          "description" : "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
          "type" : "string"
        },
        "scheduler" : {
          "description" : "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
          "default" : "none",
          "type" : "string"
        },
        "scheduler-properties" : {
          "description" : "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
          "type" : "string"
        },
        "send-empty-message-when-idle" : {
          "description" : "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
          "default" : "false",
          "type" : "boolean"
        },
        "send-noop" : {
          "description" : "Whether to send a noop command as a pre-write check before uploading files to the FTP server. This is enabled by default as a validation of the connection is still valid, which allows to silently re-connect to be able to upload the file. However if this causes problems, you can turn this option off.",
          "default" : "true",
          "type" : "boolean"
        },
        "separator" : {
          "description" : "Sets the path separator to be used. UNIX = Uses unix style path separator Windows = Uses windows style path separator Auto = (is default) Use existing path separator in file name",
          "default" : "UNIX",
          "enum" : [ "UNIX", "Windows", "Auto" ],
          "type" : "string"
        },
        "server-alive-count-max" : {
          "description" : "Sets the number of keep-alive messages which may be sent without receiving any messages back from the server. If this threshold is reached while keep-alive messages are being sent, the connection will be disconnected. The default value is one.",
          "default" : "1",
          "type" : "integer"
        },
        "server-alive-interval" : {
          "description" : "Sets the interval (millis) to send a keep-alive message. If zero is specified, any keep-alive message must not be sent. The default interval is zero.",
          "type" : "integer"
        },
        "shuffle" : {
          "description" : "To shuffle the list of files (sort in random order)",
          "default" : "false",
          "type" : "boolean"
        },
        "so-timeout" : {
          "description" : "Sets the so timeout FTP and FTPS Only for Camel 2.4. SFTP for Camel 2.14.3/2.15.3/2.16 onwards. Is the SocketOptions.SO_TIMEOUT value in millis. Recommended option is to set this to 300000 so as not have a hanged connection. On SFTP this option is set as timeout on the JSCH Session instance.",
          "default" : "5m",
          "type" : "string"
        },
        "sort-by" : {
          "description" : "Built-in sort by using the File Language. Supports nested sorts, so you can have a sort by file name and as a 2nd group sort by modified date.",
          "type" : "string"
        },
        "sorter" : {
          "description" : "Pluggable sorter as a java.util.Comparator class.",
          "type" : "string"
        },
        "start-scheduler" : {
          "description" : "Whether the scheduler should be auto started.",
          "default" : "true",
          "type" : "boolean"
        },
        "stepwise" : {
          "description" : "Sets whether we should stepwise change directories while traversing file structures when downloading files, or as well when uploading a file to a directory. You can disable this if you for example are in a situation where you cannot change directory on the FTP server due security reasons. Stepwise cannot be used together with streamDownload.",
          "default" : "true",
          "type" : "boolean"
        },
        "stream-download" : {
          "description" : "Sets the download method to use when not using a local working directory. If set to true, the remote files are streamed to the route as they are read. When set to false, the remote files are loaded into memory before being sent into the route. If enabling this option then you must set stepwise=false as both cannot be enabled at the same time.",
          "default" : "false",
          "type" : "boolean"
        },
        "strict-host-key-checking" : {
          "description" : "Sets whether to use strict host key checking.",
          "default" : "no",
          "enum" : [ "no", "yes" ],
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "temp-file-name" : {
          "description" : "The same as tempPrefix option but offering a more fine grained control on the naming of the temporary filename as it uses the File Language. The location for tempFilename is relative to the final file location in the option 'fileName', not the target directory in the base uri. For example if option fileName includes a directory prefix: dir/finalFilename then tempFileName is relative to that subdirectory dir.",
          "type" : "string"
        },
        "temp-prefix" : {
          "description" : "This option is used to write the file using a temporary name and then, after the write is complete, rename it to the real name. Can be used to identify files being written and also avoid consumers (not using exclusive read locks) reading in progress files. Is often used by FTP when uploading big files.",
          "type" : "string"
        },
        "throw-exception-on-connect-failed" : {
          "description" : "Should an exception be thrown if connection failed (exhausted) By default exception is not thrown and a WARN is logged. You can use this to enable exception being thrown and handle the thrown exception from the org.apache.camel.spi.PollingConsumerPollStrategy rollback method.",
          "default" : "false",
          "type" : "boolean"
        },
        "time-unit" : {
          "description" : "Time unit for initialDelay and delay options.",
          "default" : "MILLISECONDS",
          "enum" : [ "NANOSECONDS", "MICROSECONDS", "MILLISECONDS", "SECONDS", "MINUTES", "HOURS", "DAYS" ],
          "type" : "string"
        },
        "timeout" : {
          "description" : "Sets the data timeout for waiting for reply Used only by FTPClient",
          "default" : "30s",
          "type" : "string"
        },
        "use-fixed-delay" : {
          "description" : "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
          "default" : "true",
          "type" : "boolean"
        },
        "use-list" : {
          "description" : "Whether to allow using LIST command when downloading a file. Default is true. In some use cases you may want to download a specific file and are not allowed to use the LIST command, and therefore you can set this option to false. Notice when using this option, then the specific file to download does not include meta-data information such as file size, timestamp, permissions etc, because those information is only possible to retrieve when LIST command is in use.",
          "default" : "true",
          "type" : "boolean"
        },
        "use-user-known-hosts-file" : {
          "description" : "If knownHostFile has not been explicit configured then use the host file from System.getProperty(user.home)/.ssh/known_hosts",
          "default" : "true",
          "type" : "boolean"
        },
        "username" : {
          "description" : "Username to use for login",
          "type" : "string"
        }
      },
      "required" : [ "host" ]
    },
    "sip" : {
      "type" : "object",
      "required" : [ "uri" ],
      "properties" : {
        "uri" : {
          "description" : "URI of the SIP server to connect to (the username and password can be included such as: john:secretmyserver:9999)",
          "type" : "string"
        },
        "address-factory" : {
          "description" : "To use a custom AddressFactory",
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "cache-connections" : {
          "description" : "Should connections be cached by the SipStack to reduce cost of connection creation. This is useful if the connection is used for long running conversations.",
          "default" : "false",
          "type" : "boolean"
        },
        "call-id-header" : {
          "description" : "A custom Header object containing call details. Must implement the type javax.sip.header.CallIdHeader",
          "type" : "string"
        },
        "consumer" : {
          "description" : "This setting is used to determine whether the kind of header (FromHeader,ToHeader etc) that needs to be created for this endpoint",
          "default" : "false",
          "type" : "boolean"
        },
        "contact-header" : {
          "description" : "An optional custom Header object containing verbose contact details (email, phone number etc). Must implement the type javax.sip.header.ContactHeader",
          "type" : "string"
        },
        "content-sub-type" : {
          "description" : "Setting for contentSubType can be set to any valid MimeSubType.",
          "default" : "plain",
          "type" : "string"
        },
        "content-type" : {
          "description" : "Setting for contentType can be set to any valid MimeType.",
          "default" : "text",
          "type" : "string"
        },
        "content-type-header" : {
          "description" : "A custom Header object containing message content details. Must implement the type javax.sip.header.ContentTypeHeader",
          "type" : "string"
        },
        "event-header" : {
          "description" : "A custom Header object containing event details. Must implement the type javax.sip.header.EventHeader",
          "type" : "string"
        },
        "event-header-name" : {
          "description" : "Setting for a String based event type.",
          "type" : "string"
        },
        "event-id" : {
          "description" : "Setting for a String based event Id. Mandatory setting unless a registry based FromHeader is specified",
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "expires-header" : {
          "description" : "A custom Header object containing message expiration details. Must implement the type javax.sip.header.ExpiresHeader",
          "type" : "string"
        },
        "extension-header" : {
          "description" : "A custom Header object containing user/application specific details. Must implement the type javax.sip.header.ExtensionHeader",
          "type" : "string"
        },
        "from-header" : {
          "description" : "A custom Header object containing message originator settings. Must implement the type javax.sip.header.FromHeader",
          "type" : "string"
        },
        "from-host" : {
          "description" : "Hostname of the message originator. Mandatory setting unless a registry based FromHeader is specified",
          "type" : "string"
        },
        "from-port" : {
          "description" : "Port of the message originator. Mandatory setting unless a registry based FromHeader is specified",
          "type" : "integer"
        },
        "from-user" : {
          "description" : "Username of the message originator. Mandatory setting unless a registry based custom FromHeader is specified.",
          "type" : "string"
        },
        "header-factory" : {
          "description" : "To use a custom HeaderFactory",
          "type" : "string"
        },
        "implementation-debug-log-file" : {
          "description" : "Name of client debug log file to use for logging",
          "type" : "string"
        },
        "implementation-server-log-file" : {
          "description" : "Name of server log file to use for logging",
          "type" : "string"
        },
        "implementation-trace-level" : {
          "description" : "Logging level for tracing",
          "default" : "0",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "listening-point" : {
          "description" : "To use a custom ListeningPoint implementation",
          "type" : "string"
        },
        "max-forwards" : {
          "description" : "Number of maximum proxy forwards",
          "type" : "integer"
        },
        "max-forwards-header" : {
          "description" : "A custom Header object containing details on maximum proxy forwards. This header places a limit on the viaHeaders possible. Must implement the type javax.sip.header.MaxForwardsHeader",
          "type" : "string"
        },
        "max-message-size" : {
          "description" : "Setting for maximum allowed Message size in bytes.",
          "default" : "1048576",
          "type" : "integer"
        },
        "message-factory" : {
          "description" : "To use a custom MessageFactory",
          "type" : "string"
        },
        "msg-expiration" : {
          "description" : "The amount of time a message received at an endpoint is considered valid",
          "default" : "3600",
          "type" : "integer"
        },
        "presence-agent" : {
          "description" : "This setting is used to distinguish between a Presence Agent & a consumer. This is due to the fact that the SIP Camel component ships with a basic Presence Agent (for testing purposes only). Consumers have to set this flag to true.",
          "default" : "false",
          "type" : "boolean"
        },
        "receive-timeout-millis" : {
          "description" : "Setting for specifying amount of time to wait for a Response and/or Acknowledgement can be received from another SIP stack",
          "default" : "10000",
          "type" : "string"
        },
        "sip-factory" : {
          "description" : "To use a custom SipFactory to create the SipStack to be used",
          "type" : "string"
        },
        "sip-stack" : {
          "description" : "To use a custom SipStack",
          "type" : "string"
        },
        "sip-uri" : {
          "description" : "To use a custom SipURI. If none configured, then the SipUri fallback to use the options toUser toHost:toPort",
          "type" : "string"
        },
        "stack-name" : {
          "description" : "Name of the SIP Stack instance associated with an SIP Endpoint.",
          "default" : "NAME_NOT_SET",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "to-header" : {
          "description" : "A custom Header object containing message receiver settings. Must implement the type javax.sip.header.ToHeader",
          "type" : "string"
        },
        "to-host" : {
          "description" : "Hostname of the message receiver. Mandatory setting unless a registry based ToHeader is specified",
          "type" : "string"
        },
        "to-port" : {
          "description" : "Portname of the message receiver. Mandatory setting unless a registry based ToHeader is specified",
          "type" : "integer"
        },
        "to-user" : {
          "description" : "Username of the message receiver. Mandatory setting unless a registry based custom ToHeader is specified.",
          "type" : "string"
        },
        "transport" : {
          "description" : "Setting for choice of transport protocol. Valid choices are tcp or udp.",
          "default" : "tcp",
          "enum" : [ "tcp", "udp" ],
          "type" : "string"
        },
        "use-router-for-all-uris" : {
          "description" : "This setting is used when requests are sent to the Presence Agent via a proxy.",
          "default" : "false",
          "type" : "boolean"
        },
        "via-headers" : {
          "description" : "List of custom Header objects of the type javax.sip.header.ViaHeader. Each ViaHeader containing a proxy address for request forwarding. (Note this header is automatically updated by each proxy when the request arrives at its listener)",
          "type" : "string"
        }
      }
    },
    "sips" : {
      "type" : "object",
      "$ref" : "#/definitions/sip"
    },
    "sjms" : {
      "type" : "object",
      "required" : [ "destinationName" ],
      "properties" : {
        "destination-name" : {
          "description" : "DestinationName is a JMS queue or topic name. By default, the destinationName is interpreted as a queue name.",
          "type" : "string"
        },
        "destination-type" : {
          "description" : "The kind of destination to use",
          "default" : "queue",
          "enum" : [ "queue", "topic" ],
          "type" : "string"
        },
        "acknowledgement-mode" : {
          "description" : "The JMS acknowledgement name, which is one of: SESSION_TRANSACTED, CLIENT_ACKNOWLEDGE, AUTO_ACKNOWLEDGE, DUPS_OK_ACKNOWLEDGE",
          "default" : "AUTO_ACKNOWLEDGE",
          "enum" : [ "SESSION_TRANSACTED", "CLIENT_ACKNOWLEDGE", "AUTO_ACKNOWLEDGE", "DUPS_OK_ACKNOWLEDGE" ],
          "type" : "string"
        },
        "allow-null-body" : {
          "description" : "Whether to allow sending messages with no body. If this option is false and the message body is null, then an JMSException is thrown.",
          "default" : "true",
          "type" : "boolean"
        },
        "async-start-listener" : {
          "description" : "Whether to startup the consumer message listener asynchronously, when starting a route. For example if a JmsConsumer cannot get a connection to a remote JMS broker, then it may block while retrying and/or failover. This will cause Camel to block while starting routes. By setting this option to true, you will let routes startup, while the JmsConsumer connects to the JMS broker using a dedicated thread in asynchronous mode. If this option is used, then beware that if the connection could not be established, then an exception is logged at WARN level, and the consumer will not be able to receive messages; You can then restart the route to retry.",
          "default" : "false",
          "type" : "boolean"
        },
        "async-stop-listener" : {
          "description" : "Whether to stop the consumer message listener asynchronously, when stopping a route.",
          "default" : "false",
          "type" : "boolean"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "connection-count" : {
          "description" : "The maximum number of connections available to this endpoint",
          "type" : "integer"
        },
        "connection-factory" : {
          "description" : "Initializes the connectionFactory for the endpoint, which takes precedence over the component's connectionFactory, if any",
          "type" : "string"
        },
        "connection-resource" : {
          "description" : "Initializes the connectionResource for the endpoint, which takes precedence over the component's connectionResource, if any",
          "type" : "string"
        },
        "consumer-count" : {
          "description" : "Sets the number of consumer listeners used for this endpoint.",
          "default" : "1",
          "type" : "integer"
        },
        "destination-creation-strategy" : {
          "description" : "To use a custom DestinationCreationStrategy.",
          "type" : "string"
        },
        "durable-subscription-id" : {
          "description" : "Sets the durable subscription Id required for durable topics.",
          "type" : "string"
        },
        "error-handler-log-stack-trace" : {
          "description" : "Allows to control whether stacktraces should be logged or not, by the default errorHandler.",
          "default" : "true",
          "type" : "boolean"
        },
        "error-handler-logging-level" : {
          "description" : "Allows to configure the default errorHandler logging level for logging uncaught exceptions.",
          "default" : "WARN",
          "enum" : [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ],
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exception-listener" : {
          "description" : "Specifies the JMS Exception Listener that is to be notified of any underlying JMS exceptions.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "header-filter-strategy" : {
          "description" : "To use a custom HeaderFilterStrategy to filter header to and from Camel message.",
          "type" : "string"
        },
        "include-all-jmsx-properties" : {
          "description" : "Whether to include all JMSXxxx properties when mapping from JMS to Camel Message. Setting this to true will include properties such as JMSXAppID, and JMSXUserID etc. Note: If you are using a custom headerFilterStrategy then this option does not apply.",
          "default" : "false",
          "type" : "boolean"
        },
        "jms-key-format-strategy" : {
          "description" : "Pluggable strategy for encoding and decoding JMS keys so they can be compliant with the JMS specification. Camel provides two implementations out of the box: default and passthrough. The default strategy will safely marshal dots and hyphens (. and -). The passthrough strategy leaves the key as is. Can be used for JMS brokers which do not care whether JMS header keys contain illegal characters. You can provide your own implementation of the org.apache.camel.component.jms.JmsKeyFormatStrategy and refer to it using the # notation.",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "map-jms-message" : {
          "description" : "Specifies whether Camel should auto map the received JMS message to a suited payload type, such as javax.jms.TextMessage to a String etc. See section about how mapping works below for more details.",
          "default" : "true",
          "type" : "boolean"
        },
        "message-created-strategy" : {
          "description" : "To use the given MessageCreatedStrategy which are invoked when Camel creates new instances of javax.jms.Message objects when Camel is sending a JMS message.",
          "type" : "string"
        },
        "message-selector" : {
          "description" : "Sets the JMS Message selector syntax.",
          "type" : "string"
        },
        "named-reply-to" : {
          "description" : "Sets the reply to destination name used for InOut producer endpoints. The type of the reply to destination can be determined by the starting prefix (topic: or queue:) in its name.",
          "type" : "string"
        },
        "persistent" : {
          "description" : "Flag used to enable/disable message persistence.",
          "default" : "true",
          "type" : "boolean"
        },
        "prefill-pool" : {
          "description" : "Whether to prefill the producer connection pool on startup, or create connections lazy when needed.",
          "default" : "true",
          "type" : "boolean"
        },
        "producer-count" : {
          "description" : "Sets the number of producers used for this endpoint.",
          "default" : "1",
          "type" : "integer"
        },
        "reconnect-back-off" : {
          "description" : "Backoff in millis on consumer pool reconnection attempts",
          "default" : "5000",
          "type" : "string"
        },
        "reconnect-on-error" : {
          "description" : "Try to apply reconnection logic on consumer pool",
          "default" : "true",
          "type" : "boolean"
        },
        "response-time-out" : {
          "description" : "Sets the amount of time we should wait before timing out a InOut response.",
          "default" : "5s",
          "type" : "string"
        },
        "shared-jms-session" : {
          "description" : "Specifies whether to share JMS session with other SJMS endpoints. Turn this off if your route is accessing to multiple JMS providers. If you need transaction against multiple JMS providers, use jms component to leverage XA transaction.",
          "default" : "true",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "true",
          "type" : "boolean"
        },
        "transacted" : {
          "description" : "Specifies whether to use transacted mode",
          "default" : "false",
          "type" : "boolean"
        },
        "transaction-batch-count" : {
          "description" : "If transacted sets the number of messages to process before committing a transaction.",
          "default" : "-1",
          "type" : "integer"
        },
        "transaction-batch-timeout" : {
          "description" : "Sets timeout (in millis) for batch transactions, the value should be 1000 or higher.",
          "default" : "5s",
          "type" : "string"
        },
        "transaction-commit-strategy" : {
          "description" : "Sets the commit strategy.",
          "type" : "string"
        },
        "ttl" : {
          "description" : "Flag used to adjust the Time To Live value of produced messages.",
          "default" : "-1",
          "type" : "string"
        }
      }
    },
    "sjms-batch" : {
      "type" : "object",
      "required" : [ "destinationName", "aggregationStrategy" ],
      "properties" : {
        "destination-name" : {
          "description" : "The destination name. Only queues are supported, names may be prefixed by 'queue:'.",
          "type" : "string"
        },
        "aggregation-strategy" : {
          "description" : "The aggregation strategy to use, which merges all the batched messages into a single message",
          "type" : "string"
        },
        "allow-null-body" : {
          "description" : "Whether to allow sending messages with no body. If this option is false and the message body is null, then an JMSException is thrown.",
          "default" : "true",
          "type" : "boolean"
        },
        "async-start-listener" : {
          "description" : "Whether to startup the consumer message listener asynchronously, when starting a route. For example if a JmsConsumer cannot get a connection to a remote JMS broker, then it may block while retrying and/or failover. This will cause Camel to block while starting routes. By setting this option to true, you will let routes startup, while the JmsConsumer connects to the JMS broker using a dedicated thread in asynchronous mode. If this option is used, then beware that if the connection could not be established, then an exception is logged at WARN level, and the consumer will not be able to receive messages; You can then restart the route to retry.",
          "default" : "false",
          "type" : "boolean"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "completion-interval" : {
          "description" : "The completion interval in millis, which causes batches to be completed in a scheduled fixed rate every interval. The batch may be empty if the timeout triggered and there was no messages in the batch. Notice you cannot use both completion timeout and completion interval at the same time, only one can be configured.",
          "default" : "1000",
          "type" : "integer"
        },
        "completion-predicate" : {
          "description" : "The completion predicate, which causes batches to be completed when the predicate evaluates as true. The predicate can also be configured using the simple language using the string syntax. You may want to set the option eagerCheckCompletion to true to let the predicate match the incoming message, as otherwise it matches the aggregated message.",
          "type" : "string"
        },
        "completion-size" : {
          "description" : "The number of messages consumed at which the batch will be completed",
          "default" : "200",
          "type" : "integer"
        },
        "completion-timeout" : {
          "description" : "The timeout in millis from receipt of the first first message when the batch will be completed. The batch may be empty if the timeout triggered and there was no messages in the batch. Notice you cannot use both completion timeout and completion interval at the same time, only one can be configured.",
          "default" : "500",
          "type" : "integer"
        },
        "consumer-count" : {
          "description" : "The number of JMS sessions to consume from",
          "default" : "1",
          "type" : "integer"
        },
        "eager-check-completion" : {
          "description" : "Use eager completion checking which means that the completionPredicate will use the incoming Exchange. As opposed to without eager completion checking the completionPredicate will use the aggregated Exchange.",
          "default" : "false",
          "type" : "boolean"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "header-filter-strategy" : {
          "description" : "To use a custom HeaderFilterStrategy to filter header to and from Camel message.",
          "type" : "string"
        },
        "include-all-jmsx-properties" : {
          "description" : "Whether to include all JMSXxxx properties when mapping from JMS to Camel Message. Setting this to true will include properties such as JMSXAppID, and JMSXUserID etc. Note: If you are using a custom headerFilterStrategy then this option does not apply.",
          "default" : "false",
          "type" : "boolean"
        },
        "jms-key-format-strategy" : {
          "description" : "Pluggable strategy for encoding and decoding JMS keys so they can be compliant with the JMS specification. Camel provides two implementations out of the box: default and passthrough. The default strategy will safely marshal dots and hyphens (. and -). The passthrough strategy leaves the key as is. Can be used for JMS brokers which do not care whether JMS header keys contain illegal characters. You can provide your own implementation of the org.apache.camel.component.jms.JmsKeyFormatStrategy and refer to it using the # notation.",
          "type" : "string"
        },
        "keep-alive-delay" : {
          "description" : "The delay in millis between attempts to re-establish a valid session. If this is a positive value the SjmsBatchConsumer will attempt to create a new session if it sees an Exception during message consumption. This delay value allows you to pause between attempts to prevent spamming the logs. If this is a negative value then the SjmsBatchConsumer will bail out and the consumer will not stop consuming new messages. The default is 5000 ms, that is, 5 seconds.",
          "default" : "5000",
          "type" : "integer"
        },
        "map-jms-message" : {
          "description" : "Specifies whether Camel should auto map the received JMS message to a suited payload type, such as javax.jms.TextMessage to a String etc. See section about how mapping works below for more details.",
          "default" : "true",
          "type" : "boolean"
        },
        "message-created-strategy" : {
          "description" : "To use the given MessageCreatedStrategy which are invoked when Camel creates new instances of javax.jms.Message objects when Camel is sending a JMS message.",
          "type" : "string"
        },
        "poll-duration" : {
          "description" : "The duration in milliseconds of each poll for messages. completionTimeOut will be used if it is shorter and a batch has started.",
          "default" : "1000",
          "type" : "integer"
        },
        "recovery-interval" : {
          "description" : "Specifies the interval between recovery attempts, i.e. when a connection is being refreshed, in milliseconds. The default is 5000 ms, that is, 5 seconds.",
          "default" : "5000",
          "type" : "integer"
        },
        "send-empty-message-when-idle" : {
          "description" : "If using completion timeout or interval, then the batch may be empty if the timeout triggered and there was no messages in the batch. If this option is true and the batch is empty then an empty message is added to the batch so an empty message is routed.",
          "default" : "false",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "timeout-checker-executor-service" : {
          "description" : "If using the completionInterval option a background thread is created to trigger the completion interval. Set this option to provide a custom thread pool to be used rather than creating a new thread for every consumer.",
          "type" : "string"
        }
      }
    },
    "sjms2" : {
      "type" : "object",
      "required" : [ "destinationName" ],
      "properties" : {
        "destination-name" : {
          "description" : "DestinationName is a JMS queue or topic name. By default, the destinationName is interpreted as a queue name.",
          "type" : "string"
        },
        "destination-type" : {
          "description" : "The kind of destination to use",
          "default" : "queue",
          "enum" : [ "queue", "topic" ],
          "type" : "string"
        },
        "acknowledgement-mode" : {
          "description" : "The JMS acknowledgement name, which is one of: SESSION_TRANSACTED, CLIENT_ACKNOWLEDGE, AUTO_ACKNOWLEDGE, DUPS_OK_ACKNOWLEDGE",
          "default" : "AUTO_ACKNOWLEDGE",
          "enum" : [ "SESSION_TRANSACTED", "CLIENT_ACKNOWLEDGE", "AUTO_ACKNOWLEDGE", "DUPS_OK_ACKNOWLEDGE" ],
          "type" : "string"
        },
        "allow-null-body" : {
          "description" : "Whether to allow sending messages with no body. If this option is false and the message body is null, then an JMSException is thrown.",
          "default" : "true",
          "type" : "boolean"
        },
        "async-start-listener" : {
          "description" : "Whether to startup the consumer message listener asynchronously, when starting a route. For example if a JmsConsumer cannot get a connection to a remote JMS broker, then it may block while retrying and/or failover. This will cause Camel to block while starting routes. By setting this option to true, you will let routes startup, while the JmsConsumer connects to the JMS broker using a dedicated thread in asynchronous mode. If this option is used, then beware that if the connection could not be established, then an exception is logged at WARN level, and the consumer will not be able to receive messages; You can then restart the route to retry.",
          "default" : "false",
          "type" : "boolean"
        },
        "async-stop-listener" : {
          "description" : "Whether to stop the consumer message listener asynchronously, when stopping a route.",
          "default" : "false",
          "type" : "boolean"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "connection-count" : {
          "description" : "The maximum number of connections available to this endpoint",
          "type" : "integer"
        },
        "connection-factory" : {
          "description" : "Initializes the connectionFactory for the endpoint, which takes precedence over the component's connectionFactory, if any",
          "type" : "string"
        },
        "connection-resource" : {
          "description" : "Initializes the connectionResource for the endpoint, which takes precedence over the component's connectionResource, if any",
          "type" : "string"
        },
        "consumer-count" : {
          "description" : "Sets the number of consumer listeners used for this endpoint.",
          "default" : "1",
          "type" : "integer"
        },
        "destination-creation-strategy" : {
          "description" : "To use a custom DestinationCreationStrategy.",
          "type" : "string"
        },
        "durable" : {
          "description" : "Sets topic consumer to durable.",
          "default" : "false",
          "type" : "boolean"
        },
        "durable-subscription-id" : {
          "description" : "Sets the durable subscription Id required for durable topics.",
          "type" : "string"
        },
        "error-handler-log-stack-trace" : {
          "description" : "Allows to control whether stacktraces should be logged or not, by the default errorHandler.",
          "default" : "true",
          "type" : "boolean"
        },
        "error-handler-logging-level" : {
          "description" : "Allows to configure the default errorHandler logging level for logging uncaught exceptions.",
          "default" : "WARN",
          "enum" : [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ],
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exception-listener" : {
          "description" : "Specifies the JMS Exception Listener that is to be notified of any underlying JMS exceptions.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "header-filter-strategy" : {
          "description" : "To use a custom HeaderFilterStrategy to filter header to and from Camel message.",
          "type" : "string"
        },
        "include-all-jmsx-properties" : {
          "description" : "Whether to include all JMSXxxx properties when mapping from JMS to Camel Message. Setting this to true will include properties such as JMSXAppID, and JMSXUserID etc. Note: If you are using a custom headerFilterStrategy then this option does not apply.",
          "default" : "false",
          "type" : "boolean"
        },
        "jms-key-format-strategy" : {
          "description" : "Pluggable strategy for encoding and decoding JMS keys so they can be compliant with the JMS specification. Camel provides two implementations out of the box: default and passthrough. The default strategy will safely marshal dots and hyphens (. and -). The passthrough strategy leaves the key as is. Can be used for JMS brokers which do not care whether JMS header keys contain illegal characters. You can provide your own implementation of the org.apache.camel.component.jms.JmsKeyFormatStrategy and refer to it using the # notation.",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "map-jms-message" : {
          "description" : "Specifies whether Camel should auto map the received JMS message to a suited payload type, such as javax.jms.TextMessage to a String etc. See section about how mapping works below for more details.",
          "default" : "true",
          "type" : "boolean"
        },
        "message-created-strategy" : {
          "description" : "To use the given MessageCreatedStrategy which are invoked when Camel creates new instances of javax.jms.Message objects when Camel is sending a JMS message.",
          "type" : "string"
        },
        "message-selector" : {
          "description" : "Sets the JMS Message selector syntax.",
          "type" : "string"
        },
        "named-reply-to" : {
          "description" : "Sets the reply to destination name used for InOut producer endpoints. The type of the reply to destination can be determined by the starting prefix (topic: or queue:) in its name.",
          "type" : "string"
        },
        "persistent" : {
          "description" : "Flag used to enable/disable message persistence.",
          "default" : "true",
          "type" : "boolean"
        },
        "prefill-pool" : {
          "description" : "Whether to prefill the producer connection pool on startup, or create connections lazy when needed.",
          "default" : "true",
          "type" : "boolean"
        },
        "producer-count" : {
          "description" : "Sets the number of producers used for this endpoint.",
          "default" : "1",
          "type" : "integer"
        },
        "reconnect-back-off" : {
          "description" : "Backoff in millis on consumer pool reconnection attempts",
          "default" : "5000",
          "type" : "string"
        },
        "reconnect-on-error" : {
          "description" : "Try to apply reconnection logic on consumer pool",
          "default" : "true",
          "type" : "boolean"
        },
        "response-time-out" : {
          "description" : "Sets the amount of time we should wait before timing out a InOut response.",
          "default" : "5s",
          "type" : "string"
        },
        "shared" : {
          "description" : "Sets the consumer to shared.",
          "default" : "false",
          "type" : "boolean"
        },
        "shared-jms-session" : {
          "description" : "Specifies whether to share JMS session with other SJMS endpoints. Turn this off if your route is accessing to multiple JMS providers. If you need transaction against multiple JMS providers, use jms component to leverage XA transaction.",
          "default" : "true",
          "type" : "boolean"
        },
        "subscription-id" : {
          "description" : "Sets the subscription Id, required for durable or shared topics.",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "true",
          "type" : "boolean"
        },
        "transacted" : {
          "description" : "Specifies whether to use transacted mode",
          "default" : "false",
          "type" : "boolean"
        },
        "transaction-batch-count" : {
          "description" : "If transacted sets the number of messages to process before committing a transaction.",
          "default" : "-1",
          "type" : "integer"
        },
        "transaction-batch-timeout" : {
          "description" : "Sets timeout (in millis) for batch transactions, the value should be 1000 or higher.",
          "default" : "5s",
          "type" : "string"
        },
        "transaction-commit-strategy" : {
          "description" : "Sets the commit strategy.",
          "type" : "string"
        },
        "ttl" : {
          "description" : "Flag used to adjust the Time To Live value of produced messages.",
          "default" : "-1",
          "type" : "string"
        }
      }
    },
    "slack" : {
      "type" : "object",
      "required" : [ "channel" ],
      "properties" : {
        "channel" : {
          "description" : "The channel name (syntax #name) or slackuser (syntax userName) to send a message directly to an user.",
          "type" : "string"
        },
        "backoff-error-threshold" : {
          "description" : "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-idle-threshold" : {
          "description" : "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-multiplier" : {
          "description" : "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
          "type" : "integer"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "delay" : {
          "description" : "Milliseconds before the next poll.",
          "default" : "500",
          "type" : "integer"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "greedy" : {
          "description" : "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
          "default" : "false",
          "type" : "boolean"
        },
        "icon-emoji" : {
          "description" : "Use a Slack emoji as an avatar",
          "type" : "string"
        },
        "icon-url" : {
          "description" : "The avatar that the component will use when sending message to a channel or user.",
          "type" : "string"
        },
        "initial-delay" : {
          "description" : "Milliseconds before the first poll starts.",
          "default" : "1000",
          "type" : "integer"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "max-results" : {
          "description" : "The Max Result for the poll",
          "default" : "10",
          "type" : "string"
        },
        "poll-strategy" : {
          "description" : "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
          "type" : "string"
        },
        "repeat-count" : {
          "description" : "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
          "default" : "0",
          "type" : "integer"
        },
        "run-logging-level" : {
          "description" : "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
          "default" : "TRACE",
          "enum" : [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ],
          "type" : "string"
        },
        "scheduled-executor-service" : {
          "description" : "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
          "type" : "string"
        },
        "scheduler" : {
          "description" : "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
          "default" : "none",
          "type" : "string"
        },
        "scheduler-properties" : {
          "description" : "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
          "type" : "string"
        },
        "send-empty-message-when-idle" : {
          "description" : "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
          "default" : "false",
          "type" : "boolean"
        },
        "server-url" : {
          "description" : "The Server URL of the Slack instance",
          "default" : "https://slack.com",
          "type" : "string"
        },
        "start-scheduler" : {
          "description" : "Whether the scheduler should be auto started.",
          "default" : "true",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "time-unit" : {
          "description" : "Time unit for initialDelay and delay options.",
          "default" : "MILLISECONDS",
          "enum" : [ "NANOSECONDS", "MICROSECONDS", "MILLISECONDS", "SECONDS", "MINUTES", "HOURS", "DAYS" ],
          "type" : "string"
        },
        "token" : {
          "description" : "The token to use",
          "type" : "string"
        },
        "use-fixed-delay" : {
          "description" : "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
          "default" : "true",
          "type" : "boolean"
        },
        "username" : {
          "description" : "This is the username that the bot will have when sending messages to a channel or user.",
          "type" : "string"
        },
        "webhook-url" : {
          "description" : "The incoming webhook URL",
          "type" : "string"
        }
      }
    },
    "smpp" : {
      "type" : "object",
      "properties" : {
        "host" : {
          "description" : "Hostname for the SMSC server to use.",
          "default" : "localhost",
          "type" : "string"
        },
        "port" : {
          "description" : "Port number for the SMSC server to use.",
          "default" : "2775",
          "type" : "integer"
        },
        "address-range" : {
          "description" : "You can specify the address range for the SmppConsumer as defined in section 5.2.7 of the SMPP 3.4 specification. The SmppConsumer will receive messages only from SMSC's which target an address (MSISDN or IP address) within this range.",
          "type" : "string"
        },
        "alphabet" : {
          "description" : "Defines encoding of data according the SMPP 3.4 specification, section 5.2.19. 0: SMSC Default Alphabet 4: 8 bit Alphabet 8: UCS2 Alphabet",
          "enum" : [ "0", "4", "8" ],
          "type" : "integer"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "data-coding" : {
          "description" : "Defines the data coding according the SMPP 3.4 specification, section 5.2.19. Example data encodings are: 0: SMSC Default Alphabet 3: Latin 1 (ISO-8859-1) 4: Octet unspecified (8-bit binary) 8: UCS2 (ISO/IEC-10646) 13: Extended Kanji JIS(X 0212-1990)",
          "type" : "integer"
        },
        "dest-addr" : {
          "description" : "Defines the destination SME address. For mobile terminated messages, this is the directory number of the recipient MS. Only for SubmitSm, SubmitMulti, CancelSm and DataSm.",
          "default" : "1717",
          "type" : "string"
        },
        "dest-addr-npi" : {
          "description" : "Defines the type of number (TON) to be used in the SME destination address parameters. Only for SubmitSm, SubmitMulti, CancelSm and DataSm. The following NPI values are defined: 0: Unknown 1: ISDN (E163/E164) 2: Data (X.121) 3: Telex (F.69) 6: Land Mobile (E.212) 8: National 9: Private 10: ERMES 13: Internet (IP) 18: WAP Client Id (to be defined by WAP Forum)",
          "enum" : [ "0", "1", "2", "3", "6", "8", "9", "10", "13", "18" ],
          "type" : "integer"
        },
        "dest-addr-ton" : {
          "description" : "Defines the type of number (TON) to be used in the SME destination address parameters. Only for SubmitSm, SubmitMulti, CancelSm and DataSm. The following TON values are defined: 0: Unknown 1: International 2: National 3: Network Specific 4: Subscriber Number 5: Alphanumeric 6: Abbreviated",
          "enum" : [ "0", "1", "2", "3", "4", "5", "6" ],
          "type" : "integer"
        },
        "encoding" : {
          "description" : "Defines the encoding scheme of the short message user data. Only for SubmitSm, ReplaceSm and SubmitMulti.",
          "default" : "ISO-8859-1",
          "type" : "string"
        },
        "enquire-link-timer" : {
          "description" : "Defines the interval in milliseconds between the confidence checks. The confidence check is used to test the communication path between an ESME and an SMSC.",
          "default" : "5000",
          "type" : "integer"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "http-proxy-host" : {
          "description" : "If you need to tunnel SMPP through a HTTP proxy, set this attribute to the hostname or ip address of your HTTP proxy.",
          "type" : "string"
        },
        "http-proxy-password" : {
          "description" : "If your HTTP proxy requires basic authentication, set this attribute to the password required for your HTTP proxy.",
          "type" : "string"
        },
        "http-proxy-port" : {
          "description" : "If you need to tunnel SMPP through a HTTP proxy, set this attribute to the port of your HTTP proxy.",
          "default" : "3128",
          "type" : "integer"
        },
        "http-proxy-username" : {
          "description" : "If your HTTP proxy requires basic authentication, set this attribute to the username required for your HTTP proxy.",
          "type" : "string"
        },
        "initial-reconnect-delay" : {
          "description" : "Defines the initial delay in milliseconds after the consumer/producer tries to reconnect to the SMSC, after the connection was lost.",
          "default" : "5000",
          "type" : "integer"
        },
        "lazy-session-creation" : {
          "description" : "Sessions can be lazily created to avoid exceptions, if the SMSC is not available when the Camel producer is started. Camel will check the in message headers 'CamelSmppSystemId' and 'CamelSmppPassword' of the first exchange. If they are present, Camel will use these data to connect to the SMSC.",
          "default" : "false",
          "type" : "boolean"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "max-reconnect" : {
          "description" : "Defines the maximum number of attempts to reconnect to the SMSC, if SMSC returns a negative bind response",
          "default" : "2147483647",
          "type" : "integer"
        },
        "numbering-plan-indicator" : {
          "description" : "Defines the numeric plan indicator (NPI) to be used in the SME. The following NPI values are defined: 0: Unknown 1: ISDN (E163/E164) 2: Data (X.121) 3: Telex (F.69) 6: Land Mobile (E.212) 8: National 9: Private 10: ERMES 13: Internet (IP) 18: WAP Client Id (to be defined by WAP Forum)",
          "enum" : [ "0", "1", "2", "3", "6", "8", "9", "10", "13", "18" ],
          "type" : "integer"
        },
        "password" : {
          "description" : "The password for connecting to SMSC server.",
          "type" : "string"
        },
        "priority-flag" : {
          "description" : "Allows the originating SME to assign a priority level to the short message. Only for SubmitSm and SubmitMulti. Four Priority Levels are supported: 0: Level 0 (lowest) priority 1: Level 1 priority 2: Level 2 priority 3: Level 3 (highest) priority",
          "enum" : [ "0", "1", "2", "3" ],
          "type" : "integer"
        },
        "protocol-id" : {
          "description" : "The protocol id",
          "type" : "integer"
        },
        "proxy-headers" : {
          "description" : "These headers will be passed to the proxy server while establishing the connection.",
          "type" : "string"
        },
        "reconnect-delay" : {
          "description" : "Defines the interval in milliseconds between the reconnect attempts, if the connection to the SMSC was lost and the previous was not succeed.",
          "default" : "5000",
          "type" : "integer"
        },
        "registered-delivery" : {
          "description" : "Is used to request an SMSC delivery receipt and/or SME originated acknowledgements. The following values are defined: 0: No SMSC delivery receipt requested. 1: SMSC delivery receipt requested where final delivery outcome is success or failure. 2: SMSC delivery receipt requested where the final delivery outcome is delivery failure.",
          "enum" : [ "0", "1", "2" ],
          "type" : "integer"
        },
        "replace-if-present-flag" : {
          "description" : "Used to request the SMSC to replace a previously submitted message, that is still pending delivery. The SMSC will replace an existing message provided that the source address, destination address and service type match the same fields in the new message. The following replace if present flag values are defined: 0: Don't replace 1: Replace",
          "enum" : [ "0", "1" ],
          "type" : "integer"
        },
        "service-type" : {
          "description" : "The service type parameter can be used to indicate the SMS Application service associated with the message. The following generic service_types are defined: CMT: Cellular Messaging CPT: Cellular Paging VMN: Voice Mail Notification VMA: Voice Mail Alerting WAP: Wireless Application Protocol USSD: Unstructured Supplementary Services Data",
          "enum" : [ "CMT", "CPT", "VMN", "VMA", "WAP", "USSD" ],
          "type" : "string"
        },
        "session-state-listener" : {
          "description" : "You can refer to a org.jsmpp.session.SessionStateListener in the Registry to receive callbacks when the session state changed.",
          "type" : "string"
        },
        "source-addr" : {
          "description" : "Defines the address of SME (Short Message Entity) which originated this message.",
          "default" : "1616",
          "type" : "string"
        },
        "source-addr-npi" : {
          "description" : "Defines the numeric plan indicator (NPI) to be used in the SME originator address parameters. The following NPI values are defined: 0: Unknown 1: ISDN (E163/E164) 2: Data (X.121) 3: Telex (F.69) 6: Land Mobile (E.212) 8: National 9: Private 10: ERMES 13: Internet (IP) 18: WAP Client Id (to be defined by WAP Forum)",
          "enum" : [ "0", "1", "2", "3", "6", "8", "9", "10", "13", "18" ],
          "type" : "integer"
        },
        "source-addr-ton" : {
          "description" : "Defines the type of number (TON) to be used in the SME originator address parameters. The following TON values are defined: 0: Unknown 1: International 2: National 3: Network Specific 4: Subscriber Number 5: Alphanumeric 6: Abbreviated",
          "enum" : [ "0", "1", "2", "3", "4", "5", "6" ],
          "type" : "integer"
        },
        "splitting-policy" : {
          "description" : "You can specify a policy for handling long messages: ALLOW - the default, long messages are split to 140 bytes per message TRUNCATE - long messages are split and only the first fragment will be sent to the SMSC. Some carriers drop subsequent fragments so this reduces load on the SMPP connection sending parts of a message that will never be delivered. REJECT - if a message would need to be split, it is rejected with an SMPP NegativeResponseException and the reason code signifying the message is too long.",
          "default" : "ALLOW",
          "enum" : [ "ALLOW", "REJECT", "TRUNCATE" ],
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "system-id" : {
          "description" : "The system id (username) for connecting to SMSC server.",
          "default" : "smppclient",
          "type" : "string"
        },
        "system-type" : {
          "description" : "This parameter is used to categorize the type of ESME (External Short Message Entity) that is binding to the SMSC (max. 13 characters).",
          "type" : "string"
        },
        "transaction-timer" : {
          "description" : "Defines the maximum period of inactivity allowed after a transaction, after which an SMPP entity may assume that the session is no longer active. This timer may be active on either communicating SMPP entity (i.e. SMSC or ESME).",
          "default" : "10000",
          "type" : "integer"
        },
        "type-of-number" : {
          "description" : "Defines the type of number (TON) to be used in the SME. The following TON values are defined: 0: Unknown 1: International 2: National 3: Network Specific 4: Subscriber Number 5: Alphanumeric 6: Abbreviated",
          "enum" : [ "0", "1", "2", "3", "4", "5", "6" ],
          "type" : "integer"
        },
        "using-ssl" : {
          "description" : "Whether using SSL with the smpps protocol",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "smpps" : {
      "type" : "object",
      "$ref" : "#/definitions/smpp"
    },
    "snmp" : {
      "type" : "object",
      "required" : [ "host", "port" ],
      "properties" : {
        "host" : {
          "description" : "Hostname of the SNMP enabled device",
          "type" : "string"
        },
        "port" : {
          "description" : "Port number of the SNMP enabled device",
          "type" : "integer"
        },
        "authentication-passphrase" : {
          "description" : "The authentication passphrase. If not null, authenticationProtocol must also be not null. RFC3414 11.2 requires passphrases to have a minimum length of 8 bytes. If the length of authenticationPassphrase is less than 8 bytes an IllegalArgumentException is thrown.",
          "type" : "string"
        },
        "authentication-protocol" : {
          "description" : "Authentication protocol to use if security level is set to enable authentication The possible values are: MD5, SHA1",
          "enum" : [ "MD5", "SHA1" ],
          "type" : "string"
        },
        "backoff-error-threshold" : {
          "description" : "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-idle-threshold" : {
          "description" : "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-multiplier" : {
          "description" : "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
          "type" : "integer"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "delay" : {
          "description" : "Sets update rate in seconds",
          "default" : "60000",
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "greedy" : {
          "description" : "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
          "default" : "false",
          "type" : "boolean"
        },
        "initial-delay" : {
          "description" : "Milliseconds before the first poll starts.",
          "default" : "1000",
          "type" : "integer"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "oids" : {
          "description" : "Defines which values you are interested in. Please have a look at the Wikipedia to get a better understanding. You may provide a single OID or a coma separated list of OIDs. Example: oids=1.3.6.1.2.1.1.3.0,1.3.6.1.2.1.25.3.2.1.5.1,1.3.6.1.2.1.25.3.5.1.1.1,1.3.6.1.2.1.43.5.1.1.11.1",
          "type" : "string"
        },
        "poll-strategy" : {
          "description" : "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
          "type" : "string"
        },
        "privacy-passphrase" : {
          "description" : "The privacy passphrase. If not null, privacyProtocol must also be not null. RFC3414 11.2 requires passphrases to have a minimum length of 8 bytes. If the length of authenticationPassphrase is less than 8 bytes an IllegalArgumentException is thrown.",
          "type" : "string"
        },
        "privacy-protocol" : {
          "description" : "The privacy protocol ID to be associated with this user. If set to null, this user only supports unencrypted messages.",
          "type" : "string"
        },
        "protocol" : {
          "description" : "Here you can select which protocol to use. You can use either udp or tcp.",
          "default" : "udp",
          "enum" : [ "tcp", "udp" ],
          "type" : "string"
        },
        "repeat-count" : {
          "description" : "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
          "default" : "0",
          "type" : "integer"
        },
        "retries" : {
          "description" : "Defines how often a retry is made before canceling the request.",
          "default" : "2",
          "type" : "integer"
        },
        "run-logging-level" : {
          "description" : "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
          "default" : "TRACE",
          "enum" : [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ],
          "type" : "string"
        },
        "scheduled-executor-service" : {
          "description" : "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
          "type" : "string"
        },
        "scheduler" : {
          "description" : "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
          "default" : "none",
          "type" : "string"
        },
        "scheduler-properties" : {
          "description" : "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
          "type" : "string"
        },
        "security-level" : {
          "description" : "Sets the security level for this target. The supplied security level must be supported by the security model dependent information associated with the security name set for this target. The value 1 means: No authentication and no encryption. Anyone can create and read messages with this security level The value 2 means: Authentication and no encryption. Only the one with the right authentication key can create messages with this security level, but anyone can read the contents of the message. The value 3 means: Authentication and encryption. Only the one with the right authentication key can create messages with this security level, and only the one with the right encryption/decryption key can read the contents of the message.",
          "default" : "3",
          "enum" : [ "1", "2", "3" ],
          "type" : "integer"
        },
        "security-name" : {
          "description" : "Sets the security name to be used with this target.",
          "type" : "string"
        },
        "send-empty-message-when-idle" : {
          "description" : "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
          "default" : "false",
          "type" : "boolean"
        },
        "snmp-community" : {
          "description" : "Sets the community octet string for the snmp request.",
          "default" : "public",
          "type" : "string"
        },
        "snmp-context-engine-id" : {
          "description" : "Sets the context engine ID field of the scoped PDU.",
          "type" : "string"
        },
        "snmp-context-name" : {
          "description" : "Sets the context name field of this scoped PDU.",
          "type" : "string"
        },
        "snmp-version" : {
          "description" : "Sets the snmp version for the request. The value 0 means SNMPv1, 1 means SNMPv2c, and the value 3 means SNMPv3",
          "default" : "0",
          "enum" : [ "0", "1", "3" ],
          "type" : "integer"
        },
        "start-scheduler" : {
          "description" : "Whether the scheduler should be auto started.",
          "default" : "true",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "time-unit" : {
          "description" : "Time unit for initialDelay and delay options.",
          "default" : "MILLISECONDS",
          "enum" : [ "NANOSECONDS", "MICROSECONDS", "MILLISECONDS", "SECONDS", "MINUTES", "HOURS", "DAYS" ],
          "type" : "string"
        },
        "timeout" : {
          "description" : "Sets the timeout value for the request in millis.",
          "default" : "1500",
          "type" : "integer"
        },
        "tree-list" : {
          "description" : "Sets the flag whether the scoped PDU will be displayed as the list if it has child elements in its tree",
          "default" : "false",
          "type" : "boolean"
        },
        "type" : {
          "description" : "Which operation to perform such as poll, trap, etc.",
          "enum" : [ "TRAP", "POLL", "GET_NEXT" ],
          "type" : "string"
        },
        "use-fixed-delay" : {
          "description" : "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
          "default" : "true",
          "type" : "boolean"
        }
      }
    },
    "solr" : {
      "type" : "object",
      "required" : [ "url" ],
      "properties" : {
        "url" : {
          "description" : "Hostname and port for the solr server",
          "type" : "string"
        },
        "allow-compression" : {
          "description" : "Server side must support gzip or deflate for this to have any effect",
          "type" : "boolean"
        },
        "collection" : {
          "description" : "Set the collection name which the solrCloud server could use",
          "type" : "string"
        },
        "connection-timeout" : {
          "description" : "connectionTimeout on the underlying HttpConnectionManager",
          "type" : "integer"
        },
        "default-max-connections-per-host" : {
          "description" : "maxConnectionsPerHost on the underlying HttpConnectionManager",
          "type" : "integer"
        },
        "follow-redirects" : {
          "description" : "indicates whether redirects are used to get to the Solr server",
          "type" : "boolean"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "max-retries" : {
          "description" : "Maximum number of retries to attempt in the event of transient errors",
          "type" : "integer"
        },
        "max-total-connections" : {
          "description" : "maxTotalConnection on the underlying HttpConnectionManager",
          "type" : "integer"
        },
        "password" : {
          "description" : "Sets password for basic auth plugin enabled servers",
          "type" : "string"
        },
        "request-handler" : {
          "description" : "Set the request handler to be used",
          "type" : "string"
        },
        "so-timeout" : {
          "description" : "Read timeout on the underlying HttpConnectionManager. This is desirable for queries, but probably not for indexing",
          "type" : "integer"
        },
        "streaming-queue-size" : {
          "description" : "Set the queue size for the StreamingUpdateSolrServer",
          "default" : "10",
          "type" : "integer"
        },
        "streaming-thread-count" : {
          "description" : "Set the number of threads for the StreamingUpdateSolrServer",
          "default" : "2",
          "type" : "integer"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "username" : {
          "description" : "Sets username for basic auth plugin enabled servers",
          "type" : "string"
        },
        "zk-host" : {
          "description" : "Set the ZooKeeper host information which the solrCloud could use, such as zkhost=localhost:8123.",
          "type" : "string"
        }
      }
    },
    "solrs" : {
      "type" : "object",
      "$ref" : "#/definitions/solr"
    },
    "solrCloud" : {
      "type" : "object",
      "$ref" : "#/definitions/solr"
    },
    "soroush" : {
      "type" : "object",
      "required" : [ "action" ],
      "properties" : {
        "action" : {
          "description" : "The action to do.",
          "enum" : [ "sendMessage", "getMessage", "uploadFile", "downloadFile" ],
          "type" : "string"
        },
        "authorization-token" : {
          "description" : "The authorization token for using the bot. if uri path does not contain authorization token, this token will be used.",
          "type" : "string"
        },
        "auto-download" : {
          "description" : "Automatically download SoroushMessage.fileUrl and SoroushMessage.thumbnailUrl if exists for the message and store them in SoroushMessage.file and SoroushMessage.thumbnail field",
          "default" : "false",
          "type" : "boolean"
        },
        "auto-upload-file" : {
          "description" : "Automatically upload attachments when a message goes to the sendMessage endpoint and the SoroushMessage.file (SoroushMessage.thumbnail) has been set and SoroushMessage.fileUrl(SoroushMessage.thumbnailUrl) is null",
          "default" : "true",
          "type" : "boolean"
        },
        "back-off-strategy" : {
          "description" : "The strategy to backoff in case of connection failure. Currently 3 strategies are supported: 1. Exponential (default): It multiply retryWaitingTime by retryExponentialCoefficient after each connection failure. 2. Linear: It increase retryWaitingTime by retryLinearIncrement after each connection failure. 3. Fixed: Always use retryWaitingTime as the time between retries.",
          "default" : "Exponential",
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "concurrent-consumers" : {
          "description" : "Number of Thread created by consumer in the route. if you use this method for parallelism, it is guaranteed that messages from same user always execute in the same thread and therefore messages from the same user are processed sequentially. Default value notice: using SoroushBotSingleThreadConsumer",
          "default" : "1",
          "type" : "integer"
        },
        "connection-timeout" : {
          "description" : "Connection timeout in ms when connecting to soroush API",
          "default" : "30000",
          "type" : "integer"
        },
        "download-thumbnail" : {
          "description" : "If true, when downloading an attached file, thumbnail will be downloaded if provided in the message. Otherwise, only the file will be downloaded",
          "default" : "true",
          "type" : "boolean"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "force-download" : {
          "description" : "Force to download SoroushMessage.fileUrl(SoroushMessage.thumbnailUrl) if exists, even if the SoroushMessage.file(SoroushMessage.thumbnail) was not null in that message",
          "default" : "false",
          "type" : "boolean"
        },
        "force-upload" : {
          "description" : "Force to upload SoroushMessage.file(SoroushMessage.thumbnail) if exists, even if the SoroushMessage.fileUrl(SoroushMessage.thumbnailUrl) is not null in the message",
          "default" : "false",
          "type" : "boolean"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "max-connection-retry" : {
          "description" : "Maximum connection retry when fail to connect to soroush API, if the quota is reached, MaximumConnectionRetryReachedException is thrown for that message.",
          "default" : "4",
          "type" : "integer"
        },
        "max-retry-waiting-time" : {
          "description" : "Maximum amount of time (in millisecond) a thread wait before retrying failed request.",
          "default" : "3600000",
          "type" : "string"
        },
        "queue-capacity-per-thread" : {
          "description" : "Maximum capacity of each queue when concurrentConsumers is greater than 1. if a queue become full, every message that should go to that queue will be dropped. If bridgeErrorHandler is set to true, an exchange with CongestionException is directed to ErrorHandler. You can then processed the error using onException(CongestionException.class) route. Default value notice: infinite capacity",
          "default" : "0",
          "type" : "integer"
        },
        "reconnect-idle-connection-timeout" : {
          "description" : "The timeout in millisecond to reconnect the existing getMessage connection to ensure that the connection is always live and does not dead without notifying the bot. this value should not be changed.",
          "default" : "300000",
          "type" : "string"
        },
        "retry-exponential-coefficient" : {
          "description" : "Coefficient to compute back off time when using Exponential Back Off strategy",
          "default" : "2",
          "type" : "string"
        },
        "retry-linear-increment" : {
          "description" : "The amount of time (in millisecond) which adds to waiting time when using Linear back off strategy",
          "default" : "10000",
          "type" : "string"
        },
        "retry-waiting-time" : {
          "description" : "Waiting time before retry failed request (Millisecond). If backOffStrategy is not Fixed this is the based value for computing back off waiting time. the first retry is always happen immediately after failure and retryWaitingTime do not apply to the first retry.",
          "default" : "1000",
          "type" : "integer"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "spark" : {
      "type" : "object",
      "required" : [ "endpointType" ],
      "properties" : {
        "endpoint-type" : {
          "description" : "Type of the endpoint (rdd, dataframe, hive).",
          "enum" : [ "rdd", "dataframe", "hive" ],
          "type" : "string"
        },
        "collect" : {
          "description" : "Indicates if results should be collected or counted.",
          "default" : "true",
          "type" : "boolean"
        },
        "data-frame" : {
          "description" : "DataFrame to compute against.",
          "type" : "string"
        },
        "data-frame-callback" : {
          "description" : "Function performing action against an DataFrame.",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "rdd" : {
          "description" : "RDD to compute against.",
          "type" : "string"
        },
        "rdd-callback" : {
          "description" : "Function performing action against an RDD.",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "splunk" : {
      "type" : "object",
      "required" : [ "name" ],
      "properties" : {
        "name" : {
          "description" : "Name has no purpose",
          "type" : "string"
        },
        "app" : {
          "description" : "Splunk app",
          "type" : "string"
        },
        "backoff-error-threshold" : {
          "description" : "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-idle-threshold" : {
          "description" : "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-multiplier" : {
          "description" : "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
          "type" : "integer"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "connection-timeout" : {
          "description" : "Timeout in MS when connecting to Splunk server",
          "default" : "5000",
          "type" : "integer"
        },
        "count" : {
          "description" : "A number that indicates the maximum number of entities to return.",
          "type" : "integer"
        },
        "delay" : {
          "description" : "Milliseconds before the next poll.",
          "default" : "500",
          "type" : "integer"
        },
        "earliest-time" : {
          "description" : "Earliest time of the search time window.",
          "type" : "string"
        },
        "event-host" : {
          "description" : "Override the default Splunk event host field",
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "greedy" : {
          "description" : "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
          "default" : "false",
          "type" : "boolean"
        },
        "host" : {
          "description" : "Splunk host.",
          "default" : "localhost",
          "type" : "string"
        },
        "index" : {
          "description" : "Splunk index to write to",
          "type" : "string"
        },
        "init-earliest-time" : {
          "description" : "Initial start offset of the first search",
          "type" : "string"
        },
        "initial-delay" : {
          "description" : "Milliseconds before the first poll starts.",
          "default" : "1000",
          "type" : "integer"
        },
        "latest-time" : {
          "description" : "Latest time of the search time window.",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "owner" : {
          "description" : "Splunk owner",
          "type" : "string"
        },
        "password" : {
          "description" : "Password for Splunk",
          "type" : "string"
        },
        "poll-strategy" : {
          "description" : "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
          "type" : "string"
        },
        "port" : {
          "description" : "Splunk port",
          "default" : "8089",
          "type" : "integer"
        },
        "raw" : {
          "description" : "Should the payload be inserted raw",
          "default" : "false",
          "type" : "boolean"
        },
        "repeat-count" : {
          "description" : "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
          "default" : "0",
          "type" : "integer"
        },
        "run-logging-level" : {
          "description" : "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
          "default" : "TRACE",
          "enum" : [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ],
          "type" : "string"
        },
        "saved-search" : {
          "description" : "The name of the query saved in Splunk to run",
          "type" : "string"
        },
        "scheduled-executor-service" : {
          "description" : "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
          "type" : "string"
        },
        "scheduler" : {
          "description" : "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
          "default" : "none",
          "type" : "string"
        },
        "scheduler-properties" : {
          "description" : "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
          "type" : "string"
        },
        "scheme" : {
          "description" : "Splunk scheme",
          "default" : "https",
          "type" : "string"
        },
        "search" : {
          "description" : "The Splunk query to run",
          "type" : "string"
        },
        "send-empty-message-when-idle" : {
          "description" : "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
          "default" : "false",
          "type" : "boolean"
        },
        "source" : {
          "description" : "Splunk source argument",
          "type" : "string"
        },
        "source-type" : {
          "description" : "Splunk sourcetype argument",
          "type" : "string"
        },
        "ssl-protocol" : {
          "description" : "Set the ssl protocol to use",
          "default" : "TLSv1.2",
          "enum" : [ "TLSv1.2", "TLSv1.1", "TLSv1", "SSLv3" ],
          "type" : "string"
        },
        "start-scheduler" : {
          "description" : "Whether the scheduler should be auto started.",
          "default" : "true",
          "type" : "boolean"
        },
        "streaming" : {
          "description" : "Sets streaming mode. Streaming mode sends exchanges as they are received, rather than in a batch.",
          "default" : "false",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "tcp-receiver-port" : {
          "description" : "Splunk tcp receiver port",
          "type" : "integer"
        },
        "time-unit" : {
          "description" : "Time unit for initialDelay and delay options.",
          "default" : "MILLISECONDS",
          "enum" : [ "NANOSECONDS", "MICROSECONDS", "MILLISECONDS", "SECONDS", "MINUTES", "HOURS", "DAYS" ],
          "type" : "string"
        },
        "use-fixed-delay" : {
          "description" : "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
          "default" : "true",
          "type" : "boolean"
        },
        "use-sun-https-handler" : {
          "description" : "Use sun.net.www.protocol.https.Handler Https handler to establish the Splunk Connection. Can be useful when running in application servers to avoid app. server https handling.",
          "default" : "false",
          "type" : "boolean"
        },
        "username" : {
          "description" : "Username for Splunk",
          "type" : "string"
        }
      }
    },
    "splunk-hec" : {
      "type" : "object",
      "required" : [ "splunkURL", "token" ],
      "properties" : {
        "splunk-url" : {
          "description" : "Splunk Host URL",
          "type" : "string"
        },
        "token" : {
          "description" : "Splunk authorization token",
          "type" : "string"
        },
        "host" : {
          "description" : "Splunk host.",
          "type" : "string"
        },
        "https" : {
          "description" : "Contact HEC over https.",
          "default" : "true",
          "type" : "boolean"
        },
        "index" : {
          "description" : "Splunk index to write to",
          "default" : "camel",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "skip-tls-verify" : {
          "description" : "Splunk HEC TLS verification.",
          "default" : "false",
          "type" : "boolean"
        },
        "source" : {
          "description" : "Splunk source argument",
          "default" : "camel",
          "type" : "string"
        },
        "source-type" : {
          "description" : "Splunk sourcetype argument",
          "default" : "camel",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "spring-batch" : {
      "type" : "object",
      "required" : [ "jobName" ],
      "properties" : {
        "job-name" : {
          "description" : "The name of the Spring Batch job located in the registry.",
          "type" : "string"
        },
        "job-from-header" : {
          "description" : "Explicitly defines if the jobName should be taken from the headers instead of the URI.",
          "default" : "false",
          "type" : "boolean"
        },
        "job-launcher" : {
          "description" : "Explicitly specifies a JobLauncher to be used.",
          "type" : "string"
        },
        "job-registry" : {
          "description" : "Explicitly specifies a JobRegistry to be used.",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "spring-event" : {
      "type" : "object",
      "properties" : {
        "name" : {
          "description" : "Name of endpoint",
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "spring-integration" : {
      "type" : "object",
      "required" : [ "defaultChannel" ],
      "properties" : {
        "default-channel" : {
          "description" : "The default channel name which is used by the Spring Integration Spring context. It will equal to the inputChannel name for the Spring Integration consumer and the outputChannel name for the Spring Integration provider.",
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "in-out" : {
          "description" : "The exchange pattern that the Spring integration endpoint should use. If inOut=true then a reply channel is expected, either from the Spring Integration Message header or configured on the endpoint.",
          "default" : "false",
          "type" : "boolean"
        },
        "input-channel" : {
          "description" : "The Spring integration input channel name that this endpoint wants to consume from Spring integration.",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "output-channel" : {
          "description" : "The Spring integration output channel name that is used to send messages to Spring integration.",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "spring-ldap" : {
      "type" : "object",
      "required" : [ "templateName", "operation" ],
      "properties" : {
        "template-name" : {
          "description" : "Name of the Spring LDAP Template bean",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "operation" : {
          "description" : "The LDAP operation to be performed.",
          "enum" : [ "SEARCH", "BIND", "UNBIND", "AUTHENTICATE", "MODIFY_ATTRIBUTES", "FUNCTION_DRIVEN" ],
          "type" : "string"
        },
        "scope" : {
          "description" : "The scope of the search operation.",
          "default" : "subtree",
          "enum" : [ "object", "onelevel", "subtree" ],
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "spring-redis" : {
      "type" : "object",
      "required" : [ "host", "port" ],
      "properties" : {
        "host" : {
          "description" : "The host where Redis server is running.",
          "type" : "string"
        },
        "port" : {
          "description" : "Redis server port number",
          "type" : "integer"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "channels" : {
          "description" : "List of topic names or name patterns to subscribe to. Multiple names can be separated by comma.",
          "type" : "string"
        },
        "command" : {
          "description" : "Default command, which can be overridden by message header. Notice the consumer only supports the following commands: PSUBSCRIBE and SUBSCRIBE",
          "default" : "SET",
          "enum" : [ "PING", "SET", "GET", "QUIT", "EXISTS", "DEL", "TYPE", "FLUSHDB", "KEYS", "RANDOMKEY", "RENAME", "RENAMENX", "RENAMEX", "DBSIZE", "EXPIRE", "EXPIREAT", "TTL", "SELECT", "MOVE", "FLUSHALL", "GETSET", "MGET", "SETNX", "SETEX", "MSET", "MSETNX", "DECRBY", "DECR", "INCRBY", "INCR", "APPEND", "SUBSTR", "HSET", "HGET", "HSETNX", "HMSET", "HMGET", "HINCRBY", "HEXISTS", "HDEL", "HLEN", "HKEYS", "HVALS", "HGETALL", "RPUSH", "LPUSH", "LLEN", "LRANGE", "LTRIM", "LINDEX", "LSET", "LREM", "LPOP", "RPOP", "RPOPLPUSH", "SADD", "SMEMBERS", "SREM", "SPOP", "SMOVE", "SCARD", "SISMEMBER", "SINTER", "SINTERSTORE", "SUNION", "SUNIONSTORE", "SDIFF", "SDIFFSTORE", "SRANDMEMBER", "ZADD", "ZRANGE", "ZREM", "ZINCRBY", "ZRANK", "ZREVRANK", "ZREVRANGE", "ZCARD", "ZSCORE", "MULTI", "DISCARD", "EXEC", "WATCH", "UNWATCH", "SORT", "BLPOP", "BRPOP", "AUTH", "SUBSCRIBE", "PUBLISH", "UNSUBSCRIBE", "PSUBSCRIBE", "PUNSUBSCRIBE", "ZCOUNT", "ZRANGEBYSCORE", "ZREVRANGEBYSCORE", "ZREMRANGEBYRANK", "ZREMRANGEBYSCORE", "ZUNIONSTORE", "ZINTERSTORE", "SAVE", "BGSAVE", "BGREWRITEAOF", "LASTSAVE", "SHUTDOWN", "INFO", "MONITOR", "SLAVEOF", "CONFIG", "STRLEN", "SYNC", "LPUSHX", "PERSIST", "RPUSHX", "ECHO", "LINSERT", "DEBUG", "BRPOPLPUSH", "SETBIT", "GETBIT", "SETRANGE", "GETRANGE", "PEXPIRE", "PEXPIREAT", "GEOADD", "GEODIST", "GEOHASH", "GEOPOS", "GEORADIUS", "GEORADIUSBYMEMBER" ],
          "type" : "string"
        },
        "connection-factory" : {
          "description" : "Reference to a pre-configured RedisConnectionFactory instance to use.",
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "listener-container" : {
          "description" : "Reference to a pre-configured RedisMessageListenerContainer instance to use.",
          "type" : "string"
        },
        "redis-template" : {
          "description" : "Reference to a pre-configured RedisTemplate instance to use.",
          "type" : "string"
        },
        "serializer" : {
          "description" : "Reference to a pre-configured RedisSerializer instance to use.",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "spring-ws" : {
      "type" : "object",
      "properties" : {
        "expression" : {
          "description" : "The XPath expression to use when option type=xpathresult. Then this option is required to be configured.",
          "type" : "string"
        },
        "lookup-key" : {
          "description" : "Endpoint mapping key if endpoint mapping is used",
          "type" : "string"
        },
        "type" : {
          "description" : "Endpoint mapping type if endpoint mapping is used. rootqname - Offers the option to map web service requests based on the qualified name of the root element contained in the message. soapaction - Used to map web service requests based on the SOAP action specified in the header of the message. uri - In order to map web service requests that target a specific URI. xpathresult - Used to map web service requests based on the evaluation of an XPath expression against the incoming message. The result of the evaluation should match the XPath result specified in the endpoint URI. beanname - Allows you to reference an org.apache.camel.component.spring.ws.bean.CamelEndpointDispatcher object in order to integrate with existing (legacy) endpoint mappings like PayloadRootQNameEndpointMapping, SoapActionEndpointMapping, etc",
          "enum" : [ "ROOT_QNAME", "ACTION", "TO", "SOAP_ACTION", "XPATHRESULT", "URI", "URI_PATH", "BEANNAME" ],
          "type" : "string"
        },
        "web-service-endpoint-uri" : {
          "description" : "The default Web Service endpoint uri to use for the producer.",
          "type" : "string"
        },
        "allow-response-attachment-override" : {
          "description" : "Option to override soap response attachments in in/out exchange with attachments from the actual service layer. If the invoked service appends or rewrites the soap attachments this option when set to true, allows the modified soap attachments to be overwritten in in/out message attachments",
          "default" : "false",
          "type" : "boolean"
        },
        "allow-response-header-override" : {
          "description" : "Option to override soap response header in in/out exchange with header info from the actual service layer. If the invoked service appends or rewrites the soap header this option when set to true, allows the modified soap header to be overwritten in in/out message headers",
          "default" : "false",
          "type" : "boolean"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "endpoint-dispatcher" : {
          "description" : "Spring org.springframework.ws.server.endpoint.MessageEndpoint for dispatching messages received by Spring-WS to a Camel endpoint, to integrate with existing (legacy) endpoint mappings like PayloadRootQNameEndpointMapping, SoapActionEndpointMapping, etc.",
          "type" : "string"
        },
        "endpoint-mapping" : {
          "description" : "Reference to an instance of org.apache.camel.component.spring.ws.bean.CamelEndpointMapping in the Registry/ApplicationContext. Only one bean is required in the registry to serve all Camel/Spring-WS endpoints. This bean is auto-discovered by the MessageDispatcher and used to map requests to Camel endpoints based on characteristics specified on the endpoint (like root QName, SOAP action, etc)",
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "fault-action" : {
          "description" : "Signifies the value for the faultAction response WS-Addressing Fault Action header that is provided by the method. See org.springframework.ws.soap.addressing.server.annotation.Action annotation for more details.",
          "type" : "string"
        },
        "fault-to" : {
          "description" : "Signifies the value for the faultAction response WS-Addressing FaultTo header that is provided by the method. See org.springframework.ws.soap.addressing.server.annotation.Action annotation for more details.",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "message-factory" : {
          "description" : "Option to provide a custom WebServiceMessageFactory. For example when you want Apache Axiom to handle web service messages instead of SAAJ.",
          "type" : "string"
        },
        "message-filter" : {
          "description" : "Option to provide a custom MessageFilter. For example when you want to process your headers or attachments by your own.",
          "type" : "string"
        },
        "message-id-strategy" : {
          "description" : "Option to provide a custom MessageIdStrategy to control generation of WS-Addressing unique message ids.",
          "type" : "string"
        },
        "message-sender" : {
          "description" : "Option to provide a custom WebServiceMessageSender. For example to perform authentication or use alternative transports",
          "type" : "string"
        },
        "output-action" : {
          "description" : "Signifies the value for the response WS-Addressing Action header that is provided by the method. See org.springframework.ws.soap.addressing.server.annotation.Action annotation for more details.",
          "type" : "string"
        },
        "reply-to" : {
          "description" : "Signifies the value for the replyTo response WS-Addressing ReplyTo header that is provided by the method. See org.springframework.ws.soap.addressing.server.annotation.Action annotation for more details.",
          "type" : "string"
        },
        "soap-action" : {
          "description" : "SOAP action to include inside a SOAP request when accessing remote web services",
          "type" : "string"
        },
        "ssl-context-parameters" : {
          "description" : "To configure security using SSLContextParameters",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "timeout" : {
          "description" : "Sets the socket read timeout (in milliseconds) while invoking a webservice using the producer, see URLConnection.setReadTimeout() and CommonsHttpMessageSender.setReadTimeout(). This option works when using the built-in message sender implementations: CommonsHttpMessageSender and HttpUrlConnectionMessageSender. One of these implementations will be used by default for HTTP based services unless you customize the Spring WS configuration options supplied to the component. If you are using a non-standard sender, it is assumed that you will handle your own timeout configuration. The built-in message sender HttpComponentsMessageSender is considered instead of CommonsHttpMessageSender which has been deprecated, see HttpComponentsMessageSender.setReadTimeout().",
          "type" : "integer"
        },
        "web-service-template" : {
          "description" : "Option to provide a custom WebServiceTemplate. This allows for full control over client-side web services handling; like adding a custom interceptor or specifying a fault resolver, message sender or message factory.",
          "type" : "string"
        },
        "ws-addressing-action" : {
          "description" : "WS-Addressing 1.0 action header to include when accessing web services. The To header is set to the address of the web service as specified in the endpoint URI (default Spring-WS behavior).",
          "type" : "string"
        }
      }
    },
    "sql" : {
      "type" : "object",
      "required" : [ "query" ],
      "properties" : {
        "query" : {
          "description" : "Sets the SQL query to perform. You can externalize the query by using file: or classpath: as prefix and specify the location of the file.",
          "type" : "string"
        },
        "allow-named-parameters" : {
          "description" : "Whether to allow using named parameters in the queries.",
          "default" : "true",
          "type" : "boolean"
        },
        "always-populate-statement" : {
          "description" : "If enabled then the populateStatement method from org.apache.camel.component.sql.SqlPrepareStatementStrategy is always invoked, also if there is no expected parameters to be prepared. When this is false then the populateStatement is only invoked if there is 1 or more expected parameters to be set; for example this avoids reading the message body/headers for SQL queries with no parameters.",
          "default" : "false",
          "type" : "boolean"
        },
        "backoff-error-threshold" : {
          "description" : "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-idle-threshold" : {
          "description" : "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-multiplier" : {
          "description" : "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
          "type" : "integer"
        },
        "batch" : {
          "description" : "Enables or disables batch mode",
          "default" : "false",
          "type" : "boolean"
        },
        "break-batch-on-consume-fail" : {
          "description" : "Sets whether to break batch if onConsume failed.",
          "default" : "false",
          "type" : "boolean"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "data-source" : {
          "description" : "Sets the DataSource to use to communicate with the database.",
          "type" : "string"
        },
        "data-source-ref" : {
          "description" : "Sets the reference to a DataSource to lookup from the registry, to use for communicating with the database.",
          "type" : "string"
        },
        "delay" : {
          "description" : "Milliseconds before the next poll.",
          "default" : "500",
          "type" : "integer"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "expected-update-count" : {
          "description" : "Sets an expected update count to validate when using onConsume.",
          "default" : "-1",
          "type" : "integer"
        },
        "greedy" : {
          "description" : "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
          "default" : "false",
          "type" : "boolean"
        },
        "initial-delay" : {
          "description" : "Milliseconds before the first poll starts.",
          "default" : "1000",
          "type" : "integer"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "max-messages-per-poll" : {
          "description" : "Sets the maximum number of messages to poll",
          "type" : "integer"
        },
        "noop" : {
          "description" : "If set, will ignore the results of the SQL query and use the existing IN message as the OUT message for the continuation of processing",
          "default" : "false",
          "type" : "boolean"
        },
        "on-consume" : {
          "description" : "After processing each row then this query can be executed, if the Exchange was processed successfully, for example to mark the row as processed. The query can have parameter.",
          "type" : "string"
        },
        "on-consume-batch-complete" : {
          "description" : "After processing the entire batch, this query can be executed to bulk update rows etc. The query cannot have parameters.",
          "type" : "string"
        },
        "on-consume-failed" : {
          "description" : "After processing each row then this query can be executed, if the Exchange failed, for example to mark the row as failed. The query can have parameter.",
          "type" : "string"
        },
        "output-class" : {
          "description" : "Specify the full package and class name to use as conversion when outputType=SelectOne.",
          "type" : "string"
        },
        "output-header" : {
          "description" : "Store the query result in a header instead of the message body. By default, outputHeader == null and the query result is stored in the message body, any existing content in the message body is discarded. If outputHeader is set, the value is used as the name of the header to store the query result and the original message body is preserved.",
          "type" : "string"
        },
        "output-type" : {
          "description" : "Make the output of consumer or producer to SelectList as List of Map, or SelectOne as single Java object in the following way: a) If the query has only single column, then that JDBC Column object is returned. (such as SELECT COUNT( ) FROM PROJECT will return a Long object. b) If the query has more than one column, then it will return a Map of that result. c) If the outputClass is set, then it will convert the query result into an Java bean object by calling all the setters that match the column names. It will assume your class has a default constructor to create instance with. d) If the query resulted in more than one rows, it throws an non-unique result exception. StreamList streams the result of the query using an Iterator. This can be used with the Splitter EIP in streaming mode to process the ResultSet in streaming fashion.",
          "default" : "SelectList",
          "enum" : [ "SelectOne", "SelectList", "StreamList" ],
          "type" : "string"
        },
        "parameters-count" : {
          "description" : "If set greater than zero, then Camel will use this count value of parameters to replace instead of querying via JDBC metadata API. This is useful if the JDBC vendor could not return correct parameters count, then user may override instead.",
          "type" : "integer"
        },
        "placeholder" : {
          "description" : "Specifies a character that will be replaced to in SQL query. Notice, that it is simple String.replaceAll() operation and no SQL parsing is involved (quoted strings will also change).",
          "default" : "#",
          "type" : "string"
        },
        "poll-strategy" : {
          "description" : "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
          "type" : "string"
        },
        "prepare-statement-strategy" : {
          "description" : "Allows to plugin to use a custom org.apache.camel.component.sql.SqlPrepareStatementStrategy to control preparation of the query and prepared statement.",
          "type" : "string"
        },
        "processing-strategy" : {
          "description" : "Allows to plugin to use a custom org.apache.camel.component.sql.SqlProcessingStrategy to execute queries when the consumer has processed the rows/batch.",
          "type" : "string"
        },
        "repeat-count" : {
          "description" : "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
          "default" : "0",
          "type" : "integer"
        },
        "route-empty-result-set" : {
          "description" : "Sets whether empty resultset should be allowed to be sent to the next hop. Defaults to false. So the empty resultset will be filtered out.",
          "default" : "false",
          "type" : "boolean"
        },
        "run-logging-level" : {
          "description" : "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
          "default" : "TRACE",
          "enum" : [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ],
          "type" : "string"
        },
        "scheduled-executor-service" : {
          "description" : "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
          "type" : "string"
        },
        "scheduler" : {
          "description" : "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
          "default" : "none",
          "type" : "string"
        },
        "scheduler-properties" : {
          "description" : "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
          "type" : "string"
        },
        "send-empty-message-when-idle" : {
          "description" : "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
          "default" : "false",
          "type" : "boolean"
        },
        "separator" : {
          "description" : "The separator to use when parameter values is taken from message body (if the body is a String type), to be inserted at # placeholders. Notice if you use named parameters, then a Map type is used instead. The default value is comma",
          "default" : ",",
          "type" : "string"
        },
        "start-scheduler" : {
          "description" : "Whether the scheduler should be auto started.",
          "default" : "true",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "template-options" : {
          "description" : "Configures the Spring JdbcTemplate with the key/values from the Map",
          "type" : "string"
        },
        "time-unit" : {
          "description" : "Time unit for initialDelay and delay options.",
          "default" : "MILLISECONDS",
          "enum" : [ "NANOSECONDS", "MICROSECONDS", "MILLISECONDS", "SECONDS", "MINUTES", "HOURS", "DAYS" ],
          "type" : "string"
        },
        "transacted" : {
          "description" : "Enables or disables transaction. If enabled then if processing an exchange failed then the consumer breaks out processing any further exchanges to cause a rollback eager.",
          "default" : "false",
          "type" : "boolean"
        },
        "use-fixed-delay" : {
          "description" : "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
          "default" : "true",
          "type" : "boolean"
        },
        "use-iterator" : {
          "description" : "Sets how resultset should be delivered to route. Indicates delivery as either a list or individual object. defaults to true.",
          "default" : "true",
          "type" : "boolean"
        },
        "use-message-body-for-sql" : {
          "description" : "Whether to use the message body as the SQL and then headers for parameters. If this option is enabled then the SQL in the uri is not used. Note that query parameters in the message body are represented by a question mark instead of a # symbol.",
          "default" : "false",
          "type" : "boolean"
        },
        "use-placeholder" : {
          "description" : "Sets whether to use placeholder and replace all placeholder characters with sign in the SQL queries.",
          "default" : "true",
          "type" : "boolean"
        }
      }
    },
    "sql-stored" : {
      "type" : "object",
      "required" : [ "template" ],
      "properties" : {
        "template" : {
          "description" : "Sets the StoredProcedure template to perform",
          "type" : "string"
        },
        "batch" : {
          "description" : "Enables or disables batch mode",
          "default" : "false",
          "type" : "boolean"
        },
        "data-source" : {
          "description" : "Sets the DataSource to use to communicate with the database.",
          "type" : "string"
        },
        "function" : {
          "description" : "Whether this call is for a function.",
          "default" : "false",
          "type" : "boolean"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "noop" : {
          "description" : "If set, will ignore the results of the template and use the existing IN message as the OUT message for the continuation of processing",
          "default" : "false",
          "type" : "boolean"
        },
        "output-header" : {
          "description" : "Store the template result in a header instead of the message body. By default, outputHeader == null and the template result is stored in the message body, any existing content in the message body is discarded. If outputHeader is set, the value is used as the name of the header to store the template result and the original message body is preserved.",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "use-message-body-for-template" : {
          "description" : "Whether to use the message body as the template and then headers for parameters. If this option is enabled then the template in the uri is not used.",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "ssh" : {
      "type" : "object",
      "required" : [ "host" ],
      "properties" : {
        "host" : {
          "description" : "Sets the hostname of the remote SSH server.",
          "type" : "string"
        },
        "port" : {
          "description" : "Sets the port number for the remote SSH server.",
          "default" : "22",
          "type" : "integer"
        },
        "backoff-error-threshold" : {
          "description" : "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-idle-threshold" : {
          "description" : "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-multiplier" : {
          "description" : "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
          "type" : "integer"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "cert-resource" : {
          "description" : "Sets the resource path of the certificate to use for Authentication. Will use ResourceHelperKeyPairProvider to resolve file based certificate, and depends on keyType setting.",
          "type" : "string"
        },
        "cert-resource-password" : {
          "description" : "Sets the password to use in loading certResource, if certResource is an encrypted key.",
          "type" : "string"
        },
        "channel-type" : {
          "description" : "Sets the channel type to pass to the Channel as part of command execution. Defaults to exec.",
          "default" : "exec",
          "type" : "string"
        },
        "delay" : {
          "description" : "Milliseconds before the next poll.",
          "default" : "500",
          "type" : "integer"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "fail-on-unknown-host" : {
          "description" : "Specifies whether a connection to an unknown host should fail or not. This value is only checked when the property knownHosts is set.",
          "default" : "false",
          "type" : "boolean"
        },
        "greedy" : {
          "description" : "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
          "default" : "false",
          "type" : "boolean"
        },
        "initial-delay" : {
          "description" : "Milliseconds before the first poll starts.",
          "default" : "1000",
          "type" : "integer"
        },
        "key-pair-provider" : {
          "description" : "Sets the KeyPairProvider reference to use when connecting using Certificates to the remote SSH Server.",
          "type" : "string"
        },
        "key-type" : {
          "description" : "Sets the key type to pass to the KeyPairProvider as part of authentication. KeyPairProvider.loadKey(...) will be passed this value. From Camel 3.0.0 / 2.25.0, by default Camel will select the first available KeyPair that is loaded. Prior to this, a KeyType of 'ssh-rsa' was enforced by default.",
          "type" : "string"
        },
        "known-hosts-resource" : {
          "description" : "Sets the resource path for a known_hosts file",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "password" : {
          "description" : "Sets the password to use in connecting to remote SSH server. Requires keyPairProvider to be set to null.",
          "type" : "string"
        },
        "poll-command" : {
          "description" : "Sets the command string to send to the remote SSH server during every poll cycle. Only works with camel-ssh component being used as a consumer, i.e. from(ssh://...) You may need to end your command with a newline, and that must be URL encoded %0A",
          "type" : "string"
        },
        "poll-strategy" : {
          "description" : "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
          "type" : "string"
        },
        "repeat-count" : {
          "description" : "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
          "default" : "0",
          "type" : "integer"
        },
        "run-logging-level" : {
          "description" : "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
          "default" : "TRACE",
          "enum" : [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ],
          "type" : "string"
        },
        "scheduled-executor-service" : {
          "description" : "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
          "type" : "string"
        },
        "scheduler" : {
          "description" : "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
          "default" : "none",
          "type" : "string"
        },
        "scheduler-properties" : {
          "description" : "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
          "type" : "string"
        },
        "send-empty-message-when-idle" : {
          "description" : "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
          "default" : "false",
          "type" : "boolean"
        },
        "shell-prompt" : {
          "description" : "Sets the shellPrompt to be dropped when response is read after command execution",
          "type" : "string"
        },
        "sleep-for-shell-prompt" : {
          "description" : "Sets the sleep period in milliseconds to wait reading response from shell prompt. Defaults to 100 milliseconds.",
          "default" : "100",
          "type" : "integer"
        },
        "start-scheduler" : {
          "description" : "Whether the scheduler should be auto started.",
          "default" : "true",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "time-unit" : {
          "description" : "Time unit for initialDelay and delay options.",
          "default" : "MILLISECONDS",
          "enum" : [ "NANOSECONDS", "MICROSECONDS", "MILLISECONDS", "SECONDS", "MINUTES", "HOURS", "DAYS" ],
          "type" : "string"
        },
        "timeout" : {
          "description" : "Sets the timeout in milliseconds to wait in establishing the remote SSH server connection. Defaults to 30000 milliseconds.",
          "default" : "30000",
          "type" : "integer"
        },
        "use-fixed-delay" : {
          "description" : "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
          "default" : "true",
          "type" : "boolean"
        },
        "username" : {
          "description" : "Sets the username to use in logging into the remote SSH server.",
          "type" : "string"
        }
      }
    },
    "stax" : {
      "type" : "object",
      "required" : [ "contentHandlerClass" ],
      "properties" : {
        "content-handler-class" : {
          "description" : "The FQN class name for the ContentHandler implementation to use.",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "stomp" : {
      "type" : "object",
      "required" : [ "destination", "brokerURL" ],
      "properties" : {
        "destination" : {
          "description" : "Name of the queue",
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "broker-url" : {
          "description" : "The URI of the Stomp broker to connect to",
          "default" : "tcp://localhost:61613",
          "type" : "string"
        },
        "custom-headers" : {
          "description" : "To set custom headers",
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "header-filter-strategy" : {
          "description" : "To use a custom HeaderFilterStrategy to filter header to and from Camel message.",
          "type" : "string"
        },
        "host" : {
          "description" : "The virtual host name",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "login" : {
          "description" : "The username",
          "type" : "string"
        },
        "passcode" : {
          "description" : "The password",
          "type" : "string"
        },
        "ssl-context-parameters" : {
          "description" : "To configure security using SSLContextParameters",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "version" : {
          "description" : "The stomp version (1.1, or 1.2)",
          "type" : "string"
        }
      }
    },
    "stream" : {
      "type" : "object",
      "required" : [ "kind" ],
      "properties" : {
        "kind" : {
          "description" : "Kind of stream to use such as System.in or System.out.",
          "enum" : [ "in", "out", "err", "header", "file" ],
          "type" : "string"
        },
        "auto-close-count" : {
          "description" : "Number of messages to process before closing stream on Producer side. Never close stream by default (only when Producer is stopped). If more messages are sent, the stream is reopened for another autoCloseCount batch.",
          "type" : "integer"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "close-on-done" : {
          "description" : "This option is used in combination with Splitter and streaming to the same file. The idea is to keep the stream open and only close when the Splitter is done, to improve performance. Mind this requires that you only stream to the same file, and not 2 or more files.",
          "default" : "false",
          "type" : "boolean"
        },
        "delay" : {
          "description" : "Initial delay in milliseconds before producing the stream.",
          "type" : "integer"
        },
        "encoding" : {
          "description" : "You can configure the encoding (is a charset name) to use text-based streams (for example, message body is a String object). If not provided, Camel uses the JVM default Charset.",
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "file-name" : {
          "description" : "When using the stream:file URI format, this option specifies the filename to stream to/from.",
          "type" : "string"
        },
        "file-watcher" : {
          "description" : "To use JVM file watcher to listen for file change events to support re-loading files that may be overwritten, somewhat like tail --retry",
          "default" : "false",
          "type" : "boolean"
        },
        "group-lines" : {
          "description" : "To group X number of lines in the consumer. For example to group 10 lines and therefore only spit out an Exchange with 10 lines, instead of 1 Exchange per line.",
          "type" : "integer"
        },
        "group-strategy" : {
          "description" : "Allows to use a custom GroupStrategy to control how to group lines.",
          "type" : "string"
        },
        "initial-prompt-delay" : {
          "description" : "Initial delay in milliseconds before showing the message prompt. This delay occurs only once. Can be used during system startup to avoid message prompts being written while other logging is done to the system out.",
          "default" : "2000",
          "type" : "integer"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "prompt-delay" : {
          "description" : "Optional delay in milliseconds before showing the message prompt.",
          "type" : "integer"
        },
        "prompt-message" : {
          "description" : "Message prompt to use when reading from stream:in; for example, you could set this to Enter a command:",
          "type" : "string"
        },
        "read-timeout" : {
          "description" : "Sets the read timeout to a specified timeout, in milliseconds. A non-zero value specifies the timeout when reading from Input stream when a connection is established to a resource. If the timeout expires before there is data available for read, a java.net.SocketTimeoutException is raised. A timeout of zero is interpreted as an infinite timeout.",
          "type" : "integer"
        },
        "retry" : {
          "description" : "Will retry opening the stream if it's overwritten, somewhat like tail --retry If reading from files then you should also enable the fileWatcher option, to make it work reliable.",
          "default" : "false",
          "type" : "boolean"
        },
        "scan-stream" : {
          "description" : "To be used for continuously reading a stream such as the unix tail command.",
          "default" : "false",
          "type" : "boolean"
        },
        "scan-stream-delay" : {
          "description" : "Delay in milliseconds between read attempts when using scanStream.",
          "type" : "integer"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "string-template" : {
      "type" : "object",
      "required" : [ "resourceUri" ],
      "properties" : {
        "resource-uri" : {
          "description" : "Path to the resource. You can prefix with: classpath, file, http, ref, or bean. classpath, file and http loads the resource using these protocols (classpath is default). ref will lookup the resource in the registry. bean will call a method on a bean to be used as the resource. For bean you can specify the method name after dot, eg bean:myBean.myMethod.",
          "type" : "string"
        },
        "allow-context-map-all" : {
          "description" : "Sets whether the context map should allow access to all details. By default only the message body and headers can be accessed. This option can be enabled for full access to the current Exchange and CamelContext. Doing so impose a potential security risk as this opens access to the full power of CamelContext API.",
          "default" : "false",
          "type" : "boolean"
        },
        "allow-template-from-header" : {
          "description" : "Whether to allow to use resource template from header or not (default false). Enabling this allows to specify dynamic templates via message header. However this can be seen as a potential security vulnerability if the header is coming from a malicious user, so use this with care.",
          "default" : "false",
          "type" : "boolean"
        },
        "content-cache" : {
          "description" : "Sets whether to use resource content cache or not",
          "default" : "false",
          "type" : "boolean"
        },
        "delimiter-start" : {
          "description" : "The variable start delimiter",
          "default" : "<",
          "type" : "string"
        },
        "delimiter-stop" : {
          "description" : "The variable end delimiter",
          "default" : ">",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "stub" : {
      "type" : "object",
      "required" : [ "name" ],
      "properties" : {
        "name" : {
          "description" : "Name of queue",
          "type" : "string"
        },
        "block-when-full" : {
          "description" : "Whether a thread that sends messages to a full SEDA queue will block until the queue's capacity is no longer exhausted. By default, an exception will be thrown stating that the queue is full. By enabling this option, the calling thread will instead block and wait until the message can be accepted.",
          "default" : "false",
          "type" : "boolean"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "concurrent-consumers" : {
          "description" : "Number of concurrent threads processing exchanges.",
          "default" : "1",
          "type" : "integer"
        },
        "discard-if-no-consumers" : {
          "description" : "Whether the producer should discard the message (do not add the message to the queue), when sending to a queue with no active consumers. Only one of the options discardIfNoConsumers and failIfNoConsumers can be enabled at the same time.",
          "default" : "false",
          "type" : "boolean"
        },
        "discard-when-full" : {
          "description" : "Whether a thread that sends messages to a full SEDA queue will be discarded. By default, an exception will be thrown stating that the queue is full. By enabling this option, the calling thread will give up sending and continue, meaning that the message was not sent to the SEDA queue.",
          "default" : "false",
          "type" : "boolean"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "fail-if-no-consumers" : {
          "description" : "Whether the producer should fail by throwing an exception, when sending to a queue with no active consumers. Only one of the options discardIfNoConsumers and failIfNoConsumers can be enabled at the same time.",
          "default" : "false",
          "type" : "boolean"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "limit-concurrent-consumers" : {
          "description" : "Whether to limit the number of concurrentConsumers to the maximum of 500. By default, an exception will be thrown if an endpoint is configured with a greater number. You can disable that check by turning this option off.",
          "default" : "true",
          "type" : "boolean"
        },
        "multiple-consumers" : {
          "description" : "Specifies whether multiple consumers are allowed. If enabled, you can use SEDA for Publish-Subscribe messaging. That is, you can send a message to the SEDA queue and have each consumer receive a copy of the message. When enabled, this option should be specified on every consumer endpoint.",
          "default" : "false",
          "type" : "boolean"
        },
        "offer-timeout" : {
          "description" : "offerTimeout (in milliseconds) can be added to the block case when queue is full. You can disable timeout by using 0 or a negative value.",
          "type" : "string"
        },
        "poll-timeout" : {
          "description" : "The timeout used when polling. When a timeout occurs, the consumer can check whether it is allowed to continue running. Setting a lower value allows the consumer to react more quickly upon shutdown.",
          "default" : "1000",
          "type" : "integer"
        },
        "purge-when-stopping" : {
          "description" : "Whether to purge the task queue when stopping the consumer/route. This allows to stop faster, as any pending messages on the queue is discarded.",
          "default" : "false",
          "type" : "boolean"
        },
        "queue" : {
          "description" : "Define the queue instance which will be used by the endpoint",
          "type" : "string"
        },
        "size" : {
          "description" : "The maximum capacity of the SEDA queue (i.e., the number of messages it can hold). Will by default use the defaultSize set on the SEDA component.",
          "default" : "1000",
          "type" : "integer"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "timeout" : {
          "description" : "Timeout (in milliseconds) before a SEDA producer will stop waiting for an asynchronous task to complete. You can disable timeout by using 0 or a negative value.",
          "default" : "30000",
          "type" : "string"
        },
        "wait-for-task-to-complete" : {
          "description" : "Option to specify whether the caller should wait for the async task to complete or not before continuing. The following three options are supported: Always, Never or IfReplyExpected. The first two values are self-explanatory. The last value, IfReplyExpected, will only wait if the message is Request Reply based. The default option is IfReplyExpected.",
          "default" : "IfReplyExpected",
          "enum" : [ "Never", "IfReplyExpected", "Always" ],
          "type" : "string"
        }
      }
    },
    "telegram" : {
      "type" : "object",
      "required" : [ "type", "authorizationToken" ],
      "properties" : {
        "type" : {
          "description" : "The endpoint type. Currently, only the 'bots' type is supported.",
          "enum" : [ "bots" ],
          "type" : "string"
        },
        "authorization-token" : {
          "description" : "The authorization token for using the bot (ask the BotFather)",
          "type" : "string"
        },
        "backoff-error-threshold" : {
          "description" : "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-idle-threshold" : {
          "description" : "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-multiplier" : {
          "description" : "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
          "type" : "integer"
        },
        "base-uri" : {
          "description" : "Can be used to set an alternative base URI, e.g. when you want to test the component against a mock Telegram API",
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "buffer-size" : {
          "description" : "The initial in-memory buffer size used when transferring data between Camel and AHC Client.",
          "default" : "4096",
          "type" : "integer"
        },
        "chat-id" : {
          "description" : "The identifier of the chat that will receive the produced messages. Chat ids can be first obtained from incoming messages (eg. when a telegram user starts a conversation with a bot, its client sends automatically a '/start' message containing the chat id). It is an optional parameter, as the chat id can be set dynamically for each outgoing message (using body or headers).",
          "type" : "string"
        },
        "client-config" : {
          "description" : "To configure the AsyncHttpClient to use a custom com.ning.http.client.AsyncHttpClientConfig instance.",
          "type" : "string"
        },
        "delay" : {
          "description" : "Milliseconds before the next poll.",
          "default" : "500",
          "type" : "integer"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "greedy" : {
          "description" : "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
          "default" : "false",
          "type" : "boolean"
        },
        "initial-delay" : {
          "description" : "Milliseconds before the first poll starts.",
          "default" : "1000",
          "type" : "integer"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "limit" : {
          "description" : "Limit on the number of updates that can be received in a single polling request.",
          "default" : "100",
          "type" : "integer"
        },
        "poll-strategy" : {
          "description" : "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
          "type" : "string"
        },
        "proxy-host" : {
          "description" : "HTTP proxy host which could be used when sending out the message.",
          "type" : "string"
        },
        "proxy-port" : {
          "description" : "HTTP proxy port which could be used when sending out the message.",
          "type" : "integer"
        },
        "proxy-type" : {
          "description" : "HTTP proxy type which could be used when sending out the message.",
          "default" : "HTTP",
          "enum" : [ "HTTP", "SOCKS4", "SOCKS5" ],
          "type" : "string"
        },
        "repeat-count" : {
          "description" : "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
          "default" : "0",
          "type" : "integer"
        },
        "run-logging-level" : {
          "description" : "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
          "default" : "TRACE",
          "enum" : [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ],
          "type" : "string"
        },
        "scheduled-executor-service" : {
          "description" : "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
          "type" : "string"
        },
        "scheduler" : {
          "description" : "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
          "default" : "none",
          "type" : "string"
        },
        "scheduler-properties" : {
          "description" : "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
          "type" : "string"
        },
        "send-empty-message-when-idle" : {
          "description" : "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
          "default" : "false",
          "type" : "boolean"
        },
        "start-scheduler" : {
          "description" : "Whether the scheduler should be auto started.",
          "default" : "true",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "time-unit" : {
          "description" : "Time unit for initialDelay and delay options.",
          "default" : "MILLISECONDS",
          "enum" : [ "NANOSECONDS", "MICROSECONDS", "MILLISECONDS", "SECONDS", "MINUTES", "HOURS", "DAYS" ],
          "type" : "string"
        },
        "timeout" : {
          "description" : "Timeout in seconds for long polling. Put 0 for short polling or a bigger number for long polling. Long polling produces shorter response time.",
          "default" : "30",
          "type" : "integer"
        },
        "use-fixed-delay" : {
          "description" : "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
          "default" : "true",
          "type" : "boolean"
        }
      }
    },
    "thrift" : {
      "type" : "object",
      "properties" : {
        "host" : {
          "description" : "The Thrift server host name. This is localhost or 0.0.0.0 (if not defined) when being a consumer or remote server host name when using producer.",
          "type" : "string"
        },
        "port" : {
          "description" : "The Thrift server port",
          "type" : "integer"
        },
        "service" : {
          "description" : "Fully qualified service name from the thrift descriptor file (package dot service definition name)",
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "client-timeout" : {
          "description" : "Client timeout for consumers",
          "type" : "integer"
        },
        "compression-type" : {
          "description" : "Protocol compression mechanism type",
          "default" : "NONE",
          "enum" : [ "NONE", "ZLIB" ],
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "exchange-protocol" : {
          "description" : "Exchange protocol serialization type",
          "default" : "BINARY",
          "enum" : [ "BINARY", "JSON", "SJSON", "COMPACT" ],
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "max-pool-size" : {
          "description" : "The Thrift server consumer max thread pool size",
          "default" : "10",
          "type" : "integer"
        },
        "method" : {
          "description" : "The Thrift invoked method name",
          "type" : "string"
        },
        "negotiation-type" : {
          "description" : "Security negotiation type",
          "default" : "PLAINTEXT",
          "enum" : [ "PLAINTEXT", "SSL", "SASL" ],
          "type" : "string"
        },
        "pool-size" : {
          "description" : "The Thrift server consumer initial thread pool size",
          "default" : "1",
          "type" : "integer"
        },
        "ssl-parameters" : {
          "description" : "Configuration parameters for SSL/TLS security negotiation",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        }
      },
      "required" : [ "port", "service" ]
    },
    "tika" : {
      "type" : "object",
      "required" : [ "operation" ],
      "properties" : {
        "operation" : {
          "description" : "Operation type",
          "enum" : [ "parse", "detect" ],
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "tika-config" : {
          "description" : "Tika Config",
          "type" : "string"
        },
        "tika-config-uri" : {
          "description" : "Tika Config Url",
          "type" : "string"
        },
        "tika-parse-output-encoding" : {
          "description" : "Tika Parse Output Encoding",
          "type" : "string"
        },
        "tika-parse-output-format" : {
          "description" : "Tika Output Format. Supported output formats. xml: Returns Parsed Content as XML. html: Returns Parsed Content as HTML. text: Returns Parsed Content as Text. textMain: Uses the boilerpipe library to automatically extract the main content from a web page.",
          "default" : "xml",
          "enum" : [ "xml", "html", "text", "textMain" ],
          "type" : "string"
        }
      }
    },
    "timer" : {
      "type" : "object",
      "required" : [ "timerName" ],
      "properties" : {
        "timer-name" : {
          "description" : "The name of the timer",
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "daemon" : {
          "description" : "Specifies whether or not the thread associated with the timer endpoint runs as a daemon. The default value is true.",
          "default" : "true",
          "type" : "boolean"
        },
        "delay" : {
          "description" : "Delay before first event is triggered.",
          "default" : "1s",
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "fixed-rate" : {
          "description" : "Events take place at approximately regular intervals, separated by the specified period.",
          "default" : "false",
          "type" : "boolean"
        },
        "include-metadata" : {
          "description" : "Whether to include metadata in the exchange such as fired time, timer name, timer count etc. This information is default included.",
          "default" : "true",
          "type" : "boolean"
        },
        "pattern" : {
          "description" : "Allows you to specify a custom Date pattern to use for setting the time option using URI syntax.",
          "type" : "string"
        },
        "period" : {
          "description" : "If greater than 0, generate periodic events every period.",
          "default" : "1s",
          "type" : "string"
        },
        "repeat-count" : {
          "description" : "Specifies a maximum limit of number of fires. So if you set it to 1, the timer will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
          "default" : "0",
          "type" : "integer"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "time" : {
          "description" : "A java.util.Date the first event should be generated. If using the URI, the pattern expected is: yyyy-MM-dd HH:mm:ss or yyyy-MM-dd'T'HH:mm:ss.",
          "type" : "string"
        },
        "timer" : {
          "description" : "To use a custom Timer",
          "type" : "string"
        }
      }
    },
    "twilio" : {
      "type" : "object",
      "required" : [ "apiName", "methodName" ],
      "properties" : {
        "api-name" : {
          "description" : "What kind of operation to perform",
          "enum" : [ "ACCOUNT", "ADDRESS", "APPLICATION", "AVAILABLE_PHONE_NUMBER_COUNTRY", "CALL", "CONFERENCE", "CONNECT_APP", "INCOMING_PHONE_NUMBER", "KEY", "MESSAGE", "NEW_KEY", "NEW_SIGNING_KEY", "NOTIFICATION", "OUTGOING_CALLER_ID", "QUEUE", "RECORDING", "SHORT_CODE", "SIGNING_KEY", "TOKEN", "TRANSCRIPTION", "VALIDATION_REQUEST", "ADDRESS_DEPENDENT_PHONE_NUMBER", "AVAILABLE_PHONE_NUMBER_COUNTRY_LOCAL", "AVAILABLE_PHONE_NUMBER_COUNTRY_MOBILE", "AVAILABLE_PHONE_NUMBER_COUNTRY_TOLL_FREE", "CALL_FEEDBACK", "CALL_FEEDBACK_SUMMARY", "CALL_NOTIFICATION", "CALL_RECORDING", "CONFERENCE_PARTICIPANT", "INCOMING_PHONE_NUMBER_LOCAL", "INCOMING_PHONE_NUMBER_MOBILE", "INCOMING_PHONE_NUMBER_TOLL_FREE", "MESSAGE_FEEDBACK", "MESSAGE_MEDIA", "QUEUE_MEMBER", "RECORDING_ADD_ON_RESULT", "RECORDING_TRANSCRIPTION", "RECORDING_ADD_ON_RESULT_PAYLOAD", "SIP_CREDENTIAL_LIST", "SIP_DOMAIN", "SIP_IP_ACCESS_CONTROL_LIST", "SIP_CREDENTIAL_LIST_CREDENTIAL", "SIP_DOMAIN_CREDENTIAL_LIST_MAPPING", "SIP_DOMAIN_IP_ACCESS_CONTROL_LIST_MAPPING", "SIP_IP_ACCESS_CONTROL_LIST_IP_ADDRESS", "USAGE_RECORD", "USAGE_TRIGGER", "USAGE_RECORD_ALL_TIME", "USAGE_RECORD_DAILY", "USAGE_RECORD_LAST_MONTH", "USAGE_RECORD_MONTHLY", "USAGE_RECORD_THIS_MONTH", "USAGE_RECORD_TODAY", "USAGE_RECORD_YEARLY", "USAGE_RECORD_YESTERDAY" ],
          "type" : "string"
        },
        "method-name" : {
          "description" : "What sub operation to use for the selected operation",
          "enum" : [ "create", "delete", "fetch", "read", "update" ],
          "type" : "string"
        },
        "backoff-error-threshold" : {
          "description" : "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-idle-threshold" : {
          "description" : "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-multiplier" : {
          "description" : "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
          "type" : "integer"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "delay" : {
          "description" : "Milliseconds before the next poll.",
          "default" : "500",
          "type" : "integer"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "greedy" : {
          "description" : "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
          "default" : "false",
          "type" : "boolean"
        },
        "in-body" : {
          "description" : "Sets the name of a parameter to be passed in the exchange In Body",
          "type" : "string"
        },
        "initial-delay" : {
          "description" : "Milliseconds before the first poll starts.",
          "default" : "1000",
          "type" : "integer"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "poll-strategy" : {
          "description" : "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
          "type" : "string"
        },
        "repeat-count" : {
          "description" : "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
          "default" : "0",
          "type" : "integer"
        },
        "run-logging-level" : {
          "description" : "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
          "default" : "TRACE",
          "enum" : [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ],
          "type" : "string"
        },
        "scheduled-executor-service" : {
          "description" : "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
          "type" : "string"
        },
        "scheduler" : {
          "description" : "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
          "default" : "none",
          "type" : "string"
        },
        "scheduler-properties" : {
          "description" : "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
          "type" : "string"
        },
        "send-empty-message-when-idle" : {
          "description" : "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
          "default" : "false",
          "type" : "boolean"
        },
        "start-scheduler" : {
          "description" : "Whether the scheduler should be auto started.",
          "default" : "true",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "time-unit" : {
          "description" : "Time unit for initialDelay and delay options.",
          "default" : "MILLISECONDS",
          "enum" : [ "NANOSECONDS", "MICROSECONDS", "MILLISECONDS", "SECONDS", "MINUTES", "HOURS", "DAYS" ],
          "type" : "string"
        },
        "use-fixed-delay" : {
          "description" : "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
          "default" : "true",
          "type" : "boolean"
        }
      }
    },
    "twitter-directmessage" : {
      "type" : "object",
      "required" : [ "user" ],
      "properties" : {
        "user" : {
          "description" : "The user name to send a direct message. This will be ignored for consumer.",
          "type" : "string"
        },
        "access-token" : {
          "description" : "The access token. Can also be configured on the TwitterComponent level instead.",
          "type" : "string"
        },
        "access-token-secret" : {
          "description" : "The access secret. Can also be configured on the TwitterComponent level instead.",
          "type" : "string"
        },
        "backoff-error-threshold" : {
          "description" : "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-idle-threshold" : {
          "description" : "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-multiplier" : {
          "description" : "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
          "type" : "integer"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "consumer-key" : {
          "description" : "The consumer key. Can also be configured on the TwitterComponent level instead.",
          "type" : "string"
        },
        "consumer-secret" : {
          "description" : "The consumer secret. Can also be configured on the TwitterComponent level instead.",
          "type" : "string"
        },
        "count" : {
          "description" : "Limiting number of results per page.",
          "default" : "5",
          "type" : "integer"
        },
        "delay" : {
          "description" : "Milliseconds before the next poll.",
          "default" : "30000",
          "type" : "string"
        },
        "distance-metric" : {
          "description" : "Used by the geography search, to search by radius using the configured metrics. The unit can either be mi for miles, or km for kilometers. You need to configure all the following options: longitude, latitude, radius, and distanceMetric.",
          "default" : "km",
          "enum" : [ "km", "mi" ],
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "extended-mode" : {
          "description" : "Used for enabling full text from twitter (eg receive tweets that contains more than 140 characters).",
          "default" : "true",
          "type" : "boolean"
        },
        "filter-old" : {
          "description" : "Filter out old tweets, that has previously been polled. This state is stored in memory only, and based on last tweet id.",
          "default" : "true",
          "type" : "boolean"
        },
        "greedy" : {
          "description" : "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
          "default" : "false",
          "type" : "boolean"
        },
        "http-proxy-host" : {
          "description" : "The http proxy host which can be used for the camel-twitter. Can also be configured on the TwitterComponent level instead.",
          "type" : "string"
        },
        "http-proxy-password" : {
          "description" : "The http proxy password which can be used for the camel-twitter. Can also be configured on the TwitterComponent level instead.",
          "type" : "string"
        },
        "http-proxy-port" : {
          "description" : "The http proxy port which can be used for the camel-twitter. Can also be configured on the TwitterComponent level instead.",
          "type" : "integer"
        },
        "http-proxy-user" : {
          "description" : "The http proxy user which can be used for the camel-twitter. Can also be configured on the TwitterComponent level instead.",
          "type" : "string"
        },
        "initial-delay" : {
          "description" : "Milliseconds before the first poll starts.",
          "default" : "1000",
          "type" : "integer"
        },
        "lang" : {
          "description" : "The lang string ISO_639-1 which will be used for searching",
          "type" : "string"
        },
        "latitude" : {
          "description" : "Used by the geography search to search by latitude. You need to configure all the following options: longitude, latitude, radius, and distanceMetric.",
          "type" : "number"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "locations" : {
          "description" : "Bounding boxes, created by pairs of lat/lons. Can be used for filter. A pair is defined as lat,lon. And multiple paris can be separated by semi colon.",
          "type" : "string"
        },
        "longitude" : {
          "description" : "Used by the geography search to search by longitude. You need to configure all the following options: longitude, latitude, radius, and distanceMetric.",
          "type" : "number"
        },
        "number-of-pages" : {
          "description" : "The number of pages result which you want camel-twitter to consume.",
          "default" : "1",
          "type" : "integer"
        },
        "poll-strategy" : {
          "description" : "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
          "type" : "string"
        },
        "radius" : {
          "description" : "Used by the geography search to search by radius. You need to configure all the following options: longitude, latitude, radius, and distanceMetric.",
          "type" : "number"
        },
        "repeat-count" : {
          "description" : "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
          "default" : "0",
          "type" : "integer"
        },
        "run-logging-level" : {
          "description" : "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
          "default" : "TRACE",
          "enum" : [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ],
          "type" : "string"
        },
        "scheduled-executor-service" : {
          "description" : "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
          "type" : "string"
        },
        "scheduler" : {
          "description" : "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
          "default" : "none",
          "type" : "string"
        },
        "scheduler-properties" : {
          "description" : "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
          "type" : "string"
        },
        "send-empty-message-when-idle" : {
          "description" : "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
          "default" : "false",
          "type" : "boolean"
        },
        "since-id" : {
          "description" : "The last tweet id which will be used for pulling the tweets. It is useful when the camel route is restarted after a long running.",
          "default" : "1",
          "type" : "integer"
        },
        "sort-by-id" : {
          "description" : "Sorts by id, so the oldest are first, and newest last.",
          "default" : "true",
          "type" : "boolean"
        },
        "start-scheduler" : {
          "description" : "Whether the scheduler should be auto started.",
          "default" : "true",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "time-unit" : {
          "description" : "Time unit for initialDelay and delay options.",
          "default" : "MILLISECONDS",
          "enum" : [ "NANOSECONDS", "MICROSECONDS", "MILLISECONDS", "SECONDS", "MINUTES", "HOURS", "DAYS" ],
          "type" : "string"
        },
        "type" : {
          "description" : "Endpoint type to use.",
          "default" : "polling",
          "enum" : [ "polling", "direct" ],
          "type" : "string"
        },
        "use-fixed-delay" : {
          "description" : "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
          "default" : "true",
          "type" : "boolean"
        },
        "user-ids" : {
          "description" : "To filter by user ids for filter. Multiple values can be separated by comma.",
          "type" : "string"
        }
      }
    },
    "twitter-search" : {
      "type" : "object",
      "required" : [ "keywords" ],
      "properties" : {
        "keywords" : {
          "description" : "The search query, use the keywords AND, OR, - and () to narrow the search results.",
          "type" : "string"
        },
        "access-token" : {
          "description" : "The access token. Can also be configured on the TwitterComponent level instead.",
          "type" : "string"
        },
        "access-token-secret" : {
          "description" : "The access secret. Can also be configured on the TwitterComponent level instead.",
          "type" : "string"
        },
        "backoff-error-threshold" : {
          "description" : "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-idle-threshold" : {
          "description" : "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-multiplier" : {
          "description" : "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
          "type" : "integer"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "consumer-key" : {
          "description" : "The consumer key. Can also be configured on the TwitterComponent level instead.",
          "type" : "string"
        },
        "consumer-secret" : {
          "description" : "The consumer secret. Can also be configured on the TwitterComponent level instead.",
          "type" : "string"
        },
        "count" : {
          "description" : "Limiting number of results per page.",
          "default" : "5",
          "type" : "integer"
        },
        "delay" : {
          "description" : "Milliseconds before the next poll.",
          "default" : "30000",
          "type" : "string"
        },
        "distance-metric" : {
          "description" : "Used by the geography search, to search by radius using the configured metrics. The unit can either be mi for miles, or km for kilometers. You need to configure all the following options: longitude, latitude, radius, and distanceMetric.",
          "default" : "km",
          "enum" : [ "km", "mi" ],
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "extended-mode" : {
          "description" : "Used for enabling full text from twitter (eg receive tweets that contains more than 140 characters).",
          "default" : "true",
          "type" : "boolean"
        },
        "filter-old" : {
          "description" : "Filter out old tweets, that has previously been polled. This state is stored in memory only, and based on last tweet id.",
          "default" : "true",
          "type" : "boolean"
        },
        "greedy" : {
          "description" : "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
          "default" : "false",
          "type" : "boolean"
        },
        "http-proxy-host" : {
          "description" : "The http proxy host which can be used for the camel-twitter. Can also be configured on the TwitterComponent level instead.",
          "type" : "string"
        },
        "http-proxy-password" : {
          "description" : "The http proxy password which can be used for the camel-twitter. Can also be configured on the TwitterComponent level instead.",
          "type" : "string"
        },
        "http-proxy-port" : {
          "description" : "The http proxy port which can be used for the camel-twitter. Can also be configured on the TwitterComponent level instead.",
          "type" : "integer"
        },
        "http-proxy-user" : {
          "description" : "The http proxy user which can be used for the camel-twitter. Can also be configured on the TwitterComponent level instead.",
          "type" : "string"
        },
        "initial-delay" : {
          "description" : "Milliseconds before the first poll starts.",
          "default" : "1000",
          "type" : "integer"
        },
        "lang" : {
          "description" : "The lang string ISO_639-1 which will be used for searching",
          "type" : "string"
        },
        "latitude" : {
          "description" : "Used by the geography search to search by latitude. You need to configure all the following options: longitude, latitude, radius, and distanceMetric.",
          "type" : "number"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "locations" : {
          "description" : "Bounding boxes, created by pairs of lat/lons. Can be used for filter. A pair is defined as lat,lon. And multiple paris can be separated by semi colon.",
          "type" : "string"
        },
        "longitude" : {
          "description" : "Used by the geography search to search by longitude. You need to configure all the following options: longitude, latitude, radius, and distanceMetric.",
          "type" : "number"
        },
        "number-of-pages" : {
          "description" : "The number of pages result which you want camel-twitter to consume.",
          "default" : "1",
          "type" : "integer"
        },
        "poll-strategy" : {
          "description" : "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
          "type" : "string"
        },
        "radius" : {
          "description" : "Used by the geography search to search by radius. You need to configure all the following options: longitude, latitude, radius, and distanceMetric.",
          "type" : "number"
        },
        "repeat-count" : {
          "description" : "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
          "default" : "0",
          "type" : "integer"
        },
        "run-logging-level" : {
          "description" : "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
          "default" : "TRACE",
          "enum" : [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ],
          "type" : "string"
        },
        "scheduled-executor-service" : {
          "description" : "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
          "type" : "string"
        },
        "scheduler" : {
          "description" : "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
          "default" : "none",
          "type" : "string"
        },
        "scheduler-properties" : {
          "description" : "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
          "type" : "string"
        },
        "send-empty-message-when-idle" : {
          "description" : "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
          "default" : "false",
          "type" : "boolean"
        },
        "since-id" : {
          "description" : "The last tweet id which will be used for pulling the tweets. It is useful when the camel route is restarted after a long running.",
          "default" : "1",
          "type" : "integer"
        },
        "sort-by-id" : {
          "description" : "Sorts by id, so the oldest are first, and newest last.",
          "default" : "true",
          "type" : "boolean"
        },
        "start-scheduler" : {
          "description" : "Whether the scheduler should be auto started.",
          "default" : "true",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "time-unit" : {
          "description" : "Time unit for initialDelay and delay options.",
          "default" : "MILLISECONDS",
          "enum" : [ "NANOSECONDS", "MICROSECONDS", "MILLISECONDS", "SECONDS", "MINUTES", "HOURS", "DAYS" ],
          "type" : "string"
        },
        "type" : {
          "description" : "Endpoint type to use.",
          "default" : "polling",
          "enum" : [ "polling", "direct" ],
          "type" : "string"
        },
        "use-fixed-delay" : {
          "description" : "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
          "default" : "true",
          "type" : "boolean"
        },
        "user-ids" : {
          "description" : "To filter by user ids for filter. Multiple values can be separated by comma.",
          "type" : "string"
        }
      }
    },
    "twitter-timeline" : {
      "type" : "object",
      "required" : [ "timelineType" ],
      "properties" : {
        "timeline-type" : {
          "description" : "The timeline type to produce/consume.",
          "enum" : [ "PUBLIC", "HOME", "USER", "MENTIONS", "RETWEETSOFME", "UNKNOWN" ],
          "type" : "string"
        },
        "access-token" : {
          "description" : "The access token. Can also be configured on the TwitterComponent level instead.",
          "type" : "string"
        },
        "access-token-secret" : {
          "description" : "The access secret. Can also be configured on the TwitterComponent level instead.",
          "type" : "string"
        },
        "backoff-error-threshold" : {
          "description" : "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-idle-threshold" : {
          "description" : "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-multiplier" : {
          "description" : "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
          "type" : "integer"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "consumer-key" : {
          "description" : "The consumer key. Can also be configured on the TwitterComponent level instead.",
          "type" : "string"
        },
        "consumer-secret" : {
          "description" : "The consumer secret. Can also be configured on the TwitterComponent level instead.",
          "type" : "string"
        },
        "count" : {
          "description" : "Limiting number of results per page.",
          "default" : "5",
          "type" : "integer"
        },
        "delay" : {
          "description" : "Milliseconds before the next poll.",
          "default" : "30000",
          "type" : "string"
        },
        "distance-metric" : {
          "description" : "Used by the geography search, to search by radius using the configured metrics. The unit can either be mi for miles, or km for kilometers. You need to configure all the following options: longitude, latitude, radius, and distanceMetric.",
          "default" : "km",
          "enum" : [ "km", "mi" ],
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "extended-mode" : {
          "description" : "Used for enabling full text from twitter (eg receive tweets that contains more than 140 characters).",
          "default" : "true",
          "type" : "boolean"
        },
        "filter-old" : {
          "description" : "Filter out old tweets, that has previously been polled. This state is stored in memory only, and based on last tweet id.",
          "default" : "true",
          "type" : "boolean"
        },
        "greedy" : {
          "description" : "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
          "default" : "false",
          "type" : "boolean"
        },
        "http-proxy-host" : {
          "description" : "The http proxy host which can be used for the camel-twitter. Can also be configured on the TwitterComponent level instead.",
          "type" : "string"
        },
        "http-proxy-password" : {
          "description" : "The http proxy password which can be used for the camel-twitter. Can also be configured on the TwitterComponent level instead.",
          "type" : "string"
        },
        "http-proxy-port" : {
          "description" : "The http proxy port which can be used for the camel-twitter. Can also be configured on the TwitterComponent level instead.",
          "type" : "integer"
        },
        "http-proxy-user" : {
          "description" : "The http proxy user which can be used for the camel-twitter. Can also be configured on the TwitterComponent level instead.",
          "type" : "string"
        },
        "initial-delay" : {
          "description" : "Milliseconds before the first poll starts.",
          "default" : "1000",
          "type" : "integer"
        },
        "lang" : {
          "description" : "The lang string ISO_639-1 which will be used for searching",
          "type" : "string"
        },
        "latitude" : {
          "description" : "Used by the geography search to search by latitude. You need to configure all the following options: longitude, latitude, radius, and distanceMetric.",
          "type" : "number"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "locations" : {
          "description" : "Bounding boxes, created by pairs of lat/lons. Can be used for filter. A pair is defined as lat,lon. And multiple paris can be separated by semi colon.",
          "type" : "string"
        },
        "longitude" : {
          "description" : "Used by the geography search to search by longitude. You need to configure all the following options: longitude, latitude, radius, and distanceMetric.",
          "type" : "number"
        },
        "number-of-pages" : {
          "description" : "The number of pages result which you want camel-twitter to consume.",
          "default" : "1",
          "type" : "integer"
        },
        "poll-strategy" : {
          "description" : "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
          "type" : "string"
        },
        "radius" : {
          "description" : "Used by the geography search to search by radius. You need to configure all the following options: longitude, latitude, radius, and distanceMetric.",
          "type" : "number"
        },
        "repeat-count" : {
          "description" : "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
          "default" : "0",
          "type" : "integer"
        },
        "run-logging-level" : {
          "description" : "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
          "default" : "TRACE",
          "enum" : [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ],
          "type" : "string"
        },
        "scheduled-executor-service" : {
          "description" : "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
          "type" : "string"
        },
        "scheduler" : {
          "description" : "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
          "default" : "none",
          "type" : "string"
        },
        "scheduler-properties" : {
          "description" : "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
          "type" : "string"
        },
        "send-empty-message-when-idle" : {
          "description" : "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
          "default" : "false",
          "type" : "boolean"
        },
        "since-id" : {
          "description" : "The last tweet id which will be used for pulling the tweets. It is useful when the camel route is restarted after a long running.",
          "default" : "1",
          "type" : "integer"
        },
        "sort-by-id" : {
          "description" : "Sorts by id, so the oldest are first, and newest last.",
          "default" : "true",
          "type" : "boolean"
        },
        "start-scheduler" : {
          "description" : "Whether the scheduler should be auto started.",
          "default" : "true",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "time-unit" : {
          "description" : "Time unit for initialDelay and delay options.",
          "default" : "MILLISECONDS",
          "enum" : [ "NANOSECONDS", "MICROSECONDS", "MILLISECONDS", "SECONDS", "MINUTES", "HOURS", "DAYS" ],
          "type" : "string"
        },
        "type" : {
          "description" : "Endpoint type to use.",
          "default" : "polling",
          "enum" : [ "polling", "direct" ],
          "type" : "string"
        },
        "use-fixed-delay" : {
          "description" : "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
          "default" : "true",
          "type" : "boolean"
        },
        "user" : {
          "description" : "The username when using timelineType=user",
          "type" : "string"
        },
        "user-ids" : {
          "description" : "To filter by user ids for filter. Multiple values can be separated by comma.",
          "type" : "string"
        }
      }
    },
    "undertow" : {
      "type" : "object",
      "required" : [ "httpURI" ],
      "properties" : {
        "http-uri" : {
          "description" : "The url of the HTTP endpoint to use.",
          "type" : "string"
        },
        "access-log" : {
          "description" : "Whether or not the consumer should write access log",
          "default" : "false",
          "type" : "boolean"
        },
        "access-log-receiver" : {
          "description" : "Which Undertow AccessLogReceiver should be used Will use JBossLoggingAccessLogReceiver if not specified",
          "type" : "string"
        },
        "allowed-roles" : {
          "description" : "Configuration used by UndertowSecurityProvider. Comma separated list of allowed roles.",
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "cookie-handler" : {
          "description" : "Configure a cookie handler to maintain a HTTP session",
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "fire-web-socket-channel-events" : {
          "description" : "if true, the consumer will post notifications to the route when a new WebSocket peer connects, disconnects, etc. See UndertowConstants.EVENT_TYPE and EventType.",
          "default" : "false",
          "type" : "boolean"
        },
        "handlers" : {
          "description" : "Specifies a comma-delimited set of io.undertow.server.HttpHandler instances to lookup in your Registry. These handlers are added to the Undertow handler chain (for example, to add security). Important: You can not use different handlers with different Undertow endpoints using the same port number. The handlers is associated to the port number. If you need different handlers, then use different port numbers.",
          "type" : "string"
        },
        "header-filter-strategy" : {
          "description" : "To use a custom HeaderFilterStrategy to filter header to and from Camel message.",
          "type" : "string"
        },
        "http-method-restrict" : {
          "description" : "Used to only allow consuming if the HttpMethod matches, such as GET/POST/PUT etc. Multiple methods can be specified separated by comma.",
          "type" : "string"
        },
        "keep-alive" : {
          "description" : "Setting to ensure socket is not closed due to inactivity",
          "default" : "true",
          "type" : "boolean"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "match-on-uri-prefix" : {
          "description" : "Whether or not the consumer should try to find a target consumer by matching the URI prefix if no exact match is found.",
          "default" : "false",
          "type" : "boolean"
        },
        "mute-exception" : {
          "description" : "If enabled and an Exchange failed processing on the consumer side the response's body won't contain the exception's stack trace.",
          "default" : "false",
          "type" : "boolean"
        },
        "options" : {
          "description" : "Sets additional channel options. The options that can be used are defined in org.xnio.Options. To configure from endpoint uri, then prefix each option with option., such as option.close-abort=true&option.send-buffer=8192",
          "type" : "string"
        },
        "options-enabled" : {
          "description" : "Specifies whether to enable HTTP OPTIONS for this Servlet consumer. By default OPTIONS is turned off.",
          "default" : "false",
          "type" : "boolean"
        },
        "preserve-host-header" : {
          "description" : "If the option is true, UndertowProducer will set the Host header to the value contained in the current exchange Host header, useful in reverse proxy applications where you want the Host header received by the downstream server to reflect the URL called by the upstream client, this allows applications which use the Host header to generate accurate URL's for a proxied service.",
          "default" : "true",
          "type" : "boolean"
        },
        "reuse-addresses" : {
          "description" : "Setting to facilitate socket multiplexing",
          "default" : "true",
          "type" : "boolean"
        },
        "security-configuration" : {
          "description" : "OConfiguration used by UndertowSecurityProvider. Security configuration object for use from UndertowSecurityProvider. Configuration is UndertowSecurityProvider specific. Each provider decides whether accepts configuration.",
          "type" : "string"
        },
        "security-provider" : {
          "description" : "Security provider allows plug in the provider, which will be used to secure requests. SPI approach could be used too (endpoint then finds security provider using SPI).",
          "type" : "string"
        },
        "send-timeout" : {
          "description" : "Timeout in milliseconds when sending to a websocket channel. The default timeout is 30000 (30 seconds).",
          "default" : "30000",
          "type" : "integer"
        },
        "send-to-all" : {
          "description" : "To send to all websocket subscribers. Can be used to configure on endpoint level, instead of having to use the UndertowConstants.SEND_TO_ALL header on the message.",
          "type" : "boolean"
        },
        "ssl-context-parameters" : {
          "description" : "To configure security using SSLContextParameters",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "tcp-no-delay" : {
          "description" : "Setting to improve TCP protocol performance",
          "default" : "true",
          "type" : "boolean"
        },
        "throw-exception-on-failure" : {
          "description" : "Option to disable throwing the HttpOperationFailedException in case of failed responses from the remote server. This allows you to get all responses regardless of the HTTP status code.",
          "default" : "true",
          "type" : "boolean"
        },
        "transfer-exception" : {
          "description" : "If enabled and an Exchange failed processing on the consumer side and if the caused Exception was send back serialized in the response as a application/x-java-serialized-object content type. On the producer side the exception will be deserialized and thrown as is instead of the HttpOperationFailedException. The caused exception is required to be serialized. This is by default turned off. If you enable this then be aware that Java will deserialize the incoming data from the request to Java and that can be a potential security risk.",
          "default" : "false",
          "type" : "boolean"
        },
        "undertow-http-binding" : {
          "description" : "To use a custom UndertowHttpBinding to control the mapping between Camel message and undertow.",
          "type" : "string"
        },
        "use-streaming" : {
          "description" : "For HTTP endpoint: if true, text and binary messages will be wrapped as java.io.InputStream before they are passed to an Exchange; otherwise they will be passed as byte. For WebSocket endpoint: if true, text and binary messages will be wrapped as java.io.Reader and java.io.InputStream respectively before they are passed to an Exchange; otherwise they will be passed as String and byte respectively.",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "validator" : {
      "type" : "object",
      "required" : [ "resourceUri" ],
      "properties" : {
        "resource-uri" : {
          "description" : "URL to a local resource on the classpath, or a reference to lookup a bean in the Registry, or a full URL to a remote resource or resource on the file system which contains the XSD to validate against.",
          "type" : "string"
        },
        "error-handler" : {
          "description" : "To use a custom org.apache.camel.processor.validation.ValidatorErrorHandler. The default error handler captures the errors and throws an exception.",
          "type" : "string"
        },
        "fail-on-null-body" : {
          "description" : "Whether to fail if no body exists.",
          "default" : "true",
          "type" : "boolean"
        },
        "fail-on-null-header" : {
          "description" : "Whether to fail if no header exists when validating against a header.",
          "default" : "true",
          "type" : "boolean"
        },
        "header-name" : {
          "description" : "To validate against a header instead of the message body.",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "resource-resolver" : {
          "description" : "To use a custom LSResourceResolver. Do not use together with resourceResolverFactory",
          "type" : "string"
        },
        "resource-resolver-factory" : {
          "description" : "To use a custom LSResourceResolver which depends on a dynamic endpoint resource URI. The default resource resolver factory resturns a resource resolver which can read files from the class path and file system. Do not use together with resourceResolver.",
          "type" : "string"
        },
        "schema-factory" : {
          "description" : "To use a custom javax.xml.validation.SchemaFactory",
          "type" : "string"
        },
        "schema-language" : {
          "description" : "Configures the W3C XML Schema Namespace URI.",
          "default" : "http://www.w3.org/2001/XMLSchema",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "use-shared-schema" : {
          "description" : "Whether the Schema instance should be shared or not. This option is introduced to work around a JDK 1.6.x bug. Xerces should not have this issue.",
          "default" : "true",
          "type" : "boolean"
        }
      }
    },
    "velocity" : {
      "type" : "object",
      "required" : [ "resourceUri" ],
      "properties" : {
        "resource-uri" : {
          "description" : "Path to the resource. You can prefix with: classpath, file, http, ref, or bean. classpath, file and http loads the resource using these protocols (classpath is default). ref will lookup the resource in the registry. bean will call a method on a bean to be used as the resource. For bean you can specify the method name after dot, eg bean:myBean.myMethod.",
          "type" : "string"
        },
        "allow-context-map-all" : {
          "description" : "Sets whether the context map should allow access to all details. By default only the message body and headers can be accessed. This option can be enabled for full access to the current Exchange and CamelContext. Doing so impose a potential security risk as this opens access to the full power of CamelContext API.",
          "default" : "false",
          "type" : "boolean"
        },
        "allow-template-from-header" : {
          "description" : "Whether to allow to use resource template from header or not (default false). Enabling this allows to specify dynamic templates via message header. However this can be seen as a potential security vulnerability if the header is coming from a malicious user, so use this with care.",
          "default" : "false",
          "type" : "boolean"
        },
        "content-cache" : {
          "description" : "Sets whether to use resource content cache or not",
          "default" : "false",
          "type" : "boolean"
        },
        "encoding" : {
          "description" : "Character encoding of the resource content.",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "loader-cache" : {
          "description" : "Enables / disables the velocity resource loader cache which is enabled by default",
          "default" : "true",
          "type" : "boolean"
        },
        "properties-file" : {
          "description" : "The URI of the properties file which is used for VelocityEngine initialization.",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "vertx" : {
      "type" : "object",
      "required" : [ "address" ],
      "properties" : {
        "address" : {
          "description" : "Sets the event bus address used to communicate",
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "pub-sub" : {
          "description" : "Whether to use publish/subscribe instead of point to point when sending to a vertx endpoint.",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "vertx-http" : {
      "type" : "object",
      "required" : [ "httpUri" ],
      "properties" : {
        "http-uri" : {
          "description" : "The HTTP URI to connect to",
          "type" : "string"
        },
        "basic-auth-password" : {
          "description" : "The password to use for basic authentication",
          "type" : "string"
        },
        "basic-auth-username" : {
          "description" : "The user name to use for basic authentication",
          "type" : "string"
        },
        "bearer-token" : {
          "description" : "The bearer token to use for bearer token authentication",
          "type" : "string"
        },
        "connect-timeout" : {
          "description" : "The amount of time in milliseconds until a connection is established. A timeout value of zero is interpreted as an infinite timeout.",
          "default" : "60000",
          "type" : "integer"
        },
        "cookie-store" : {
          "description" : "A custom CookieStore to use when session management is enabled. If this option is not set then an in-memory CookieStore is used",
          "default" : "InMemoryCookieStore",
          "type" : "string"
        },
        "header-filter-strategy" : {
          "description" : "A custom org.apache.camel.spi.HeaderFilterStrategy to filter header to and from Camel message.",
          "default" : "VertxHttpHeaderFilterStrategy",
          "type" : "string"
        },
        "http-method" : {
          "description" : "The HTTP method to use. The HttpMethod header cannot override this option if set",
          "enum" : [ "OPTIONS", "GET", "HEAD", "POST", "PUT", "DELETE", "TRACE", "CONNECT", "PATCH", "OTHER" ],
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "ok-status-code-range" : {
          "description" : "The status codes which are considered a success response. The values are inclusive. Multiple ranges can be defined, separated by comma, e.g. 200-204,209,301-304. Each range must be a single number or from-to with the dash included",
          "default" : "200-299",
          "type" : "string"
        },
        "proxy-host" : {
          "description" : "The proxy server host address",
          "type" : "string"
        },
        "proxy-password" : {
          "description" : "The proxy server password if authentication is required",
          "type" : "string"
        },
        "proxy-port" : {
          "description" : "The proxy server port",
          "type" : "integer"
        },
        "proxy-type" : {
          "description" : "The proxy server type",
          "enum" : [ "HTTP", "SOCKS4", "SOCKS5" ],
          "type" : "string"
        },
        "proxy-username" : {
          "description" : "The proxy server username if authentication is required",
          "type" : "string"
        },
        "session-management" : {
          "description" : "Enables session management via WebClientSession. By default the client is configured to use an in-memory CookieStore. The cookieStore option can be used to override this",
          "default" : "false",
          "type" : "boolean"
        },
        "ssl-context-parameters" : {
          "description" : "To configure security using SSLContextParameters",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "throw-exception-on-failure" : {
          "description" : "Disable throwing HttpOperationFailedException in case of failed responses from the remote server",
          "default" : "true",
          "type" : "boolean"
        },
        "timeout" : {
          "description" : "The amount of time in milliseconds after which if the request does not return any data within the timeout period a TimeoutException fails the request. Setting zero or a negative value disables the timeout.",
          "default" : "-1",
          "type" : "integer"
        },
        "transfer-exception" : {
          "description" : "If enabled and an Exchange failed processing on the consumer side, and if the caused Exception was sent back serialized in the response as a application/x-java-serialized-object content type. On the producer side the exception will be deserialized and thrown as is, instead of HttpOperationFailedException. The caused exception is required to be serialized. This is by default turned off. If you enable this then be aware that Camel will deserialize the incoming data from the request to a Java object, which can be a potential security risk.",
          "default" : "false",
          "type" : "boolean"
        },
        "use-compression" : {
          "description" : "Set whether compression is enabled to handled compressed (E.g gzipped) responses",
          "default" : "false",
          "type" : "boolean"
        },
        "vertx-http-binding" : {
          "description" : "A custom VertxHttpBinding which can control how to bind between Vert.x and Camel.",
          "type" : "string"
        },
        "web-client-options" : {
          "description" : "Sets customized options for configuring the Vert.x WebClient",
          "type" : "string"
        }
      }
    },
    "vertx-kafka" : {
      "type" : "object",
      "required" : [ "topic" ],
      "properties" : {
        "topic" : {
          "description" : "Name of the topic to use. On the consumer you can use comma to separate multiple topics. A producer can only send a message to a single topic.",
          "type" : "string"
        },
        "acks" : {
          "description" : "The number of acknowledgments the producer requires the leader to have received before considering a request complete. This controls the durability of records that are sent. The following settings are allowed: acks=0 If set to zero then the producer will not wait for any acknowledgment from the server at all. The record will be immediately added to the socket buffer and considered sent. No guarantee can be made that the server has received the record in this case, and the retries configuration will not take effect (as the client won't generally know of any failures). The offset given back for each record will always be set to -1. acks=1 This will mean the leader will write the record to its local log but will respond without awaiting full acknowledgement from all followers. In this case should the leader fail immediately after acknowledging the record but before the followers have replicated it then the record will be lost. acks=all This means the leader will wait for the full set of in-sync replicas to acknowledge the record. This guarantees that the record will not be lost as long as at least one in-sync replica remains alive. This is the strongest available guarantee. This is equivalent to the acks=-1 setting.",
          "default" : "1",
          "enum" : [ "all", "-1", "0", "1" ],
          "type" : "string"
        },
        "additional-properties" : {
          "description" : "Sets additional properties for either kafka consumer or kafka producer in case they can't be set directly on the camel configurations (e.g: new Kafka properties that are not reflected yet in Camel configurations), the properties have to be prefixed with additionalProperties.. E.g: additionalProperties.transactional.id=12345&additionalProperties.schema.registry.url=http://localhost:8811/avro",
          "type" : "string"
        },
        "allow-auto-create-topics" : {
          "description" : "Allow automatic topic creation on the broker when subscribing to or assigning a topic. A topic being subscribed to will be automatically created only if the broker allows for it using auto.create.topics.enable broker configuration. This configuration must be set to false when using brokers older than 0.11.0",
          "default" : "true",
          "type" : "boolean"
        },
        "auto-commit-interval-ms" : {
          "description" : "The frequency in milliseconds that the consumer offsets are auto-committed to Kafka if enable.auto.commit is set to true.",
          "default" : "5s",
          "type" : "string"
        },
        "auto-offset-reset" : {
          "description" : "What to do when there is no initial offset in Kafka or if the current offset does not exist any more on the server (e.g. because that data has been deleted): earliest: automatically reset the offset to the earliest offsetlatest: automatically reset the offset to the latest offsetnone: throw exception to the consumer if no previous offset is found for the consumer's groupanything else: throw exception to the consumer.",
          "default" : "latest",
          "enum" : [ "latest", "earliest", "none" ],
          "type" : "string"
        },
        "batch-size" : {
          "description" : "The producer will attempt to batch records together into fewer requests whenever multiple records are being sent to the same partition. This helps performance on both the client and the server. This configuration controls the default batch size in bytes. No attempt will be made to batch records larger than this size. Requests sent to brokers will contain multiple batches, one for each partition with data available to be sent. A small batch size will make batching less common and may reduce throughput (a batch size of zero will disable batching entirely). A very large batch size may use memory a bit more wastefully as we will always allocate a buffer of the specified batch size in anticipation of additional records.",
          "default" : "16384",
          "type" : "integer"
        },
        "bootstrap-servers" : {
          "description" : "A list of host/port pairs to use for establishing the initial connection to the Kafka cluster. The client will make use of all servers irrespective of which servers are specified here for bootstrapping&mdash;this list only impacts the initial hosts used to discover the full set of servers. This list should be in the form host1:port1,host2:port2,.... Since these servers are just used for the initial connection to discover the full cluster membership (which may change dynamically), this list need not contain the full set of servers (you may want more than one, though, in case a server is down).",
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "buffer-memory" : {
          "description" : "The total bytes of memory the producer can use to buffer records waiting to be sent to the server. If records are sent faster than they can be delivered to the server the producer will block for max.block.ms after which it will throw an exception.This setting should correspond roughly to the total memory the producer will use, but is not a hard bound since not all memory the producer uses is used for buffering. Some additional memory will be used for compression (if compression is enabled) as well as for maintaining in-flight requests.",
          "default" : "33554432",
          "type" : "integer"
        },
        "check-crcs" : {
          "description" : "Automatically check the CRC32 of the records consumed. This ensures no on-the-wire or on-disk corruption to the messages occurred. This check adds some overhead, so it may be disabled in cases seeking extreme performance.",
          "default" : "true",
          "type" : "boolean"
        },
        "client-dns-lookup" : {
          "description" : "Controls how the client uses DNS lookups. If set to use_all_dns_ips, connect to each returned IP address in sequence until a successful connection is established. After a disconnection, the next IP is used. Once all IPs have been used once, the client resolves the IP(s) from the hostname again (both the JVM and the OS cache DNS name lookups, however). If set to resolve_canonical_bootstrap_servers_only, resolve each bootstrap address into a list of canonical names. After the bootstrap phase, this behaves the same as use_all_dns_ips. If set to default (deprecated), attempt to connect to the first IP address returned by the lookup, even if the lookup returns multiple IP addresses.",
          "default" : "use_all_dns_ips",
          "enum" : [ "default", "use_all_dns_ips", "resolve_canonical_bootstrap_servers_only" ],
          "type" : "string"
        },
        "client-id" : {
          "description" : "An id string to pass to the server when making requests. The purpose of this is to be able to track the source of requests beyond just ip/port by allowing a logical application name to be included in server-side request logging.",
          "type" : "string"
        },
        "client-rack" : {
          "description" : "A rack identifier for this client. This can be any string value which indicates where this client is physically located. It corresponds with the broker config 'broker.rack'",
          "type" : "string"
        },
        "compression-type" : {
          "description" : "The compression type for all data generated by the producer. The default is none (i.e. no compression). Valid values are none, gzip, snappy, lz4, or zstd. Compression is of full batches of data, so the efficacy of batching will also impact the compression ratio (more batching means better compression).",
          "default" : "none",
          "type" : "string"
        },
        "connections-max-idle-ms" : {
          "description" : "Close idle connections after the number of milliseconds specified by this config.",
          "default" : "9m",
          "type" : "string"
        },
        "default-api-timeout-ms" : {
          "description" : "Specifies the timeout (in milliseconds) for client APIs. This configuration is used as the default timeout for all client operations that do not specify a timeout parameter.",
          "default" : "1m",
          "type" : "string"
        },
        "delivery-timeout-ms" : {
          "description" : "An upper bound on the time to report success or failure after a call to send() returns. This limits the total time that a record will be delayed prior to sending, the time to await acknowledgement from the broker (if expected), and the time allowed for retriable send failures. The producer may report failure to send a record earlier than this config if either an unrecoverable error is encountered, the retries have been exhausted, or the record is added to a batch which reached an earlier delivery expiration deadline. The value of this config should be greater than or equal to the sum of request.timeout.ms and linger.ms.",
          "default" : "2m",
          "type" : "string"
        },
        "enable-auto-commit" : {
          "description" : "If true the consumer's offset will be periodically committed in the background.",
          "default" : "true",
          "type" : "boolean"
        },
        "enable-idempotence" : {
          "description" : "When set to 'true', the producer will ensure that exactly one copy of each message is written in the stream. If 'false', producer retries due to broker failures, etc., may write duplicates of the retried message in the stream. Note that enabling idempotence requires max.in.flight.requests.per.connection to be less than or equal to 5, retries to be greater than 0 and acks must be 'all'. If these values are not explicitly set by the user, suitable values will be chosen. If incompatible values are set, a ConfigException will be thrown.",
          "default" : "false",
          "type" : "boolean"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "exclude-internal-topics" : {
          "description" : "Whether internal topics matching a subscribed pattern should be excluded from the subscription. It is always possible to explicitly subscribe to an internal topic.",
          "default" : "true",
          "type" : "boolean"
        },
        "fetch-max-bytes" : {
          "description" : "The maximum amount of data the server should return for a fetch request. Records are fetched in batches by the consumer, and if the first record batch in the first non-empty partition of the fetch is larger than this value, the record batch will still be returned to ensure that the consumer can make progress. As such, this is not a absolute maximum. The maximum record batch size accepted by the broker is defined via message.max.bytes (broker config) or max.message.bytes (topic config). Note that the consumer performs multiple fetches in parallel.",
          "default" : "52428800",
          "type" : "integer"
        },
        "fetch-max-wait-ms" : {
          "description" : "The maximum amount of time the server will block before answering the fetch request if there isn't sufficient data to immediately satisfy the requirement given by fetch.min.bytes.",
          "default" : "500ms",
          "type" : "string"
        },
        "fetch-min-bytes" : {
          "description" : "The minimum amount of data the server should return for a fetch request. If insufficient data is available the request will wait for that much data to accumulate before answering the request. The default setting of 1 byte means that fetch requests are answered as soon as a single byte of data is available or the fetch request times out waiting for data to arrive. Setting this to something greater than 1 will cause the server to wait for larger amounts of data to accumulate which can improve server throughput a bit at the cost of some additional latency.",
          "default" : "1",
          "type" : "integer"
        },
        "group-id" : {
          "description" : "A unique string that identifies the consumer group this consumer belongs to. This property is required if the consumer uses either the group management functionality by using subscribe(topic) or the Kafka-based offset management strategy.",
          "type" : "string"
        },
        "group-instance-id" : {
          "description" : "A unique identifier of the consumer instance provided by the end user. Only non-empty strings are permitted. If set, the consumer is treated as a static member, which means that only one instance with this ID is allowed in the consumer group at any time. This can be used in combination with a larger session timeout to avoid group rebalances caused by transient unavailability (e.g. process restarts). If not set, the consumer will join the group as a dynamic member, which is the traditional behavior.",
          "type" : "string"
        },
        "header-filter-strategy" : {
          "description" : "To use a custom HeaderFilterStrategy to filter header to and from Camel message.",
          "type" : "string"
        },
        "heartbeat-interval-ms" : {
          "description" : "The expected time between heartbeats to the consumer coordinator when using Kafka's group management facilities. Heartbeats are used to ensure that the consumer's session stays active and to facilitate rebalancing when new consumers join or leave the group. The value must be set lower than session.timeout.ms, but typically should be set no higher than 1/3 of that value. It can be adjusted even lower to control the expected time for normal rebalances.",
          "default" : "3s",
          "type" : "string"
        },
        "interceptor-classes" : {
          "description" : "A list of classes to use as interceptors. Implementing the org.apache.kafka.clients.producer.ProducerInterceptor interface allows you to intercept (and possibly mutate) the records received by the producer before they are published to the Kafka cluster. By default, there are no interceptors.",
          "type" : "string"
        },
        "isolation-level" : {
          "description" : "Controls how to read messages written transactionally. If set to read_committed, consumer.poll() will only return transactional messages which have been committed. If set to read_uncommitted' (the default), consumer.poll() will return all messages, even transactional messages which have been aborted. Non-transactional messages will be returned unconditionally in either mode. Messages will always be returned in offset order. Hence, in read_committed mode, consumer.poll() will only return messages up to the last stable offset (LSO), which is the one less than the offset of the first open transaction. In particular any messages appearing after messages belonging to ongoing transactions will be withheld until the relevant transaction has been completed. As a result, read_committed consumers will not be able to read up to the high watermark when there are in flight transactions. Further, when in read_committed the seekToEnd method will return the LSO",
          "default" : "read_uncommitted",
          "enum" : [ "read_committed", "read_uncommitted" ],
          "type" : "string"
        },
        "key-deserializer" : {
          "description" : "Deserializer class for key that implements the org.apache.kafka.common.serialization.Deserializer interface.",
          "default" : "org.apache.kafka.common.serialization.StringDeserializer",
          "type" : "string"
        },
        "key-serializer" : {
          "description" : "Serializer class for key that implements the org.apache.kafka.common.serialization.Serializer interface.",
          "default" : "org.apache.kafka.common.serialization.StringSerializer",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "linger-ms" : {
          "description" : "The producer groups together any records that arrive in between request transmissions into a single batched request. Normally this occurs only under load when records arrive faster than they can be sent out. However in some circumstances the client may want to reduce the number of requests even under moderate load. This setting accomplishes this by adding a small amount of artificial delay&mdash;that is, rather than immediately sending out a record the producer will wait for up to the given delay to allow other records to be sent so that the sends can be batched together. This can be thought of as analogous to Nagle's algorithm in TCP. This setting gives the upper bound on the delay for batching: once we get batch.size worth of records for a partition it will be sent immediately regardless of this setting, however if we have fewer than this many bytes accumulated for this partition we will 'linger' for the specified time waiting for more records to show up. This setting defaults to 0 (i.e. no delay). Setting linger.ms=5, for example, would have the effect of reducing the number of requests sent but would add up to 5ms of latency to records sent in the absence of load.",
          "default" : "0ms",
          "type" : "string"
        },
        "max-block-ms" : {
          "description" : "The configuration controls how long KafkaProducer.send() and KafkaProducer.partitionsFor() will block.These methods can be blocked either because the buffer is full or metadata unavailable.Blocking in the user-supplied serializers or partitioner will not be counted against this timeout.",
          "default" : "1m",
          "type" : "string"
        },
        "max-in-flight-requests-per-connection" : {
          "description" : "The maximum number of unacknowledged requests the client will send on a single connection before blocking. Note that if this setting is set to be greater than 1 and there are failed sends, there is a risk of message re-ordering due to retries (i.e., if retries are enabled).",
          "default" : "5",
          "type" : "integer"
        },
        "max-partition-fetch-bytes" : {
          "description" : "The maximum amount of data per-partition the server will return. Records are fetched in batches by the consumer. If the first record batch in the first non-empty partition of the fetch is larger than this limit, the batch will still be returned to ensure that the consumer can make progress. The maximum record batch size accepted by the broker is defined via message.max.bytes (broker config) or max.message.bytes (topic config). See fetch.max.bytes for limiting the consumer request size.",
          "default" : "1048576",
          "type" : "integer"
        },
        "max-poll-interval-ms" : {
          "description" : "The maximum delay between invocations of poll() when using consumer group management. This places an upper bound on the amount of time that the consumer can be idle before fetching more records. If poll() is not called before expiration of this timeout, then the consumer is considered failed and the group will rebalance in order to reassign the partitions to another member. For consumers using a non-null group.instance.id which reach this timeout, partitions will not be immediately reassigned. Instead, the consumer will stop sending heartbeats and partitions will be reassigned after expiration of session.timeout.ms. This mirrors the behavior of a static consumer which has shutdown.",
          "default" : "5m",
          "type" : "string"
        },
        "max-poll-records" : {
          "description" : "The maximum number of records returned in a single call to poll().",
          "default" : "500",
          "type" : "integer"
        },
        "max-request-size" : {
          "description" : "The maximum size of a request in bytes. This setting will limit the number of record batches the producer will send in a single request to avoid sending huge requests. This is also effectively a cap on the maximum uncompressed record batch size. Note that the server has its own cap on the record batch size (after compression if compression is enabled) which may be different from this.",
          "default" : "1048576",
          "type" : "integer"
        },
        "metadata-max-age-ms" : {
          "description" : "The period of time in milliseconds after which we force a refresh of metadata even if we haven't seen any partition leadership changes to proactively discover any new brokers or partitions.",
          "default" : "5m",
          "type" : "string"
        },
        "metadata-max-idle-ms" : {
          "description" : "Controls how long the producer will cache metadata for a topic that's idle. If the elapsed time since a topic was last produced to exceeds the metadata idle duration, then the topic's metadata is forgotten and the next access to it will force a metadata fetch request.",
          "default" : "5m",
          "type" : "string"
        },
        "metric-reporters" : {
          "description" : "A list of classes to use as metrics reporters. Implementing the org.apache.kafka.common.metrics.MetricsReporter interface allows plugging in classes that will be notified of new metric creation. The JmxReporter is always included to register JMX statistics.",
          "type" : "string"
        },
        "metrics-num-samples" : {
          "description" : "The number of samples maintained to compute metrics.",
          "default" : "2",
          "type" : "integer"
        },
        "metrics-recording-level" : {
          "description" : "The highest recording level for metrics.",
          "default" : "INFO",
          "enum" : [ "INFO", "DEBUG" ],
          "type" : "string"
        },
        "metrics-sample-window-ms" : {
          "description" : "The window of time a metrics sample is computed over.",
          "default" : "30s",
          "type" : "string"
        },
        "partition-assignment-strategy" : {
          "description" : "A list of class names or class types, ordered by preference, of supported partition assignment strategies that the client will use to distribute partition ownership amongst consumer instances when group management is used.In addition to the default class specified below, you can use the org.apache.kafka.clients.consumer.RoundRobinAssignorclass for round robin assignments of partitions to consumers. Implementing the org.apache.kafka.clients.consumer.ConsumerPartitionAssignor interface allows you to plug in a custom assignmentstrategy.",
          "default" : "org.apache.kafka.clients.consumer.RangeAssignor",
          "type" : "string"
        },
        "partition-id" : {
          "description" : "The partition to which the record will be sent (or null if no partition was specified) or read from a particular partition if set. Header VertxKafkaConstants#PARTITION_ID If configured, it will take precedence over this config",
          "type" : "integer"
        },
        "partitioner-class" : {
          "description" : "Partitioner class that implements the org.apache.kafka.clients.producer.Partitioner interface.",
          "default" : "org.apache.kafka.clients.producer.internals.DefaultPartitioner",
          "type" : "string"
        },
        "receive-buffer-bytes" : {
          "description" : "The size of the TCP receive buffer (SO_RCVBUF) to use when reading data. If the value is -1, the OS default will be used.",
          "default" : "32768",
          "type" : "integer"
        },
        "reconnect-backoff-max-ms" : {
          "description" : "The maximum amount of time in milliseconds to wait when reconnecting to a broker that has repeatedly failed to connect. If provided, the backoff per host will increase exponentially for each consecutive connection failure, up to this maximum. After calculating the backoff increase, 20% random jitter is added to avoid connection storms.",
          "default" : "1s",
          "type" : "string"
        },
        "reconnect-backoff-ms" : {
          "description" : "The base amount of time to wait before attempting to reconnect to a given host. This avoids repeatedly connecting to a host in a tight loop. This backoff applies to all connection attempts by the client to a broker.",
          "default" : "50ms",
          "type" : "string"
        },
        "request-timeout-ms" : {
          "description" : "The configuration controls the maximum amount of time the client will wait for the response of a request. If the response is not received before the timeout elapses the client will resend the request if necessary or fail the request if retries are exhausted. This should be larger than replica.lag.time.max.ms (a broker configuration) to reduce the possibility of message duplication due to unnecessary producer retries.",
          "default" : "30s",
          "type" : "string"
        },
        "retries" : {
          "description" : "Setting a value greater than zero will cause the client to resend any record whose send fails with a potentially transient error. Note that this retry is no different than if the client resent the record upon receiving the error. Allowing retries without setting max.in.flight.requests.per.connection to 1 will potentially change the ordering of records because if two batches are sent to a single partition, and the first fails and is retried but the second succeeds, then the records in the second batch may appear first. Note additionally that produce requests will be failed before the number of retries has been exhausted if the timeout configured by delivery.timeout.ms expires first before successful acknowledgement. Users should generally prefer to leave this config unset and instead use delivery.timeout.ms to control retry behavior.",
          "default" : "2147483647",
          "type" : "integer"
        },
        "retry-backoff-ms" : {
          "description" : "The amount of time to wait before attempting to retry a failed request to a given topic partition. This avoids repeatedly sending requests in a tight loop under some failure scenarios.",
          "default" : "100ms",
          "type" : "string"
        },
        "sasl-client-callback-handler-class" : {
          "description" : "The fully qualified name of a SASL client callback handler class that implements the AuthenticateCallbackHandler interface.",
          "type" : "string"
        },
        "sasl-jaas-config" : {
          "description" : "JAAS login context parameters for SASL connections in the format used by JAAS configuration files. JAAS configuration file format is described here. The format for the value is: 'loginModuleClass controlFlag (optionName=optionValue);'. For brokers, the config must be prefixed with listener prefix and SASL mechanism name in lower-case. For example, listener.name.sasl_ssl.scram-sha-256.sasl.jaas.config=com.example.ScramLoginModule required;",
          "type" : "string"
        },
        "sasl-kerberos-kinit-cmd" : {
          "description" : "Kerberos kinit command path.",
          "default" : "/usr/bin/kinit",
          "type" : "string"
        },
        "sasl-kerberos-min-time-before-relogin" : {
          "description" : "Login thread sleep time between refresh attempts.",
          "default" : "60000",
          "type" : "integer"
        },
        "sasl-kerberos-service-name" : {
          "description" : "The Kerberos principal name that Kafka runs as. This can be defined either in Kafka's JAAS config or in Kafka's config.",
          "type" : "string"
        },
        "sasl-kerberos-ticket-renew-jitter" : {
          "description" : "Percentage of random jitter added to the renewal time.",
          "default" : "0.05",
          "type" : "number"
        },
        "sasl-kerberos-ticket-renew-window-factor" : {
          "description" : "Login thread will sleep until the specified window factor of time from last refresh to ticket's expiry has been reached, at which time it will try to renew the ticket.",
          "default" : "0.8",
          "type" : "number"
        },
        "sasl-login-callback-handler-class" : {
          "description" : "The fully qualified name of a SASL login callback handler class that implements the AuthenticateCallbackHandler interface. For brokers, login callback handler config must be prefixed with listener prefix and SASL mechanism name in lower-case. For example, listener.name.sasl_ssl.scram-sha-256.sasl.login.callback.handler.class=com.example.CustomScramLoginCallbackHandler",
          "type" : "string"
        },
        "sasl-login-class" : {
          "description" : "The fully qualified name of a class that implements the Login interface. For brokers, login config must be prefixed with listener prefix and SASL mechanism name in lower-case. For example, listener.name.sasl_ssl.scram-sha-256.sasl.login.class=com.example.CustomScramLogin",
          "type" : "string"
        },
        "sasl-login-refresh-buffer-seconds" : {
          "description" : "The amount of buffer time before credential expiration to maintain when refreshing a credential, in seconds. If a refresh would otherwise occur closer to expiration than the number of buffer seconds then the refresh will be moved up to maintain as much of the buffer time as possible. Legal values are between 0 and 3600 (1 hour); a default value of 300 (5 minutes) is used if no value is specified. This value and sasl.login.refresh.min.period.seconds are both ignored if their sum exceeds the remaining lifetime of a credential. Currently applies only to OAUTHBEARER.",
          "default" : "300",
          "type" : "integer"
        },
        "sasl-login-refresh-min-period-seconds" : {
          "description" : "The desired minimum time for the login refresh thread to wait before refreshing a credential, in seconds. Legal values are between 0 and 900 (15 minutes); a default value of 60 (1 minute) is used if no value is specified. This value and sasl.login.refresh.buffer.seconds are both ignored if their sum exceeds the remaining lifetime of a credential. Currently applies only to OAUTHBEARER.",
          "default" : "60",
          "type" : "integer"
        },
        "sasl-login-refresh-window-factor" : {
          "description" : "Login refresh thread will sleep until the specified window factor relative to the credential's lifetime has been reached, at which time it will try to refresh the credential. Legal values are between 0.5 (50%) and 1.0 (100%) inclusive; a default value of 0.8 (80%) is used if no value is specified. Currently applies only to OAUTHBEARER.",
          "default" : "0.8",
          "type" : "number"
        },
        "sasl-login-refresh-window-jitter" : {
          "description" : "The maximum amount of random jitter relative to the credential's lifetime that is added to the login refresh thread's sleep time. Legal values are between 0 and 0.25 (25%) inclusive; a default value of 0.05 (5%) is used if no value is specified. Currently applies only to OAUTHBEARER.",
          "default" : "0.05",
          "type" : "number"
        },
        "sasl-mechanism" : {
          "description" : "SASL mechanism used for client connections. This may be any mechanism for which a security provider is available. GSSAPI is the default mechanism.",
          "default" : "GSSAPI",
          "type" : "string"
        },
        "security-protocol" : {
          "description" : "Protocol used to communicate with brokers. Valid values are: PLAINTEXT, SSL, SASL_PLAINTEXT, SASL_SSL.",
          "default" : "PLAINTEXT",
          "type" : "string"
        },
        "security-providers" : {
          "description" : "A list of configurable creator classes each returning a provider implementing security algorithms. These classes should implement the org.apache.kafka.common.security.auth.SecurityProviderCreator interface.",
          "type" : "string"
        },
        "seek-to-offset" : {
          "description" : "Set if KafkaConsumer will read from a particular offset on startup. This config will take precedence over seekTo config",
          "type" : "integer"
        },
        "seek-to-position" : {
          "description" : "Set if KafkaConsumer will read from beginning or end on startup: beginning : read from beginning end : read from end.",
          "enum" : [ "beginning", "end" ],
          "type" : "string"
        },
        "send-buffer-bytes" : {
          "description" : "The size of the TCP send buffer (SO_SNDBUF) to use when sending data. If the value is -1, the OS default will be used.",
          "default" : "131072",
          "type" : "integer"
        },
        "session-timeout-ms" : {
          "description" : "The timeout used to detect client failures when using Kafka's group management facility. The client sends periodic heartbeats to indicate its liveness to the broker. If no heartbeats are received by the broker before the expiration of this session timeout, then the broker will remove this client from the group and initiate a rebalance. Note that the value must be in the allowable range as configured in the broker configuration by group.min.session.timeout.ms and group.max.session.timeout.ms.",
          "default" : "10s",
          "type" : "string"
        },
        "ssl-cipher-suites" : {
          "description" : "A list of cipher suites. This is a named combination of authentication, encryption, MAC and key exchange algorithm used to negotiate the security settings for a network connection using TLS or SSL network protocol. By default all the available cipher suites are supported.",
          "type" : "string"
        },
        "ssl-enabled-protocols" : {
          "description" : "The list of protocols enabled for SSL connections. The default is 'TLSv1.2,TLSv1.3' when running with Java 11 or newer, 'TLSv1.2' otherwise. With the default value for Java 11, clients and servers will prefer TLSv1.3 if both support it and fallback to TLSv1.2 otherwise (assuming both support at least TLSv1.2). This default should be fine for most cases. Also see the config documentation for ssl.protocol.",
          "default" : "TLSv1.2,TLSv1.3",
          "type" : "string"
        },
        "ssl-endpoint-identification-algorithm" : {
          "description" : "The endpoint identification algorithm to validate server hostname using server certificate.",
          "default" : "https",
          "type" : "string"
        },
        "ssl-engine-factory-class" : {
          "description" : "The class of type org.apache.kafka.common.security.auth.SslEngineFactory to provide SSLEngine objects. Default value is org.apache.kafka.common.security.ssl.DefaultSslEngineFactory",
          "type" : "string"
        },
        "ssl-key-password" : {
          "description" : "The password of the private key in the key store file. This is optional for client.",
          "type" : "string"
        },
        "ssl-keymanager-algorithm" : {
          "description" : "The algorithm used by key manager factory for SSL connections. Default value is the key manager factory algorithm configured for the Java Virtual Machine.",
          "default" : "SunX509",
          "type" : "string"
        },
        "ssl-keystore-location" : {
          "description" : "The location of the key store file. This is optional for client and can be used for two-way authentication for client.",
          "type" : "string"
        },
        "ssl-keystore-password" : {
          "description" : "The store password for the key store file. This is optional for client and only needed if ssl.keystore.location is configured.",
          "type" : "string"
        },
        "ssl-keystore-type" : {
          "description" : "The file format of the key store file. This is optional for client.",
          "default" : "JKS",
          "type" : "string"
        },
        "ssl-protocol" : {
          "description" : "The SSL protocol used to generate the SSLContext. The default is 'TLSv1.3' when running with Java 11 or newer, 'TLSv1.2' otherwise. This value should be fine for most use cases. Allowed values in recent JVMs are 'TLSv1.2' and 'TLSv1.3'. 'TLS', 'TLSv1.1', 'SSL', 'SSLv2' and 'SSLv3' may be supported in older JVMs, but their usage is discouraged due to known security vulnerabilities. With the default value for this config and 'ssl.enabled.protocols', clients will downgrade to 'TLSv1.2' if the server does not support 'TLSv1.3'. If this config is set to 'TLSv1.2', clients will not use 'TLSv1.3' even if it is one of the values in ssl.enabled.protocols and the server only supports 'TLSv1.3'.",
          "default" : "TLSv1.2",
          "type" : "string"
        },
        "ssl-provider" : {
          "description" : "The name of the security provider used for SSL connections. Default value is the default security provider of the JVM.",
          "type" : "string"
        },
        "ssl-secure-random-implementation" : {
          "description" : "The SecureRandom PRNG implementation to use for SSL cryptography operations.",
          "type" : "string"
        },
        "ssl-trustmanager-algorithm" : {
          "description" : "The algorithm used by trust manager factory for SSL connections. Default value is the trust manager factory algorithm configured for the Java Virtual Machine.",
          "default" : "PKIX",
          "type" : "string"
        },
        "ssl-truststore-location" : {
          "description" : "The location of the trust store file.",
          "type" : "string"
        },
        "ssl-truststore-password" : {
          "description" : "The password for the trust store file. If a password is not set access to the truststore is still available, but integrity checking is disabled.",
          "type" : "string"
        },
        "ssl-truststore-type" : {
          "description" : "The file format of the trust store file.",
          "default" : "JKS",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "transaction-timeout-ms" : {
          "description" : "The maximum amount of time in ms that the transaction coordinator will wait for a transaction status update from the producer before proactively aborting the ongoing transaction.If this value is larger than the transaction.max.timeout.ms setting in the broker, the request will fail with a InvalidTransactionTimeout error.",
          "default" : "1m",
          "type" : "string"
        },
        "transactional-id" : {
          "description" : "The TransactionalId to use for transactional delivery. This enables reliability semantics which span multiple producer sessions since it allows the client to guarantee that transactions using the same TransactionalId have been completed prior to starting any new transactions. If no TransactionalId is provided, then the producer is limited to idempotent delivery. If a TransactionalId is configured, enable.idempotence is implied. By default the TransactionId is not configured, which means transactions cannot be used. Note that, by default, transactions require a cluster of at least three brokers which is the recommended setting for production; for development you can change this, by adjusting broker setting transaction.state.log.replication.factor.",
          "type" : "string"
        },
        "value-deserializer" : {
          "description" : "Deserializer class for value that implements the org.apache.kafka.common.serialization.Deserializer interface.",
          "default" : "org.apache.kafka.common.serialization.StringDeserializer",
          "type" : "string"
        },
        "value-serializer" : {
          "description" : "Serializer class for value that implements the org.apache.kafka.common.serialization.Serializer interface.",
          "default" : "org.apache.kafka.common.serialization.StringSerializer",
          "type" : "string"
        }
      }
    },
    "vertx-websocket" : {
      "type" : "object",
      "properties" : {
        "host" : {
          "description" : "The host that the consumer should bind to or the host of the remote websocket destination that the producer should connect to",
          "default" : "0.0.0.0",
          "type" : "string"
        },
        "path" : {
          "description" : "The path that the consumer should bind to or path of the remote websocket destination that the producer should connect to",
          "default" : "/",
          "type" : "string"
        },
        "port" : {
          "description" : "The port that the consumer should bind to or port of the remote websocket destination that the producer should connect to",
          "default" : "0",
          "type" : "integer"
        },
        "allowed-origin-pattern" : {
          "description" : "Regex pattern to match the origin header sent by WebSocket clients",
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "client-options" : {
          "description" : "Sets customized options for configuring the WebSocket client used in the producer",
          "type" : "string"
        },
        "client-sub-protocols" : {
          "description" : "Comma separated list of WebSocket subprotocols that the client should use for the Sec-WebSocket-Protocol header",
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "router" : {
          "description" : "To use an existing vertx router for the HTTP server",
          "type" : "string"
        },
        "send-to-all" : {
          "description" : "To send to all websocket subscribers. Can be used to configure on endpoint level, instead of having to use the VertxWebsocketConstants.SEND_TO_ALL header on the message.",
          "default" : "false",
          "type" : "boolean"
        },
        "server-options" : {
          "description" : "Sets customized options for configuring the HTTP server hosting the WebSocket for the consumer",
          "type" : "string"
        },
        "ssl-context-parameters" : {
          "description" : "To configure security using SSLContextParameters",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        }
      },
      "required" : [ "path" ]
    },
    "vm" : {
      "type" : "object",
      "required" : [ "name" ],
      "properties" : {
        "name" : {
          "description" : "Name of queue",
          "type" : "string"
        },
        "block-when-full" : {
          "description" : "Whether a thread that sends messages to a full SEDA queue will block until the queue's capacity is no longer exhausted. By default, an exception will be thrown stating that the queue is full. By enabling this option, the calling thread will instead block and wait until the message can be accepted.",
          "default" : "false",
          "type" : "boolean"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "concurrent-consumers" : {
          "description" : "Number of concurrent threads processing exchanges.",
          "default" : "1",
          "type" : "integer"
        },
        "discard-if-no-consumers" : {
          "description" : "Whether the producer should discard the message (do not add the message to the queue), when sending to a queue with no active consumers. Only one of the options discardIfNoConsumers and failIfNoConsumers can be enabled at the same time.",
          "default" : "false",
          "type" : "boolean"
        },
        "discard-when-full" : {
          "description" : "Whether a thread that sends messages to a full SEDA queue will be discarded. By default, an exception will be thrown stating that the queue is full. By enabling this option, the calling thread will give up sending and continue, meaning that the message was not sent to the SEDA queue.",
          "default" : "false",
          "type" : "boolean"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "fail-if-no-consumers" : {
          "description" : "Whether the producer should fail by throwing an exception, when sending to a queue with no active consumers. Only one of the options discardIfNoConsumers and failIfNoConsumers can be enabled at the same time.",
          "default" : "false",
          "type" : "boolean"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "limit-concurrent-consumers" : {
          "description" : "Whether to limit the number of concurrentConsumers to the maximum of 500. By default, an exception will be thrown if an endpoint is configured with a greater number. You can disable that check by turning this option off.",
          "default" : "true",
          "type" : "boolean"
        },
        "multiple-consumers" : {
          "description" : "Specifies whether multiple consumers are allowed. If enabled, you can use SEDA for Publish-Subscribe messaging. That is, you can send a message to the SEDA queue and have each consumer receive a copy of the message. When enabled, this option should be specified on every consumer endpoint.",
          "default" : "false",
          "type" : "boolean"
        },
        "offer-timeout" : {
          "description" : "offerTimeout (in milliseconds) can be added to the block case when queue is full. You can disable timeout by using 0 or a negative value.",
          "type" : "string"
        },
        "poll-timeout" : {
          "description" : "The timeout used when polling. When a timeout occurs, the consumer can check whether it is allowed to continue running. Setting a lower value allows the consumer to react more quickly upon shutdown.",
          "default" : "1000",
          "type" : "integer"
        },
        "purge-when-stopping" : {
          "description" : "Whether to purge the task queue when stopping the consumer/route. This allows to stop faster, as any pending messages on the queue is discarded.",
          "default" : "false",
          "type" : "boolean"
        },
        "queue" : {
          "description" : "Define the queue instance which will be used by the endpoint",
          "type" : "string"
        },
        "size" : {
          "description" : "The maximum capacity of the SEDA queue (i.e., the number of messages it can hold). Will by default use the defaultSize set on the SEDA component.",
          "default" : "1000",
          "type" : "integer"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "timeout" : {
          "description" : "Timeout (in milliseconds) before a SEDA producer will stop waiting for an asynchronous task to complete. You can disable timeout by using 0 or a negative value.",
          "default" : "30000",
          "type" : "string"
        },
        "wait-for-task-to-complete" : {
          "description" : "Option to specify whether the caller should wait for the async task to complete or not before continuing. The following three options are supported: Always, Never or IfReplyExpected. The first two values are self-explanatory. The last value, IfReplyExpected, will only wait if the message is Request Reply based. The default option is IfReplyExpected.",
          "default" : "IfReplyExpected",
          "enum" : [ "Never", "IfReplyExpected", "Always" ],
          "type" : "string"
        }
      }
    },
    "weather" : {
      "type" : "object",
      "required" : [ "name", "appid", "geolocationAccessKey", "geolocationRequestHostIP" ],
      "properties" : {
        "name" : {
          "description" : "The name value is not used.",
          "type" : "string"
        },
        "appid" : {
          "description" : "APPID ID used to authenticate the user connected to the API Server",
          "type" : "string"
        },
        "backoff-error-threshold" : {
          "description" : "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-idle-threshold" : {
          "description" : "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-multiplier" : {
          "description" : "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
          "type" : "integer"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "cnt" : {
          "description" : "Number of results to be found",
          "type" : "integer"
        },
        "delay" : {
          "description" : "Milliseconds before the next poll.",
          "default" : "500",
          "type" : "integer"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "geo-location-provider" : {
          "description" : "A custum geolocation provider to determine the longitude and latitude to use when no location information is set. The default implementaion uses the ipstack API and requires geolocationAccessKey and geolocationRequestHostIP",
          "type" : "string"
        },
        "geolocation-access-key" : {
          "description" : "The geolocation service now needs an accessKey to be used",
          "type" : "string"
        },
        "geolocation-request-host-ip" : {
          "description" : "The geolocation service now needs to specify the IP associated to the accessKey you're using",
          "type" : "string"
        },
        "greedy" : {
          "description" : "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
          "default" : "false",
          "type" : "boolean"
        },
        "header-name" : {
          "description" : "To store the weather result in this header instead of the message body. This is useable if you want to keep current message body as-is.",
          "type" : "string"
        },
        "http-client" : {
          "description" : "To use an existing configured http client (for example with http proxy)",
          "type" : "string"
        },
        "ids" : {
          "description" : "List of id's of city/stations. You can separate multiple ids by comma.",
          "type" : "string"
        },
        "initial-delay" : {
          "description" : "Milliseconds before the first poll starts.",
          "default" : "1000",
          "type" : "integer"
        },
        "language" : {
          "description" : "Language of the response.",
          "default" : "en",
          "enum" : [ "en", "ru", "it", "es", "sp", "uk", "ua", "de", "pt", "ro", "pl", "fi", "nl", "fr", "bg", "sv", "se", "zh_tw", "zh", "zh_cn", "tr", "hr", "ca" ],
          "type" : "string"
        },
        "lat" : {
          "description" : "Latitude of location. You can use lat and lon options instead of location. For boxed queries this is the bottom latitude.",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "location" : {
          "description" : "If null Camel will try and determine your current location using the geolocation of your ip address, else specify the city,country. For well known city names, Open Weather Map will determine the best fit, but multiple results may be returned. Hence specifying and country as well will return more accurate data. If you specify current as the location then the component will try to get the current latitude and longitude and use that to get the weather details. You can use lat and lon options instead of location.",
          "type" : "string"
        },
        "lon" : {
          "description" : "Longitude of location. You can use lat and lon options instead of location. For boxed queries this is the left longtitude.",
          "type" : "string"
        },
        "mode" : {
          "description" : "The output format of the weather data.",
          "default" : "JSON",
          "enum" : [ "HTML", "JSON", "XML" ],
          "type" : "string"
        },
        "period" : {
          "description" : "If null, the current weather will be returned, else use values of 5, 7, 14 days. Only the numeric value for the forecast period is actually parsed, so spelling, capitalisation of the time period is up to you (its ignored)",
          "type" : "string"
        },
        "poll-strategy" : {
          "description" : "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
          "type" : "string"
        },
        "repeat-count" : {
          "description" : "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
          "default" : "0",
          "type" : "integer"
        },
        "right-lon" : {
          "description" : "For boxed queries this is the right longtitude. Needs to be used in combination with topLat and zoom.",
          "type" : "string"
        },
        "run-logging-level" : {
          "description" : "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
          "default" : "TRACE",
          "enum" : [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ],
          "type" : "string"
        },
        "scheduled-executor-service" : {
          "description" : "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
          "type" : "string"
        },
        "scheduler" : {
          "description" : "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
          "default" : "none",
          "type" : "string"
        },
        "scheduler-properties" : {
          "description" : "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
          "type" : "string"
        },
        "send-empty-message-when-idle" : {
          "description" : "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
          "default" : "false",
          "type" : "boolean"
        },
        "start-scheduler" : {
          "description" : "Whether the scheduler should be auto started.",
          "default" : "true",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "time-unit" : {
          "description" : "Time unit for initialDelay and delay options.",
          "default" : "MILLISECONDS",
          "enum" : [ "NANOSECONDS", "MICROSECONDS", "MILLISECONDS", "SECONDS", "MINUTES", "HOURS", "DAYS" ],
          "type" : "string"
        },
        "top-lat" : {
          "description" : "For boxed queries this is the top latitude. Needs to be used in combination with rightLon and zoom.",
          "type" : "string"
        },
        "units" : {
          "description" : "The units for temperature measurement.",
          "enum" : [ "IMPERIAL", "METRIC" ],
          "type" : "string"
        },
        "use-fixed-delay" : {
          "description" : "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
          "default" : "true",
          "type" : "boolean"
        },
        "weather-api" : {
          "description" : "The API to use (current, forecast/3 hour, forecast daily, station)",
          "enum" : [ "Current", "Station", "Hourly", "Daily" ],
          "type" : "string"
        },
        "zip" : {
          "description" : "Zip-code, e.g. 94040,us",
          "type" : "string"
        },
        "zoom" : {
          "description" : "For boxed queries this is the zoom. Needs to be used in combination with rightLon and topLat.",
          "type" : "integer"
        }
      }
    },
    "web3j" : {
      "type" : "object",
      "required" : [ "nodeAddress" ],
      "properties" : {
        "node-address" : {
          "description" : "Sets the node address used to communicate",
          "type" : "string"
        },
        "address" : {
          "description" : "Contract address.",
          "type" : "string"
        },
        "addresses" : {
          "description" : "Contract address or a list of addresses.",
          "type" : "string"
        },
        "at-block" : {
          "description" : "The block number, or the string latest for the last mined block or pending, earliest for not yet mined transactions.",
          "default" : "latest",
          "type" : "string"
        },
        "block-hash" : {
          "description" : "Hash of the block where this transaction was in.",
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "client-id" : {
          "description" : "A random hexadecimal(32 bytes) ID identifying the client.",
          "type" : "string"
        },
        "data" : {
          "description" : "The compiled code of a contract OR the hash of the invoked method signature and encoded parameters.",
          "type" : "string"
        },
        "database-name" : {
          "description" : "The local database name.",
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "filter-id" : {
          "description" : "The filter id to use.",
          "type" : "string"
        },
        "from-address" : {
          "description" : "The address the transaction is send from",
          "type" : "string"
        },
        "from-block" : {
          "description" : "The block number, or the string latest for the last mined block or pending, earliest for not yet mined transactions.",
          "default" : "latest",
          "type" : "string"
        },
        "full-transaction-objects" : {
          "description" : "If true it returns the full transaction objects, if false only the hashes of the transactions.",
          "default" : "false",
          "type" : "boolean"
        },
        "gas-limit" : {
          "description" : "The maximum gas allowed in this block.",
          "type" : "string"
        },
        "gas-price" : {
          "description" : "Gas price used for each paid gas.",
          "type" : "string"
        },
        "hashrate" : {
          "description" : "A hexadecimal string representation (32 bytes) of the hash rate.",
          "type" : "string"
        },
        "header-pow-hash" : {
          "description" : "The header's pow-hash (256 bits) used for submitting a proof-of-work solution.",
          "type" : "string"
        },
        "index" : {
          "description" : "The transactions/uncle index position in the block.",
          "type" : "string"
        },
        "key-name" : {
          "description" : "The key name in the database.",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "mix-digest" : {
          "description" : "The mix digest (256 bits) used for submitting a proof-of-work solution.",
          "type" : "string"
        },
        "nonce" : {
          "description" : "The nonce found (64 bits) used for submitting a proof-of-work solution.",
          "type" : "string"
        },
        "operation" : {
          "description" : "Operation to use.",
          "default" : "transaction",
          "type" : "string"
        },
        "position" : {
          "description" : "The transaction index position withing a block.",
          "type" : "string"
        },
        "priority" : {
          "description" : "The priority of a whisper message.",
          "type" : "string"
        },
        "private-for" : {
          "description" : "A transaction privateFor nodes with public keys in a Quorum network",
          "type" : "string"
        },
        "quorum-api" : {
          "description" : "If true, this will support Quorum API.",
          "default" : "false",
          "type" : "boolean"
        },
        "sha3-hash-of-data-to-sign" : {
          "description" : "Message to sign by calculating an Ethereum specific signature.",
          "type" : "string"
        },
        "signed-transaction-data" : {
          "description" : "The signed transaction data for a new message call transaction or a contract creation for signed transactions.",
          "type" : "string"
        },
        "source-code" : {
          "description" : "The source code to compile.",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "to-address" : {
          "description" : "The address the transaction is directed to.",
          "type" : "string"
        },
        "to-block" : {
          "description" : "The block number, or the string latest for the last mined block or pending, earliest for not yet mined transactions.",
          "default" : "latest",
          "type" : "string"
        },
        "topics" : {
          "description" : "Topics are order-dependent. Each topic can also be a list of topics. Specify multiple topics separated by comma.",
          "type" : "string"
        },
        "transaction-hash" : {
          "description" : "The information about a transaction requested by transaction hash.",
          "type" : "string"
        },
        "ttl" : {
          "description" : "The time to live in seconds of a whisper message.",
          "type" : "string"
        },
        "value" : {
          "description" : "The value sent within a transaction.",
          "type" : "string"
        },
        "web3j" : {
          "description" : "The preconfigured Web3j object.",
          "type" : "string"
        }
      }
    },
    "webhook" : {
      "type" : "object",
      "required" : [ "endpointUri" ],
      "properties" : {
        "endpoint-uri" : {
          "description" : "The delegate uri. Must belong to a component that supports webhooks.",
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "webhook-auto-register" : {
          "description" : "Automatically register the webhook at startup and unregister it on shutdown.",
          "default" : "true",
          "type" : "boolean"
        },
        "webhook-base-path" : {
          "description" : "The first (base) path element where the webhook will be exposed. It's a good practice to set it to a random string, so that it cannot be guessed by unauthorized parties.",
          "type" : "string"
        },
        "webhook-component-name" : {
          "description" : "The Camel Rest component to use for the REST transport, such as netty-http.",
          "type" : "string"
        },
        "webhook-external-url" : {
          "description" : "The URL of the current service as seen by the webhook provider",
          "type" : "string"
        },
        "webhook-path" : {
          "description" : "The path where the webhook endpoint will be exposed (relative to basePath, if any)",
          "type" : "string"
        }
      }
    },
    "websocket" : {
      "type" : "object",
      "properties" : {
        "host" : {
          "description" : "The hostname. The default value is 0.0.0.0. Setting this option on the component will use the component configured value as default.",
          "default" : "0.0.0.0",
          "type" : "string"
        },
        "port" : {
          "description" : "The port number. The default value is 9292. Setting this option on the component will use the component configured value as default.",
          "default" : "9292",
          "type" : "integer"
        },
        "resource-uri" : {
          "description" : "Name of the websocket channel to use",
          "type" : "string"
        },
        "allowed-origins" : {
          "description" : "The CORS allowed origins. Use to allow all.",
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "buffer-size" : {
          "description" : "Set the buffer size of the websocketServlet, which is also the max frame byte size (default 8192)",
          "default" : "8192",
          "type" : "integer"
        },
        "cross-origin-filter-on" : {
          "description" : "Whether to enable CORS",
          "default" : "false",
          "type" : "boolean"
        },
        "enable-jmx" : {
          "description" : "If this option is true, Jetty JMX support will be enabled for this endpoint. See Jetty JMX support for more details.",
          "default" : "false",
          "type" : "boolean"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "filter-path" : {
          "description" : "Context path for filtering CORS",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "max-binary-message-size" : {
          "description" : "Can be used to set the size in bytes that the websocket created by the websocketServlet may be accept before closing. (Default is -1 - or unlimited)",
          "default" : "-1",
          "type" : "integer"
        },
        "max-idle-time" : {
          "description" : "Set the time in ms that the websocket created by the websocketServlet may be idle before closing. (default is 300000)",
          "default" : "300000",
          "type" : "integer"
        },
        "max-text-message-size" : {
          "description" : "Can be used to set the size in characters that the websocket created by the websocketServlet may be accept before closing.",
          "type" : "integer"
        },
        "min-version" : {
          "description" : "Can be used to set the minimum protocol version accepted for the websocketServlet. (Default 13 - the RFC6455 version)",
          "default" : "13",
          "type" : "integer"
        },
        "send-timeout" : {
          "description" : "Timeout in millis when sending to a websocket channel. The default timeout is 30000 (30 seconds).",
          "default" : "30000",
          "type" : "integer"
        },
        "send-to-all" : {
          "description" : "To send to all websocket subscribers. Can be used to configure on endpoint level, instead of having to use the WebsocketConstants.SEND_TO_ALL header on the message.",
          "type" : "boolean"
        },
        "session-support" : {
          "description" : "Whether to enable session support which enables HttpSession for each http request.",
          "default" : "false",
          "type" : "boolean"
        },
        "ssl-context-parameters" : {
          "description" : "To configure security using SSLContextParameters",
          "type" : "string"
        },
        "static-resources" : {
          "description" : "Set a resource path for static resources (such as .html files etc). The resources can be loaded from classpath, if you prefix with classpath:, otherwise the resources is loaded from file system or from JAR files. For example to load from root classpath use classpath:., or classpath:WEB-INF/static If not configured (eg null) then no static resource is in use.",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        }
      },
      "required" : [ "resourceUri" ]
    },
    "websocket-jsr356" : {
      "type" : "object",
      "properties" : {
        "uri" : {
          "description" : "If a schemeless URI path is provided, a ServerEndpoint is deployed under that path. Else if the URI is prefixed with the 'ws://' scheme, then a connection is established to the corresponding server",
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "session-count" : {
          "description" : "Used when the endpoint is in client mode to populate a pool of sessions",
          "default" : "1",
          "type" : "integer"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "weka" : {
      "type" : "object",
      "required" : [ "command" ],
      "properties" : {
        "command" : {
          "description" : "The command to use.",
          "enum" : [ "filter", "model", "read", "write", "push", "pop", "version" ],
          "type" : "string"
        },
        "apply" : {
          "description" : "The filter spec (i.e. Name Options)",
          "type" : "string"
        },
        "build" : {
          "description" : "The classifier spec (i.e. Name Options)",
          "type" : "string"
        },
        "dsname" : {
          "description" : "The named dataset to train the classifier with",
          "type" : "string"
        },
        "folds" : {
          "description" : "Number of folds to use for cross-validation",
          "default" : "10",
          "type" : "integer"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "load-from" : {
          "description" : "Path to load the model from",
          "type" : "string"
        },
        "path" : {
          "description" : "An in/out path for the read/write commands",
          "type" : "string"
        },
        "save-to" : {
          "description" : "Path to save the model to",
          "type" : "string"
        },
        "seed" : {
          "description" : "An optional seed for the randomizer",
          "default" : "1",
          "type" : "integer"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "xval" : {
          "description" : "Flag on whether to use cross-validation with the current dataset",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "wordpress" : {
      "type" : "object",
      "required" : [ "operation", "url" ],
      "properties" : {
        "operation" : {
          "description" : "The endpoint operation.",
          "enum" : [ "post", "user" ],
          "type" : "string"
        },
        "operation-detail" : {
          "description" : "The second part of an endpoint operation. Needed only when endpoint semantic is not enough, like wordpress:post:delete",
          "enum" : [ "delete" ],
          "type" : "string"
        },
        "api-version" : {
          "description" : "The Wordpress REST API version",
          "default" : "2",
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "criteria" : {
          "description" : "The criteria to use with complex searches.",
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "force" : {
          "description" : "Whether to bypass trash and force deletion.",
          "default" : "false",
          "type" : "boolean"
        },
        "id" : {
          "description" : "The entity ID. Should be passed when the operation performed requires a specific entity, e.g. deleting a post",
          "type" : "integer"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "password" : {
          "description" : "Password from authorized user",
          "type" : "string"
        },
        "search-criteria" : {
          "description" : "Search criteria",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "url" : {
          "description" : "The Wordpress API URL from your site, e.g. http://myblog.com/wp-json/",
          "type" : "string"
        },
        "user" : {
          "description" : "Authorized user to perform writing operations",
          "type" : "string"
        }
      }
    },
    "workday" : {
      "type" : "object",
      "required" : [ "entity", "path", "clientId", "clientSecret", "host", "tenant", "tokenRefresh" ],
      "properties" : {
        "entity" : {
          "description" : "The entity to be requested or subscribed via API.",
          "enum" : [ "report", "commonAPI" ],
          "type" : "string"
        },
        "path" : {
          "description" : "The API path to access an entity structure.",
          "type" : "string"
        },
        "client-id" : {
          "description" : "Workday client Id generated by API client for integrations.",
          "type" : "string"
        },
        "client-secret" : {
          "description" : "Workday client Secret generated by API client for integrations.",
          "type" : "string"
        },
        "host" : {
          "description" : "Workday Host name.",
          "type" : "string"
        },
        "http-connection-manager" : {
          "description" : "Pool connection manager for advanced configuration.",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "report-format" : {
          "description" : "Workday Report as a service output format.",
          "default" : "json",
          "enum" : [ "json" ],
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "tenant" : {
          "description" : "Workday Tenant name.",
          "type" : "string"
        },
        "token-refresh" : {
          "description" : "Workday token Refresh generated for integrations system user.",
          "type" : "string"
        }
      }
    },
    "xchange" : {
      "type" : "object",
      "required" : [ "name", "method", "service" ],
      "properties" : {
        "name" : {
          "description" : "The exchange to connect to",
          "type" : "string"
        },
        "currency" : {
          "description" : "The currency",
          "type" : "string"
        },
        "currency-pair" : {
          "description" : "The currency pair",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "method" : {
          "description" : "The method to execute",
          "enum" : [ "balances", "fundingHistory", "wallets", "currencies", "currencyMetaData", "currencyPairs", "currencyPairMetaData", "ticker" ],
          "type" : "string"
        },
        "service" : {
          "description" : "The service to call",
          "enum" : [ "marketdata", "metadata", "account" ],
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        }
      }
    },
    "xj" : {
      "type" : "object",
      "required" : [ "resourceUri", "transformDirection" ],
      "properties" : {
        "resource-uri" : {
          "description" : "Path to the template. The following is supported by the default URIResolver. You can prefix with: classpath, file, http, ref, or bean. classpath, file and http loads the resource using these protocols (classpath is default). ref will lookup the resource in the registry. bean will call a method on a bean to be used as the resource. For bean you can specify the method name after dot, eg bean:myBean.myMethod",
          "type" : "string"
        },
        "allow-st-ax" : {
          "description" : "Whether to allow using StAX as the javax.xml.transform.Source. You can enable this if the XSLT library supports StAX such as the Saxon library (camel-saxon). The Xalan library (default in JVM) does not support StAXSource.",
          "default" : "true",
          "type" : "boolean"
        },
        "content-cache" : {
          "description" : "Cache for the resource content (the stylesheet file) when it is loaded. If set to false Camel will reload the stylesheet file on each message processing. This is good for development. A cached stylesheet can be forced to reload at runtime via JMX using the clearCachedStylesheet operation.",
          "default" : "true",
          "type" : "boolean"
        },
        "delete-output-file" : {
          "description" : "If you have output=file then this option dictates whether or not the output file should be deleted when the Exchange is done processing. For example suppose the output file is a temporary file, then it can be a good idea to delete it after use.",
          "default" : "false",
          "type" : "boolean"
        },
        "entity-resolver" : {
          "description" : "To use a custom org.xml.sax.EntityResolver with javax.xml.transform.sax.SAXSource.",
          "type" : "string"
        },
        "error-listener" : {
          "description" : "Allows to configure to use a custom javax.xml.transform.ErrorListener. Beware when doing this then the default error listener which captures any errors or fatal errors and store information on the Exchange as properties is not in use. So only use this option for special use-cases.",
          "type" : "string"
        },
        "fail-on-null-body" : {
          "description" : "Whether or not to throw an exception if the input body is null.",
          "default" : "true",
          "type" : "boolean"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "output" : {
          "description" : "Option to specify which output type to use. Possible values are: string, bytes, DOM, file. The first three options are all in memory based, where as file is streamed directly to a java.io.File. For file you must specify the filename in the IN header with the key Exchange.XSLT_FILE_NAME which is also CamelXsltFileName. Also any paths leading to the filename must be created beforehand, otherwise an exception is thrown at runtime.",
          "default" : "string",
          "enum" : [ "string", "bytes", "DOM", "file" ],
          "type" : "string"
        },
        "result-handler-factory" : {
          "description" : "Allows you to use a custom org.apache.camel.builder.xml.ResultHandlerFactory which is capable of using custom org.apache.camel.builder.xml.ResultHandler types.",
          "type" : "string"
        },
        "saxon-configuration" : {
          "description" : "To use a custom Saxon configuration",
          "type" : "string"
        },
        "saxon-extension-functions" : {
          "description" : "Allows you to use a custom net.sf.saxon.lib.ExtensionFunctionDefinition. You would need to add camel-saxon to the classpath. The function is looked up in the registry, where you can comma to separate multiple values to lookup.",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "transform-direction" : {
          "description" : "Transform direction. Either XML2JSON or JSON2XML",
          "enum" : [ "XML2JSON", "JSON2XML" ],
          "type" : "string"
        },
        "transformer-cache-size" : {
          "description" : "The number of javax.xml.transform.Transformer object that are cached for reuse to avoid calls to Template.newTransformer().",
          "default" : "0",
          "type" : "integer"
        },
        "transformer-factory" : {
          "description" : "To use a custom XSLT transformer factory",
          "type" : "string"
        },
        "transformer-factory-class" : {
          "description" : "To use a custom XSLT transformer factory, specified as a FQN class name",
          "type" : "string"
        },
        "transformer-factory-configuration-strategy" : {
          "description" : "A configuration strategy to apply on freshly created instances of TransformerFactory.",
          "type" : "string"
        },
        "uri-resolver" : {
          "description" : "To use a custom javax.xml.transform.URIResolver",
          "type" : "string"
        }
      }
    },
    "xmlsecurity-sign" : {
      "type" : "object",
      "required" : [ "name" ],
      "properties" : {
        "name" : {
          "description" : "The name part in the URI can be chosen by the user to distinguish between different signer endpoints within the camel context.",
          "type" : "string"
        },
        "add-key-info-reference" : {
          "description" : "In order to protect the KeyInfo element from tampering you can add a reference to the signed info element so that it is protected via the signature value. The default value is true. Only relevant when a KeyInfo is returned by KeyAccessor. and KeyInfo#getId() is not null.",
          "default" : "true",
          "type" : "boolean"
        },
        "base-uri" : {
          "description" : "You can set a base URI which is used in the URI dereferencing. Relative URIs are then concatenated with the base URI.",
          "type" : "string"
        },
        "canonicalization-method" : {
          "description" : "Canonicalization method used to canonicalize the SignedInfo element before the digest is calculated. You can use the helper methods XmlSignatureHelper.getCanonicalizationMethod(String algorithm) or getCanonicalizationMethod(String algorithm, List inclusiveNamespacePrefixes) to create a canonicalization method.",
          "default" : "http://www.w3.org/TR/2001/REC-xml-c14n-20010315",
          "type" : "string"
        },
        "clear-headers" : {
          "description" : "Determines if the XML signature specific headers be cleared after signing and verification. Defaults to true.",
          "default" : "true",
          "type" : "boolean"
        },
        "content-object-id" : {
          "description" : "Sets the content object Id attribute value. By default a UUID is generated. If you set the null value, then a new UUID will be generated. Only used in the enveloping case.",
          "type" : "string"
        },
        "content-reference-type" : {
          "description" : "Type of the content reference. The default value is null. This value can be overwritten by the header XmlSignatureConstants#HEADER_CONTENT_REFERENCE_TYPE.",
          "type" : "string"
        },
        "content-reference-uri" : {
          "description" : "Reference URI for the content to be signed. Only used in the enveloped case. If the reference URI contains an ID attribute value, then the resource schema URI ( setSchemaResourceUri(String)) must also be set because the schema validator will then find out which attributes are ID attributes. Will be ignored in the enveloping or detached case.",
          "type" : "string"
        },
        "crypto-context-properties" : {
          "description" : "Sets the crypto context properties. See {link XMLCryptoContext#setProperty(String, Object)}. Possible properties are defined in XMLSignContext an XMLValidateContext (see Supported Properties). The following properties are set by default to the value Boolean#TRUE for the XML validation. If you want to switch these features off you must set the property value to Boolean#FALSE. org.jcp.xml.dsig.validateManifests javax.xml.crypto.dsig.cacheReference",
          "type" : "string"
        },
        "digest-algorithm" : {
          "description" : "Digest algorithm URI. Optional parameter. This digest algorithm is used for calculating the digest of the input message. If this digest algorithm is not specified then the digest algorithm is calculated from the signature algorithm. Example: http://www.w3.org/2001/04/xmlenc#sha256",
          "type" : "string"
        },
        "disallow-doctype-decl" : {
          "description" : "Disallows that the incoming XML document contains DTD DOCTYPE declaration. The default value is Boolean#TRUE.",
          "default" : "true",
          "type" : "boolean"
        },
        "key-accessor" : {
          "description" : "For the signing process, a private key is necessary. You specify a key accessor bean which provides this private key. The key accessor bean must implement the KeyAccessor interface. The package org.apache.camel.component.xmlsecurity.api contains the default implementation class DefaultKeyAccessor which reads the private key from a Java keystore.",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "omit-xml-declaration" : {
          "description" : "Indicator whether the XML declaration in the outgoing message body should be omitted. Default value is false. Can be overwritten by the header XmlSignatureConstants#HEADER_OMIT_XML_DECLARATION.",
          "default" : "false",
          "type" : "boolean"
        },
        "output-xml-encoding" : {
          "description" : "The character encoding of the resulting signed XML document. If null then the encoding of the original XML document is used.",
          "type" : "string"
        },
        "parent-local-name" : {
          "description" : "Local name of the parent element to which the XML signature element will be added. Only relevant for enveloped XML signature. Alternatively you can also use setParentXpath(XPathFilterParameterSpec). Default value is null. The value must be null for enveloping and detached XML signature. This parameter or the parameter setParentXpath(XPathFilterParameterSpec) for enveloped signature and the parameter setXpathsToIdAttributes(List) for detached signature must not be set in the same configuration. If the parameters parentXpath and parentLocalName are specified in the same configuration then an exception is thrown.",
          "type" : "string"
        },
        "parent-namespace" : {
          "description" : "Namespace of the parent element to which the XML signature element will be added.",
          "type" : "string"
        },
        "parent-xpath" : {
          "description" : "Sets the XPath to find the parent node in the enveloped case. Either you specify the parent node via this method or the local name and namespace of the parent with the methods setParentLocalName(String) and setParentNamespace(String). Default value is null. The value must be null for enveloping and detached XML signature. If the parameters parentXpath and parentLocalName are specified in the same configuration then an exception is thrown.",
          "type" : "string"
        },
        "plain-text" : {
          "description" : "Indicator whether the message body contains plain text. The default value is false, indicating that the message body contains XML. The value can be overwritten by the header XmlSignatureConstants#HEADER_MESSAGE_IS_PLAIN_TEXT.",
          "default" : "false",
          "type" : "boolean"
        },
        "plain-text-encoding" : {
          "description" : "Encoding of the plain text. Only relevant if the message body is plain text (see parameter plainText. Default value is UTF-8.",
          "default" : "UTF-8",
          "type" : "string"
        },
        "prefix-for-xml-signature-namespace" : {
          "description" : "Namespace prefix for the XML signature namespace http://www.w3.org/2000/09/xmldsig#. Default value is ds. If null or an empty value is set then no prefix is used for the XML signature namespace. See best practice http://www.w3.org/TR/xmldsig-bestpractices/#signing-xml- without-namespaces",
          "default" : "ds",
          "type" : "string"
        },
        "properties" : {
          "description" : "For adding additional References and Objects to the XML signature which contain additional properties, you can provide a bean which implements the XmlSignatureProperties interface.",
          "type" : "string"
        },
        "schema-resource-uri" : {
          "description" : "Classpath to the XML Schema. Must be specified in the detached XML Signature case for determining the ID attributes, might be set in the enveloped and enveloping case. If set, then the XML document is validated with the specified XML schema. The schema resource URI can be overwritten by the header XmlSignatureConstants#HEADER_SCHEMA_RESOURCE_URI.",
          "type" : "string"
        },
        "signature-algorithm" : {
          "description" : "Signature algorithm. Default value is http://www.w3.org/2000/09/xmldsig#rsa-sha1.",
          "default" : "http://www.w3.org/2001/04/xmldsig-more#rsa-sha256",
          "type" : "string"
        },
        "signature-id" : {
          "description" : "Sets the signature Id. If this parameter is not set (null value) then a unique ID is generated for the signature ID (default). If this parameter is set to (empty string) then no Id attribute is created in the signature element.",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "transform-methods" : {
          "description" : "Transforms which are executed on the message body before the digest is calculated. By default, C14n is added and in the case of enveloped signature (see option parentLocalName) also http://www.w3.org/2000/09/xmldsig#enveloped-signature is added at position 0 of the list. Use methods in XmlSignatureHelper to create the transform methods.",
          "type" : "string"
        },
        "uri-dereferencer" : {
          "description" : "If you want to restrict the remote access via reference URIs, you can set an own dereferencer. Optional parameter. If not set the provider default dereferencer is used which can resolve URI fragments, HTTP, file and XPpointer URIs. Attention: The implementation is provider dependent!",
          "type" : "string"
        },
        "xpaths-to-id-attributes" : {
          "description" : "Define the elements which are signed in the detached case via XPATH expressions to ID attributes (attributes of type ID). For each element found via the XPATH expression a detached signature is created whose reference URI contains the corresponding attribute value (preceded by '#'). The signature becomes the last sibling of the signed element. Elements with deeper hierarchy level are signed first. You can also set the XPATH list dynamically via the header XmlSignatureConstants#HEADER_XPATHS_TO_ID_ATTRIBUTES. The parameter setParentLocalName(String) or setParentXpath(XPathFilterParameterSpec) for enveloped signature and this parameter for detached signature must not be set in the same configuration.",
          "type" : "string"
        }
      }
    },
    "xmlsecurity-verify" : {
      "type" : "object",
      "required" : [ "name" ],
      "properties" : {
        "name" : {
          "description" : "The name part in the URI can be chosen by the user to distinguish between different verify endpoints within the camel context.",
          "type" : "string"
        },
        "base-uri" : {
          "description" : "You can set a base URI which is used in the URI dereferencing. Relative URIs are then concatenated with the base URI.",
          "type" : "string"
        },
        "clear-headers" : {
          "description" : "Determines if the XML signature specific headers be cleared after signing and verification. Defaults to true.",
          "default" : "true",
          "type" : "boolean"
        },
        "crypto-context-properties" : {
          "description" : "Sets the crypto context properties. See {link XMLCryptoContext#setProperty(String, Object)}. Possible properties are defined in XMLSignContext an XMLValidateContext (see Supported Properties). The following properties are set by default to the value Boolean#TRUE for the XML validation. If you want to switch these features off you must set the property value to Boolean#FALSE. org.jcp.xml.dsig.validateManifests javax.xml.crypto.dsig.cacheReference",
          "type" : "string"
        },
        "disallow-doctype-decl" : {
          "description" : "Disallows that the incoming XML document contains DTD DOCTYPE declaration. The default value is Boolean#TRUE.",
          "default" : "true",
          "type" : "boolean"
        },
        "key-selector" : {
          "description" : "Provides the key for validating the XML signature.",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "omit-xml-declaration" : {
          "description" : "Indicator whether the XML declaration in the outgoing message body should be omitted. Default value is false. Can be overwritten by the header XmlSignatureConstants#HEADER_OMIT_XML_DECLARATION.",
          "default" : "false",
          "type" : "boolean"
        },
        "output-node-search" : {
          "description" : "Sets the output node search value for determining the node from the XML signature document which shall be set to the output message body. The class of the value depends on the type of the output node search. The output node search is forwarded to XmlSignature2Message.",
          "type" : "string"
        },
        "output-node-search-type" : {
          "description" : "Determines the search type for determining the output node which is serialized into the output message bodyF. See setOutputNodeSearch(Object). The supported default search types you can find in DefaultXmlSignature2Message.",
          "default" : "Default",
          "type" : "string"
        },
        "output-xml-encoding" : {
          "description" : "The character encoding of the resulting signed XML document. If null then the encoding of the original XML document is used.",
          "type" : "string"
        },
        "remove-signature-elements" : {
          "description" : "Indicator whether the XML signature elements (elements with local name Signature and namesapce http://www.w3.org/2000/09/xmldsig#) shall be removed from the document set to the output message. Normally, this is only necessary, if the XML signature is enveloped. The default value is Boolean#FALSE. This parameter is forwarded to XmlSignature2Message. This indicator has no effect if the output node search is of type DefaultXmlSignature2Message#OUTPUT_NODE_SEARCH_TYPE_DEFAULT.F",
          "default" : "false",
          "type" : "boolean"
        },
        "schema-resource-uri" : {
          "description" : "Classpath to the XML Schema. Must be specified in the detached XML Signature case for determining the ID attributes, might be set in the enveloped and enveloping case. If set, then the XML document is validated with the specified XML schema. The schema resource URI can be overwritten by the header XmlSignatureConstants#HEADER_SCHEMA_RESOURCE_URI.",
          "type" : "string"
        },
        "secure-validation" : {
          "description" : "Enables secure validation. If true then secure validation is enabled.",
          "default" : "true",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "uri-dereferencer" : {
          "description" : "If you want to restrict the remote access via reference URIs, you can set an own dereferencer. Optional parameter. If not set the provider default dereferencer is used which can resolve URI fragments, HTTP, file and XPpointer URIs. Attention: The implementation is provider dependent!",
          "type" : "string"
        },
        "validation-failed-handler" : {
          "description" : "Handles the different validation failed situations. The default implementation throws specific exceptions for the different situations (All exceptions have the package name org.apache.camel.component.xmlsecurity.api and are a sub-class of XmlSignatureInvalidException. If the signature value validation fails, a XmlSignatureInvalidValueException is thrown. If a reference validation fails, a XmlSignatureInvalidContentHashException is thrown. For more detailed information, see the JavaDoc.",
          "type" : "string"
        },
        "xml-signature2-message" : {
          "description" : "Bean which maps the XML signature to the output-message after the validation. How this mapping should be done can be configured by the options outputNodeSearchType, outputNodeSearch, and removeSignatureElements. The default implementation offers three possibilities which are related to the three output node search types Default, ElementName, and XPath. The default implementation determines a node which is then serialized and set to the body of the output message If the search type is ElementName then the output node (which must be in this case an element) is determined by the local name and namespace defined in the search value (see option outputNodeSearch). If the search type is XPath then the output node is determined by the XPath specified in the search value (in this case the output node can be of type Element, TextNode or Document). If the output node search type is Default then the following rules apply: In the enveloped XML signature case (there is a reference with URI= and transform http://www.w3.org/2000/09/xmldsig#enveloped-signature), the incoming XML document without the Signature element is set to the output message body. In the non-enveloped XML signature case, the message body is determined from a referenced Object; this is explained in more detail in chapter Output Node Determination in Enveloping XML Signature Case.",
          "type" : "string"
        },
        "xml-signature-checker" : {
          "description" : "This interface allows the application to check the XML signature before the validation is executed. This step is recommended in http://www.w3.org/TR/xmldsig-bestpractices/#check-what-is-signed",
          "type" : "string"
        }
      }
    },
    "xmpp" : {
      "type" : "object",
      "required" : [ "host", "port" ],
      "properties" : {
        "host" : {
          "description" : "Hostname for the chat server",
          "type" : "string"
        },
        "participant" : {
          "description" : "JID (Jabber ID) of person to receive messages. room parameter has precedence over participant.",
          "type" : "string"
        },
        "port" : {
          "description" : "Port number for the chat server",
          "type" : "integer"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "connection-config" : {
          "description" : "To use an existing connection configuration. Currently org.jivesoftware.smack.tcp.XMPPTCPConnectionConfiguration is only supported (XMPP over TCP).",
          "type" : "string"
        },
        "connection-poll-delay" : {
          "description" : "The amount of time in seconds between polls (in seconds) to verify the health of the XMPP connection, or between attempts to establish an initial consumer connection. Camel will try to re-establish a connection if it has become inactive. Default is 10 seconds.",
          "default" : "10",
          "type" : "integer"
        },
        "create-account" : {
          "description" : "If true, an attempt to create an account will be made. Default is false.",
          "default" : "false",
          "type" : "boolean"
        },
        "doc" : {
          "description" : "Set a doc header on the IN message containing a Document form of the incoming packet; default is true if presence or pubsub are true, otherwise false",
          "default" : "false",
          "type" : "boolean"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "header-filter-strategy" : {
          "description" : "To use a custom HeaderFilterStrategy to filter header to and from Camel message.",
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "login" : {
          "description" : "Whether to login the user.",
          "default" : "true",
          "type" : "boolean"
        },
        "nickname" : {
          "description" : "Use nickname when joining room. If room is specified and nickname is not, user will be used for the nickname.",
          "type" : "string"
        },
        "password" : {
          "description" : "Password for login",
          "type" : "string"
        },
        "pubsub" : {
          "description" : "Accept pubsub packets on input, default is false",
          "default" : "false",
          "type" : "boolean"
        },
        "resource" : {
          "description" : "XMPP resource. The default is Camel.",
          "default" : "Camel",
          "type" : "string"
        },
        "room" : {
          "description" : "If this option is specified, the component will connect to MUC (Multi User Chat). Usually, the domain name for MUC is different from the login domain. For example, if you are supermanjabber.org and want to join the krypton room, then the room URL is kryptonconference.jabber.org. Note the conference part. It is not a requirement to provide the full room JID. If the room parameter does not contain the symbol, the domain part will be discovered and added by Camel",
          "type" : "string"
        },
        "room-password" : {
          "description" : "Password for room",
          "type" : "string"
        },
        "service-name" : {
          "description" : "The name of the service you are connecting to. For Google Talk, this would be gmail.com.",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "test-connection-on-startup" : {
          "description" : "Specifies whether to test the connection on startup. This is used to ensure that the XMPP client has a valid connection to the XMPP server when the route starts. Camel throws an exception on startup if a connection cannot be established. When this option is set to false, Camel will attempt to establish a lazy connection when needed by a producer, and will poll for a consumer connection until the connection is established. Default is true.",
          "default" : "true",
          "type" : "boolean"
        },
        "user" : {
          "description" : "User name (without server name). If not specified, anonymous login will be attempted.",
          "type" : "string"
        }
      }
    },
    "xquery" : {
      "type" : "object",
      "required" : [ "resourceUri" ],
      "properties" : {
        "resource-uri" : {
          "description" : "The name of the template to load from classpath or file system",
          "type" : "string"
        },
        "allow-st-ax" : {
          "description" : "Whether to allow using StAX mode",
          "default" : "false",
          "type" : "boolean"
        },
        "backoff-error-threshold" : {
          "description" : "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-idle-threshold" : {
          "description" : "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-multiplier" : {
          "description" : "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
          "type" : "integer"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "configuration" : {
          "description" : "To use a custom Saxon configuration",
          "type" : "string"
        },
        "configuration-properties" : {
          "description" : "To set custom Saxon configuration properties",
          "type" : "string"
        },
        "delay" : {
          "description" : "Milliseconds before the next poll.",
          "default" : "500",
          "type" : "integer"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "greedy" : {
          "description" : "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
          "default" : "false",
          "type" : "boolean"
        },
        "header-name" : {
          "description" : "To use a Camel Message header as the input source instead of Message body.",
          "type" : "string"
        },
        "initial-delay" : {
          "description" : "Milliseconds before the first poll starts.",
          "default" : "1000",
          "type" : "integer"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "module-uri-resolver" : {
          "description" : "To use the custom ModuleURIResolver",
          "type" : "string"
        },
        "namespace-prefixes" : {
          "description" : "Allows to control which namespace prefixes to use for a set of namespace mappings",
          "type" : "string"
        },
        "parameters" : {
          "description" : "Additional parameters",
          "type" : "string"
        },
        "poll-strategy" : {
          "description" : "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
          "type" : "string"
        },
        "properties" : {
          "description" : "Properties to configure the serialization parameters",
          "type" : "string"
        },
        "repeat-count" : {
          "description" : "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
          "default" : "0",
          "type" : "integer"
        },
        "result-type" : {
          "description" : "What output result to use defined as a class",
          "type" : "string"
        },
        "results-format" : {
          "description" : "What output result to use",
          "default" : "DOM",
          "enum" : [ "Bytes", "BytesSource", "DOM", "DOMSource", "List", "String", "StringSource" ],
          "type" : "string"
        },
        "run-logging-level" : {
          "description" : "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
          "default" : "TRACE",
          "enum" : [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ],
          "type" : "string"
        },
        "scheduled-executor-service" : {
          "description" : "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
          "type" : "string"
        },
        "scheduler" : {
          "description" : "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
          "default" : "none",
          "type" : "string"
        },
        "scheduler-properties" : {
          "description" : "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
          "type" : "string"
        },
        "send-empty-message-when-idle" : {
          "description" : "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
          "default" : "false",
          "type" : "boolean"
        },
        "start-scheduler" : {
          "description" : "Whether the scheduler should be auto started.",
          "default" : "true",
          "type" : "boolean"
        },
        "static-query-context" : {
          "description" : "To use a custom Saxon StaticQueryContext",
          "type" : "string"
        },
        "strips-all-white-space" : {
          "description" : "Whether to strip all whitespaces",
          "default" : "true",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "time-unit" : {
          "description" : "Time unit for initialDelay and delay options.",
          "default" : "MILLISECONDS",
          "enum" : [ "NANOSECONDS", "MICROSECONDS", "MILLISECONDS", "SECONDS", "MINUTES", "HOURS", "DAYS" ],
          "type" : "string"
        },
        "use-fixed-delay" : {
          "description" : "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
          "default" : "true",
          "type" : "boolean"
        }
      }
    },
    "xslt" : {
      "type" : "object",
      "required" : [ "resourceUri" ],
      "properties" : {
        "resource-uri" : {
          "description" : "Path to the template. The following is supported by the default URIResolver. You can prefix with: classpath, file, http, ref, or bean. classpath, file and http loads the resource using these protocols (classpath is default). ref will lookup the resource in the registry. bean will call a method on a bean to be used as the resource. For bean you can specify the method name after dot, eg bean:myBean.myMethod",
          "type" : "string"
        },
        "content-cache" : {
          "description" : "Cache for the resource content (the stylesheet file) when it is loaded. If set to false Camel will reload the stylesheet file on each message processing. This is good for development. A cached stylesheet can be forced to reload at runtime via JMX using the clearCachedStylesheet operation.",
          "default" : "true",
          "type" : "boolean"
        },
        "delete-output-file" : {
          "description" : "If you have output=file then this option dictates whether or not the output file should be deleted when the Exchange is done processing. For example suppose the output file is a temporary file, then it can be a good idea to delete it after use.",
          "default" : "false",
          "type" : "boolean"
        },
        "entity-resolver" : {
          "description" : "To use a custom org.xml.sax.EntityResolver with javax.xml.transform.sax.SAXSource.",
          "type" : "string"
        },
        "error-listener" : {
          "description" : "Allows to configure to use a custom javax.xml.transform.ErrorListener. Beware when doing this then the default error listener which captures any errors or fatal errors and store information on the Exchange as properties is not in use. So only use this option for special use-cases.",
          "type" : "string"
        },
        "fail-on-null-body" : {
          "description" : "Whether or not to throw an exception if the input body is null.",
          "default" : "true",
          "type" : "boolean"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "output" : {
          "description" : "Option to specify which output type to use. Possible values are: string, bytes, DOM, file. The first three options are all in memory based, where as file is streamed directly to a java.io.File. For file you must specify the filename in the IN header with the key Exchange.XSLT_FILE_NAME which is also CamelXsltFileName. Also any paths leading to the filename must be created beforehand, otherwise an exception is thrown at runtime.",
          "default" : "string",
          "enum" : [ "string", "bytes", "DOM", "file" ],
          "type" : "string"
        },
        "result-handler-factory" : {
          "description" : "Allows you to use a custom org.apache.camel.builder.xml.ResultHandlerFactory which is capable of using custom org.apache.camel.builder.xml.ResultHandler types.",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "transformer-cache-size" : {
          "description" : "The number of javax.xml.transform.Transformer object that are cached for reuse to avoid calls to Template.newTransformer().",
          "default" : "0",
          "type" : "integer"
        },
        "transformer-factory" : {
          "description" : "To use a custom XSLT transformer factory",
          "type" : "string"
        },
        "transformer-factory-class" : {
          "description" : "To use a custom XSLT transformer factory, specified as a FQN class name",
          "type" : "string"
        },
        "transformer-factory-configuration-strategy" : {
          "description" : "A configuration strategy to apply on freshly created instances of TransformerFactory.",
          "type" : "string"
        },
        "uri-resolver" : {
          "description" : "To use a custom javax.xml.transform.URIResolver",
          "type" : "string"
        }
      }
    },
    "xslt-saxon" : {
      "type" : "object",
      "required" : [ "resourceUri" ],
      "properties" : {
        "resource-uri" : {
          "description" : "Path to the template. The following is supported by the default URIResolver. You can prefix with: classpath, file, http, ref, or bean. classpath, file and http loads the resource using these protocols (classpath is default). ref will lookup the resource in the registry. bean will call a method on a bean to be used as the resource. For bean you can specify the method name after dot, eg bean:myBean.myMethod",
          "type" : "string"
        },
        "allow-st-ax" : {
          "description" : "Whether to allow using StAX as the javax.xml.transform.Source. You can enable this if the XSLT library supports StAX such as the Saxon library (camel-saxon). The Xalan library (default in JVM) does not support StAXSource.",
          "default" : "true",
          "type" : "boolean"
        },
        "content-cache" : {
          "description" : "Cache for the resource content (the stylesheet file) when it is loaded. If set to false Camel will reload the stylesheet file on each message processing. This is good for development. A cached stylesheet can be forced to reload at runtime via JMX using the clearCachedStylesheet operation.",
          "default" : "true",
          "type" : "boolean"
        },
        "delete-output-file" : {
          "description" : "If you have output=file then this option dictates whether or not the output file should be deleted when the Exchange is done processing. For example suppose the output file is a temporary file, then it can be a good idea to delete it after use.",
          "default" : "false",
          "type" : "boolean"
        },
        "entity-resolver" : {
          "description" : "To use a custom org.xml.sax.EntityResolver with javax.xml.transform.sax.SAXSource.",
          "type" : "string"
        },
        "error-listener" : {
          "description" : "Allows to configure to use a custom javax.xml.transform.ErrorListener. Beware when doing this then the default error listener which captures any errors or fatal errors and store information on the Exchange as properties is not in use. So only use this option for special use-cases.",
          "type" : "string"
        },
        "fail-on-null-body" : {
          "description" : "Whether or not to throw an exception if the input body is null.",
          "default" : "true",
          "type" : "boolean"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "output" : {
          "description" : "Option to specify which output type to use. Possible values are: string, bytes, DOM, file. The first three options are all in memory based, where as file is streamed directly to a java.io.File. For file you must specify the filename in the IN header with the key Exchange.XSLT_FILE_NAME which is also CamelXsltFileName. Also any paths leading to the filename must be created beforehand, otherwise an exception is thrown at runtime.",
          "default" : "string",
          "enum" : [ "string", "bytes", "DOM", "file" ],
          "type" : "string"
        },
        "result-handler-factory" : {
          "description" : "Allows you to use a custom org.apache.camel.builder.xml.ResultHandlerFactory which is capable of using custom org.apache.camel.builder.xml.ResultHandler types.",
          "type" : "string"
        },
        "saxon-configuration" : {
          "description" : "To use a custom Saxon configuration",
          "type" : "string"
        },
        "saxon-extension-functions" : {
          "description" : "Allows you to use a custom net.sf.saxon.lib.ExtensionFunctionDefinition. You would need to add camel-saxon to the classpath. The function is looked up in the registry, where you can comma to separate multiple values to lookup.",
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "transformer-cache-size" : {
          "description" : "The number of javax.xml.transform.Transformer object that are cached for reuse to avoid calls to Template.newTransformer().",
          "default" : "0",
          "type" : "integer"
        },
        "transformer-factory" : {
          "description" : "To use a custom XSLT transformer factory",
          "type" : "string"
        },
        "transformer-factory-class" : {
          "description" : "To use a custom XSLT transformer factory, specified as a FQN class name",
          "type" : "string"
        },
        "transformer-factory-configuration-strategy" : {
          "description" : "A configuration strategy to apply on freshly created instances of TransformerFactory.",
          "type" : "string"
        },
        "uri-resolver" : {
          "description" : "To use a custom javax.xml.transform.URIResolver",
          "type" : "string"
        }
      }
    },
    "yammer" : {
      "type" : "object",
      "required" : [ "function", "accessToken", "consumerKey", "consumerSecret" ],
      "properties" : {
        "function" : {
          "description" : "The function to use",
          "enum" : [ "MESSAGES", "MY_FEED", "ALGO", "FOLLOWING", "SENT", "PRIVATE", "RECEIVED", "USERS", "CURRENT" ],
          "type" : "string"
        },
        "access-token" : {
          "description" : "The access token",
          "type" : "string"
        },
        "backoff-error-threshold" : {
          "description" : "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-idle-threshold" : {
          "description" : "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-multiplier" : {
          "description" : "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
          "type" : "integer"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "consumer-key" : {
          "description" : "The consumer key",
          "type" : "string"
        },
        "consumer-secret" : {
          "description" : "The consumer secret",
          "type" : "string"
        },
        "delay" : {
          "description" : "Delay between polling in millis",
          "default" : "5000",
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "greedy" : {
          "description" : "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
          "default" : "false",
          "type" : "boolean"
        },
        "initial-delay" : {
          "description" : "Milliseconds before the first poll starts.",
          "default" : "1000",
          "type" : "integer"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "limit" : {
          "description" : "Return only the specified number of messages. Works for threaded set to true and threaded set to extended.",
          "default" : "-1",
          "type" : "integer"
        },
        "newer-than" : {
          "description" : "Returns messages newer than the message ID specified as a numeric string. This should be used when polling for new messages. If you're looking at messages, and the most recent message returned is 3516, you can make a request with the parameter newerThan equals to 3516 to ensure that you do not get duplicate copies of messages already on your page.",
          "default" : "-1",
          "type" : "integer"
        },
        "older-than" : {
          "description" : "Returns messages older than the message ID specified as a numeric string. This is useful for paginating messages. For example, if you're currently viewing 20 messages and the oldest is number 2912, you could append olderThan equals to 2912 to your request to get the 20 messages prior to those you're seeing.",
          "default" : "-1",
          "type" : "integer"
        },
        "poll-strategy" : {
          "description" : "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
          "type" : "string"
        },
        "repeat-count" : {
          "description" : "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
          "default" : "0",
          "type" : "integer"
        },
        "requestor" : {
          "description" : "To use a specific requester to communicate with Yammer.",
          "type" : "string"
        },
        "run-logging-level" : {
          "description" : "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
          "default" : "TRACE",
          "enum" : [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ],
          "type" : "string"
        },
        "scheduled-executor-service" : {
          "description" : "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
          "type" : "string"
        },
        "scheduler" : {
          "description" : "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
          "default" : "none",
          "type" : "string"
        },
        "scheduler-properties" : {
          "description" : "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
          "type" : "string"
        },
        "send-empty-message-when-idle" : {
          "description" : "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
          "default" : "false",
          "type" : "boolean"
        },
        "start-scheduler" : {
          "description" : "Whether the scheduler should be auto started.",
          "default" : "true",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "threaded" : {
          "description" : "threaded equals to true will only return the first message in each thread. This parameter is intended for apps which display message threads collapsed. threaded equals to extended will return the thread starter messages in order of most recently active as well as the two most recent messages, as they are viewed in the default view on the Yammer web interface.",
          "enum" : [ "true", "extended" ],
          "type" : "string"
        },
        "time-unit" : {
          "description" : "Time unit for initialDelay and delay options.",
          "default" : "MILLISECONDS",
          "enum" : [ "NANOSECONDS", "MICROSECONDS", "MILLISECONDS", "SECONDS", "MINUTES", "HOURS", "DAYS" ],
          "type" : "string"
        },
        "use-fixed-delay" : {
          "description" : "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
          "default" : "true",
          "type" : "boolean"
        },
        "use-json" : {
          "description" : "Set to true if you want to use raw JSON rather than converting to POJOs.",
          "default" : "false",
          "type" : "boolean"
        },
        "user-id" : {
          "description" : "The user id",
          "type" : "string"
        }
      }
    },
    "zendesk" : {
      "type" : "object",
      "required" : [ "methodName" ],
      "properties" : {
        "method-name" : {
          "description" : "What operation to use",
          "enum" : [ "ADD_TAG_TO_ORGANISATIONS", "ADD_TAG_TO_TICKET", "ADD_TAG_TO_TOPICS", "ASSOCIATE_ATTACHMENTS_TO_ARTICLE", "CHANGE_USER_PASSWORD", "CREATE_ARTICLE", "CREATE_ARTICLE_1", "CREATE_ARTICLE_TRANSLATION", "CREATE_AUTOMATION", "CREATE_CATEGORY", "CREATE_CATEGORY_TRANSLATION", "CREATE_COMMENT", "CREATE_DYNAMIC_CONTENT_ITEM", "CREATE_DYNAMIC_CONTENT_ITEM_VARIANT", "CREATE_FORUM", "CREATE_GROUP", "CREATE_GROUP_MEMBERSHIP", "CREATE_GROUP_MEMBERSHIP_1", "CREATE_MACRO", "CREATE_OR_UPDATE_USER", "CREATE_OR_UPDATE_USERS", "CREATE_OR_UPDATE_USERS_1", "CREATE_OR_UPDATE_USERS_ASYNC", "CREATE_ORGANIZATION", "CREATE_ORGANIZATION_MEMBERSHIP", "CREATE_ORGANIZATION_MEMBERSHIP_1", "CREATE_ORGANIZATION_MEMBERSHIPS", "CREATE_ORGANIZATION_MEMBERSHIPS_1", "CREATE_ORGANIZATION_MEMBERSHIPS_ASYNC", "CREATE_ORGANIZATIONS", "CREATE_ORGANIZATIONS_1", "CREATE_ORGANIZATIONS_ASYNC", "CREATE_PERMISSION_GROUP", "CREATE_REQUEST", "CREATE_SATISFACTION_RATING", "CREATE_SATISFACTION_RATING_1", "CREATE_SECTION", "CREATE_SECTION_TRANSLATION", "CREATE_TARGET", "CREATE_TICKET", "CREATE_TICKET_ASYNC", "CREATE_TICKET_FIELD", "CREATE_TICKET_FORM", "CREATE_TICKET_FROM_TWEET", "CREATE_TICKETS", "CREATE_TICKETS_1", "CREATE_TICKETS_ASYNC", "CREATE_TOPIC", "CREATE_TRIGGER", "CREATE_UPLOAD", "CREATE_UPLOAD_1", "CREATE_UPLOAD_2", "CREATE_UPLOAD_ARTICLE", "CREATE_UPLOAD_ARTICLE_1", "CREATE_USER", "CREATE_USER_IDENTITY", "CREATE_USER_IDENTITY_1", "CREATE_USER_SEGMENT", "CREATE_USERS", "CREATE_USERS_1", "CREATE_USERS_ASYNC", "DELETE_ARTICLE", "DELETE_ARTICLE_ATTACHMENT", "DELETE_ARTICLE_ATTACHMENT_1", "DELETE_ATTACHMENT", "DELETE_ATTACHMENT_1", "DELETE_AUTOMATION", "DELETE_CATEGORY", "DELETE_DYNAMIC_CONTENT_ITEM", "DELETE_DYNAMIC_CONTENT_ITEM_VARIANT", "DELETE_FORUM", "DELETE_GROUP", "DELETE_GROUP_1", "DELETE_GROUP_MEMBERSHIP", "DELETE_GROUP_MEMBERSHIP_1", "DELETE_GROUP_MEMBERSHIP_2", "DELETE_GROUP_MEMBERSHIP_3", "DELETE_ORGANIZATION", "DELETE_ORGANIZATION_1", "DELETE_ORGANIZATION_MEMBERSHIP", "DELETE_ORGANIZATION_MEMBERSHIP_1", "DELETE_ORGANIZATION_MEMBERSHIP_2", "DELETE_ORGANIZATION_MEMBERSHIPS", "DELETE_PERMISSION_GROUP", "DELETE_PERMISSION_GROUP_1", "DELETE_SECTION", "DELETE_SUSPENDED_TICKET", "DELETE_SUSPENDED_TICKET_1", "DELETE_TARGET", "DELETE_TICKET", "DELETE_TICKET_1", "DELETE_TICKET_FIELD", "DELETE_TICKET_FIELD_1", "DELETE_TICKETS", "DELETE_TOPIC", "DELETE_TRANSLATION", "DELETE_TRANSLATION_1", "DELETE_TRIGGER", "DELETE_UPLOAD", "DELETE_UPLOAD_1", "DELETE_USER", "DELETE_USER_1", "DELETE_USER_IDENTITY", "DELETE_USER_IDENTITY_1", "DELETE_USER_IDENTITY_2", "DELETE_USER_SEGMENT", "DELETE_USER_SEGMENT_1", "GET_ARTICLE", "GET_ARTICLE_FROM_SEARCH", "GET_ARTICLE_FROM_SEARCH_1", "GET_ARTICLE_SUBSCRIPTIONS", "GET_ARTICLE_SUBSCRIPTIONS_1", "GET_ARTICLE_TRANSLATIONS", "GET_ARTICLES", "GET_ARTICLES_1", "GET_ARTICLES_2", "GET_ARTICLES_3", "GET_ARTICLES_FROM_ALL_LABELS", "GET_ARTICLES_FROM_ANY_LABELS", "GET_ARTICLES_FROM_PAGE", "GET_ARTICLES_INCREMENTALLY", "GET_ASSIGNABLE_GROUP_MEMBERSHIPS", "GET_ASSIGNABLE_GROUP_MEMBERSHIPS_1", "GET_ASSIGNABLE_GROUPS", "GET_ATTACHMENT", "GET_ATTACHMENT_1", "GET_ATTACHMENTS_FROM_ARTICLE", "GET_AUTHENTICATED_USER", "GET_AUTO_COMPLETE_ORGANIZATIONS", "GET_AUTOMATION", "GET_AUTOMATIONS", "GET_BRANDS", "GET_CC_REQUESTS", "GET_CATEGORIES", "GET_CATEGORY", "GET_CATEGORY_TRANSLATIONS", "GET_COMPLIANCE_DELETION_STATUSES", "GET_CURRENT_USER", "GET_CUSTOM_AGENT_ROLES", "GET_DELETED_TICKETS", "GET_DELETED_TICKETS_1", "GET_DYNAMIC_CONTENT_ITEM", "GET_DYNAMIC_CONTENT_ITEM_VARIANT", "GET_DYNAMIC_CONTENT_ITEM_VARIANTS", "GET_DYNAMIC_CONTENT_ITEMS", "GET_FORUM", "GET_FORUMS", "GET_FORUMS_1", "GET_GROUP", "GET_GROUP_MEMBERSHIP", "GET_GROUP_MEMBERSHIP_1", "GET_GROUP_MEMBERSHIP_BY_USER", "GET_GROUP_MEMBERSHIPS", "GET_GROUP_MEMBERSHIPS_1", "GET_GROUP_ORGANIZATION", "GET_GROUP_USERS", "GET_GROUPS", "GET_HELP_CENTER_LOCALES", "GET_HOLIDAYS_FOR_SCHEDULE", "GET_HOLIDAYS_FOR_SCHEDULE_1", "GET_INCREMENTAL_TICKETS_RESULT", "GET_JOB_STATUS", "GET_JOB_STATUS_ASYNC", "GET_JOB_STATUSES", "GET_JOB_STATUSES_ASYNC", "GET_MACRO", "GET_MACROS", "GET_OPEN_REQUESTS", "GET_ORGANIZATION", "GET_ORGANIZATION_FIELDS", "GET_ORGANIZATION_MEMBERSHIP", "GET_ORGANIZATION_MEMBERSHIP_BY_USER", "GET_ORGANIZATION_MEMBERSHIP_FOR_USER", "GET_ORGANIZATION_MEMBERSHIPS", "GET_ORGANIZATION_MEMBERSHIPS_FOR_ORG", "GET_ORGANIZATION_MEMBERSHIPS_FOR_USER", "GET_ORGANIZATION_TICKETS", "GET_ORGANIZATION_USERS", "GET_ORGANIZATIONS", "GET_ORGANIZATIONS_INCREMENTALLY", "GET_PERMISSION_GROUP", "GET_PERMISSION_GROUPS", "GET_RECENT_TICKETS", "GET_REQUEST", "GET_REQUEST_COMMENT", "GET_REQUEST_COMMENT_1", "GET_REQUEST_COMMENT_2", "GET_REQUEST_COMMENTS", "GET_REQUEST_COMMENTS_1", "GET_REQUESTS", "GET_SATISFACTION_RATING", "GET_SATISFACTION_RATINGS", "GET_SCHEDULE", "GET_SCHEDULE_1", "GET_SCHEDULES", "GET_SEARCH_RESULTS", "GET_SEARCH_RESULTS_1", "GET_SEARCH_RESULTS_2", "GET_SEARCH_RESULTS_3", "GET_SEARCH_RESULTS_4", "GET_SECTION", "GET_SECTION_SUBSCRIPTIONS", "GET_SECTION_SUBSCRIPTIONS_1", "GET_SECTION_TRANSLATIONS", "GET_SECTIONS", "GET_SECTIONS_1", "GET_SECTIONS_2", "GET_SOLVED_REQUESTS", "GET_SUSPENDED_TICKETS", "GET_TARGET", "GET_TARGETS", "GET_TICKET", "GET_TICKET_AUDIT", "GET_TICKET_AUDIT_1", "GET_TICKET_AUDIT_2", "GET_TICKET_AUDITS", "GET_TICKET_AUDITS_1", "GET_TICKET_COLLABORATORS", "GET_TICKET_COMMENTS", "GET_TICKET_COMMENTS_1", "GET_TICKET_FIELD", "GET_TICKET_FIELDS", "GET_TICKET_FORM", "GET_TICKET_FORMS", "GET_TICKET_INCIDENTS", "GET_TICKET_METRIC", "GET_TICKET_METRIC_BY_TICKET", "GET_TICKET_METRICS", "GET_TICKETS", "GET_TICKETS_1", "GET_TICKETS_BY_EXTERNAL_ID", "GET_TICKETS_BY_EXTERNAL_ID_1", "GET_TICKETS_FROM_SEARCH", "GET_TICKETS_INCREMENTALLY", "GET_TICKETS_INCREMENTALLY_1", "GET_TOPIC", "GET_TOPICS", "GET_TOPICS_1", "GET_TOPICS_2", "GET_TOPICS_3", "GET_TOPICS_BY_USER", "GET_TRIGGER", "GET_TRIGGERS", "GET_TWITTER_MONITORS", "GET_USER", "GET_USER_CCD_TICKETS", "GET_USER_FIELDS", "GET_USER_IDENTITIES", "GET_USER_IDENTITIES_1", "GET_USER_IDENTITY", "GET_USER_IDENTITY_1", "GET_USER_IDENTITY_2", "GET_USER_RELATED_INFO", "GET_USER_REQUESTED_TICKETS", "GET_USER_REQUESTS", "GET_USER_REQUESTS_1", "GET_USER_SEGMENT", "GET_USER_SEGMENTS", "GET_USER_SEGMENTS_1", "GET_USER_SEGMENTS_APPLICABLE", "GET_USER_SUBSCRIPTIONS", "GET_USER_SUBSCRIPTIONS_1", "GET_USERS", "GET_USERS_BY_ROLE", "GET_USERS_INCREMENTALLY", "IMPORT_TICKET", "IMPORT_TOPIC", "LOOKUP_ORGANIZATIONS_BY_EXTERNAL_ID", "LOOKUP_USER_BY_EMAIL", "LOOKUP_USER_BY_EXTERNAL_ID", "MACROS_SHOW_CHANGES_TO_TICKET", "MACROS_SHOW_TICKET_AFTER_CHANGES", "MAKE_PRIVATE_TICKET_AUDIT", "MAKE_PRIVATE_TICKET_AUDIT_1", "MAKE_PRIVATE_TICKET_AUDIT_2", "MARK_TICKET_AS_SPAM", "MARK_TICKET_AS_SPAM_1", "MERGE_USERS", "NOTIFY_APP", "PERMANENTLY_DELETE_TICKET", "PERMANENTLY_DELETE_TICKET_1", "PERMANENTLY_DELETE_TICKETS", "PERMANENTLY_DELETE_USER", "PERMANENTLY_DELETE_USER_1", "QUEUE_CREATE_TICKET_ASYNC", "REMOVE_TAG_FROM_ORGANISATIONS", "REMOVE_TAG_FROM_TICKET", "REMOVE_TAG_FROM_TOPICS", "REQUEST_VERIFY_USER_IDENTITY", "REQUEST_VERIFY_USER_IDENTITY_1", "REQUEST_VERIFY_USER_IDENTITY_2", "RESET_USER_PASSWORD", "RESET_USER_PASSWORD_1", "SET_GROUP_MEMBERSHIP_AS_DEFAULT", "SET_ORGANIZATION_MEMBERSHIP_AS_DEFAULT", "SET_TAG_ON_ORGANISATIONS", "SET_TAG_ON_TICKET", "SET_TAG_ON_TOPICS", "SET_USER_PRIMARY_IDENTITY", "SET_USER_PRIMARY_IDENTITY_1", "SET_USER_PRIMARY_IDENTITY_2", "SUSPEND_USER", "TRUST_TICKET_AUDIT", "TRUST_TICKET_AUDIT_1", "TRUST_TICKET_AUDIT_2", "UNSUSPEND_USER", "UPDATE_ARTICLE", "UPDATE_ARTICLE_TRANSLATION", "UPDATE_AUTOMATION", "UPDATE_CATEGORY", "UPDATE_CATEGORY_TRANSLATION", "UPDATE_DYNAMIC_CONTENT_ITEM", "UPDATE_DYNAMIC_CONTENT_ITEM_VARIANT", "UPDATE_FORUM", "UPDATE_GROUP", "UPDATE_INSTALLATION", "UPDATE_MACRO", "UPDATE_ORGANIZATION", "UPDATE_ORGANIZATIONS", "UPDATE_ORGANIZATIONS_1", "UPDATE_ORGANIZATIONS_ASYNC", "UPDATE_PERMISSION_GROUP", "UPDATE_REQUEST", "UPDATE_SECTION", "UPDATE_SECTION_TRANSLATION", "UPDATE_TICKET", "UPDATE_TICKET_FIELD", "UPDATE_TICKETS", "UPDATE_TICKETS_1", "UPDATE_TICKETS_ASYNC", "UPDATE_TOPIC", "UPDATE_TRIGGER", "UPDATE_USER", "UPDATE_USER_IDENTITY", "UPDATE_USER_IDENTITY_1", "UPDATE_USER_SEGMENT", "UPDATE_USERS", "UPDATE_USERS_1", "UPDATE_USERS_ASYNC", "VERIFY_USER_IDENTITY", "VERIFY_USER_IDENTITY_1", "VERIFY_USER_IDENTITY_2" ],
          "type" : "string"
        },
        "backoff-error-threshold" : {
          "description" : "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-idle-threshold" : {
          "description" : "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
          "type" : "integer"
        },
        "backoff-multiplier" : {
          "description" : "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
          "type" : "integer"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "delay" : {
          "description" : "Milliseconds before the next poll.",
          "default" : "500",
          "type" : "integer"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "greedy" : {
          "description" : "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
          "default" : "false",
          "type" : "boolean"
        },
        "in-body" : {
          "description" : "Sets the name of a parameter to be passed in the exchange In Body",
          "type" : "string"
        },
        "initial-delay" : {
          "description" : "Milliseconds before the first poll starts.",
          "default" : "1000",
          "type" : "integer"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "oauth-token" : {
          "description" : "The OAuth token.",
          "type" : "string"
        },
        "password" : {
          "description" : "The password.",
          "type" : "string"
        },
        "poll-strategy" : {
          "description" : "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
          "type" : "string"
        },
        "repeat-count" : {
          "description" : "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
          "default" : "0",
          "type" : "integer"
        },
        "run-logging-level" : {
          "description" : "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
          "default" : "TRACE",
          "enum" : [ "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF" ],
          "type" : "string"
        },
        "scheduled-executor-service" : {
          "description" : "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
          "type" : "string"
        },
        "scheduler" : {
          "description" : "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
          "default" : "none",
          "type" : "string"
        },
        "scheduler-properties" : {
          "description" : "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
          "type" : "string"
        },
        "send-empty-message-when-idle" : {
          "description" : "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
          "default" : "false",
          "type" : "boolean"
        },
        "server-url" : {
          "description" : "The server URL to connect.",
          "type" : "string"
        },
        "start-scheduler" : {
          "description" : "Whether the scheduler should be auto started.",
          "default" : "true",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "time-unit" : {
          "description" : "Time unit for initialDelay and delay options.",
          "default" : "MILLISECONDS",
          "enum" : [ "NANOSECONDS", "MICROSECONDS", "MILLISECONDS", "SECONDS", "MINUTES", "HOURS", "DAYS" ],
          "type" : "string"
        },
        "token" : {
          "description" : "The security token.",
          "type" : "string"
        },
        "use-fixed-delay" : {
          "description" : "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
          "default" : "true",
          "type" : "boolean"
        },
        "username" : {
          "description" : "The user name.",
          "type" : "string"
        }
      }
    },
    "zookeeper" : {
      "type" : "object",
      "required" : [ "path", "serverUrls" ],
      "properties" : {
        "path" : {
          "description" : "The node in the ZooKeeper server (aka znode)",
          "type" : "string"
        },
        "server-urls" : {
          "description" : "The zookeeper server hosts (multiple servers can be separated by comma)",
          "type" : "string"
        },
        "backoff" : {
          "description" : "The time interval to backoff for after an error before retrying.",
          "default" : "5000",
          "type" : "integer"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "create" : {
          "description" : "Should the endpoint create the node if it does not currently exist.",
          "default" : "false",
          "type" : "boolean"
        },
        "create-mode" : {
          "description" : "The create mode that should be used for the newly created node",
          "default" : "EPHEMERAL",
          "enum" : [ "PERSISTENT", "PERSISTENT_SEQUENTIAL", "EPHEMERAL", "EPHEMERAL_SEQUENTIAL" ],
          "type" : "string"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "lazy-start-producer" : {
          "description" : "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
          "default" : "false",
          "type" : "boolean"
        },
        "list-children" : {
          "description" : "Whether the children of the node should be listed",
          "default" : "false",
          "type" : "boolean"
        },
        "repeat" : {
          "description" : "Should changes to the znode be 'watched' and repeatedly processed.",
          "default" : "false",
          "type" : "boolean"
        },
        "send-empty-message-on-delete" : {
          "description" : "Upon the delete of a znode, should an empty message be send to the consumer",
          "default" : "true",
          "type" : "boolean"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        },
        "timeout" : {
          "description" : "The time interval to wait on connection before timing out.",
          "default" : "5000",
          "type" : "integer"
        }
      }
    },
    "zookeeper-master" : {
      "type" : "object",
      "required" : [ "consumerEndpointUri", "groupName" ],
      "properties" : {
        "consumer-endpoint-uri" : {
          "description" : "The consumer endpoint to use in master/slave mode",
          "type" : "string"
        },
        "group-name" : {
          "description" : "The name of the cluster group to use",
          "type" : "string"
        },
        "bridge-error-handler" : {
          "description" : "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "default" : "false",
          "type" : "boolean"
        },
        "exception-handler" : {
          "description" : "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
          "type" : "string"
        },
        "exchange-pattern" : {
          "description" : "Sets the exchange pattern when the consumer creates an exchange.",
          "enum" : [ "InOnly", "InOut", "InOptionalOut" ],
          "type" : "string"
        },
        "synchronous" : {
          "description" : "Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).",
          "default" : "false",
          "type" : "boolean"
        }
      }
    }
  }
}